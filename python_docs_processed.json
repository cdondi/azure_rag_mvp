[
  {
    "id": "appetite_chunk_0",
    "source_file": "appetite",
    "chunk_index": 0,
    "content": "1. Whetting Your AppetiteÂ¶ If you do much work on computers, eventually you find that thereâs some task youâd like to automate. For example, you may wish to perform a search-and-replace over a large number of text files, or rename and rearrange a bunch of photo files in a complicated way. Perhaps youâd like to write a small custom database, or a specialized GUI application, or a simple game. If youâre a professional software developer, you may have to work with several C/C++/Java libraries but find the usual write/compile/test/re-compile cycle is too slow. Perhaps youâre writing a test suite for such a library and find writing the testing code a tedious task. Or maybe youâve written a program that could use an extension language, and you donât want to design and implement a whole new language for your application. Python is just the language for you. You could write a Unix shell script or Windows batch files for some of these tasks, but shell scripts are best at moving around files and changing text data, not well-suited for GUI applications or games. You could write a C/C++/Java program, but it can take a lot of development time to get even a first-draft program. Python is simpler to use, available on Windows, macOS, and Unix operating systems, and will help you get the job done more quickly. Python is simple to use, but it is a real programming language, offering much more structure and support for large programs than shell scripts or batch files can offer. On the other hand, Python also offers much more error checking than C, and, being a very-high-level language, it has high-level data types built in, such as flexible arrays and dictionaries. Because of its more general data types Python is applicable to a much larger problem domain than Awk or even Perl, yet many things are at least as easy in Python as in those languages. Python allows you to split your program into modules that can be reused in other Python programs. It comes with a large collection of standard modules that you can use as the basis of your programs â or as examples to start learning to program in Python. Some of these modules provide things like file I/O, system calls, sockets, and even interfaces to graphical user interface toolkits like Tk. Python is an interpreted language, which can save you considerable time during program development because no compilation and linking is necessary. The interpreter can be used interactively, which makes it easy to experiment with features of the language, to write throw-away programs, or to test functions during bottom-up program development. It is also a handy desk calculator. Python enables programs to be written compactly and readably. Programs written in Python are typically much shorter than equivalent C, C++, or Java programs, for several reasons: the high-level data types allow you to express complex operations in a single statement; statement grouping is done by indentation instead of beginning and ending brackets;",
    "content_length": 3005
  },
  {
    "id": "appetite_chunk_1",
    "source_file": "appetite",
    "chunk_index": 1,
    "content": "to be written compactly and readably. Programs written in Python are typically much shorter than equivalent C, C++, or Java programs, for several reasons: the high-level data types allow you to express complex operations in a single statement; statement grouping is done by indentation instead of beginning and ending brackets; no variable or argument declarations are necessary. Python is extensible: if you know how to program in C it is easy to add a new built-in function or module to the interpreter, either to perform critical operations at maximum speed, or to link Python programs to libraries that may only be available in binary form (such as a vendor-specific graphics library). Once you are really hooked, you can link the Python interpreter into an application written in C and use it as an extension or command language for that application. By the way, the language is named after the BBC show âMonty Pythonâs Flying Circusâ and has nothing to do with reptiles. Making references to Monty Python skits in documentation is not only allowed, it is encouraged! Now that you are all excited about Python, youâll want to examine it in some more detail. Since the best way to learn a language is to use it, the tutorial invites you to play with the Python interpreter as you read. In the next chapter, the mechanics of using the interpreter are explained. This is rather mundane information, but essential for trying out the examples shown later. The rest of the tutorial introduces various features of the Python language and system through examples, beginning with simple expressions, statements and data types, through functions and modules, and finally touching upon advanced concepts like exceptions and user-defined classes.",
    "content_length": 1747
  },
  {
    "id": "stdlib_chunk_0",
    "source_file": "stdlib",
    "chunk_index": 0,
    "content": "10. Brief Tour of the Standard LibraryÂ¶ 10.1. Operating System InterfaceÂ¶ The os module provides dozens of functions for interacting with the operating system: >>> import os >>> os.getcwd() # Return the current working directory 'C:\\\\Python313' >>> os.chdir('/server/accesslogs') # Change current working directory >>> os.system('mkdir today') # Run the command mkdir in the system shell 0 Be sure to use the import os style instead of from os import *. This will keep os.open() from shadowing the built-in open() function which operates much differently. The built-in dir() and help() functions are useful as interactive aids for working with large modules like os: >>> import os >>> dir(os) <returns a list of all module functions> >>> help(os) <returns an extensive manual page created from the module's docstrings> For daily file and directory management tasks, the shutil module provides a higher level interface that is easier to use: >>> import shutil >>> shutil.copyfile('data.db', 'archive.db') 'archive.db' >>> shutil.move('/build/executables', 'installdir') 'installdir' 10.2. File WildcardsÂ¶ The glob module provides a function for making file lists from directory wildcard searches: >>> import glob >>> glob.glob('*.py') ['primes.py', 'random.py', 'quote.py'] 10.3. Command Line ArgumentsÂ¶ Common utility scripts often need to process command line arguments. These arguments are stored in the sys moduleâs argv attribute as a list. For instance, letâs take the following demo.py file: # File demo.py import sys print(sys.argv) Here is the output from running python demo.py one two three at the command line: ['demo.py', 'one', 'two', 'three'] The argparse module provides a more sophisticated mechanism to process command line arguments. The following script extracts one or more filenames and an optional number of lines to be displayed: import argparse parser = argparse.ArgumentParser( prog='top', description='Show top lines from each file') parser.add_argument('filenames', nargs='+') parser.add_argument('-l', '--lines', type=int, default=10) args = parser.parse_args() print(args) When run at the command line with python top.py --lines=5 alpha.txt beta.txt, the script sets args.lines to 5 and args.filenames to ['alpha.txt', 'beta.txt']. 10.4. Error Output Redirection and Program TerminationÂ¶ The sys module also has attributes for stdin, stdout, and stderr. The latter is useful for emitting warnings and error messages to make them visible even when stdout has been redirected: >>> sys.stderr.write('Warning, log file not found starting a new one\\n') Warning, log file not found starting a new one The most direct way to terminate a script is to use sys.exit(). 10.5. String Pattern MatchingÂ¶ The re module provides regular expression tools for advanced string processing. For complex matching and manipulation, regular expressions offer succinct, optimized solutions: >>> import re >>> re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest') ['foot', 'fell', 'fastest'] >>> re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat') 'cat in the hat' When only simple capabilities are needed, string methods are preferred because they are easier to read and debug: >>> 'tea for too'.replace('too', 'two') 'tea for two' 10.6. MathematicsÂ¶ The math module gives access to the underlying C library functions for floating-point math: >>> import math >>> math.cos(math.pi / 4) 0.70710678118654757 >>> math.log(1024, 2) 10.0 The random module provides tools for making",
    "content_length": 3498
  },
  {
    "id": "stdlib_chunk_1",
    "source_file": "stdlib",
    "chunk_index": 1,
    "content": "they are easier to read and debug: >>> 'tea for too'.replace('too', 'two') 'tea for two' 10.6. MathematicsÂ¶ The math module gives access to the underlying C library functions for floating-point math: >>> import math >>> math.cos(math.pi / 4) 0.70710678118654757 >>> math.log(1024, 2) 10.0 The random module provides tools for making random selections: >>> import random >>> random.choice(['apple', 'pear', 'banana']) 'apple' >>> random.sample(range(100), 10) # sampling without replacement [30, 83, 16, 4, 8, 81, 41, 50, 18, 33] >>> random.random() # random float from the interval [0.0, 1.0) 0.17970987693706186 >>> random.randrange(6) # random integer chosen from range(6) 4 The statistics module calculates basic statistical properties (the mean, median, variance, etc.) of numeric data: >>> import statistics >>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5] >>> statistics.mean(data) 1.6071428571428572 >>> statistics.median(data) 1.25 >>> statistics.variance(data) 1.3720238095238095 The SciPy project <https://scipy.org> has many other modules for numerical computations. 10.7. Internet AccessÂ¶ There are a number of modules for accessing the internet and processing internet protocols. Two of the simplest are urllib.request for retrieving data from URLs and smtplib for sending mail: >>> from urllib.request import urlopen >>> with urlopen('http://worldtimeapi.org/api/timezone/etc/UTC.txt') as response: ... for line in response: ... line = line.decode() # Convert bytes to a str ... if line.startswith('datetime'): ... print(line.rstrip()) # Remove trailing newline ... datetime: 2022-01-01T01:36:47.689215+00:00 >>> import smtplib >>> server = smtplib.SMTP('localhost') >>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org', ... \"\"\"To: jcaesar@example.org ... From: soothsayer@example.org ... ... Beware the Ides of March. ... \"\"\") >>> server.quit() (Note that the second example needs a mailserver running on localhost.) 10.8. Dates and TimesÂ¶ The datetime module supplies classes for manipulating dates and times in both simple and complex ways. While date and time arithmetic is supported, the focus of the implementation is on efficient member extraction for output formatting and manipulation. The module also supports objects that are timezone aware. >>> # dates are easily constructed and formatted >>> from datetime import date >>> now = date.today() >>> now datetime.date(2003, 12, 2) >>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\") '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.' >>> # dates support calendar arithmetic >>> birthday = date(1964, 7, 31) >>> age = now - birthday >>> age.days 14368 10.9. Data CompressionÂ¶ Common data archiving and compression formats are directly supported by modules including: zlib, gzip, bz2, lzma, zipfile and tarfile. >>> import zlib >>> s = b'witch which has which witches wrist watch' >>> len(s) 41 >>> t = zlib.compress(s) >>> len(t) 37 >>> zlib.decompress(t) b'witch which has which witches wrist watch' >>> zlib.crc32(s) 226805979 10.10. Performance MeasurementÂ¶ Some Python users develop a deep interest in knowing the relative performance of different approaches to the same problem. Python provides a measurement tool that answers those questions immediately. For example, it may be tempting to use the tuple packing and unpacking feature instead of the traditional approach to swapping arguments. The timeit module quickly demonstrates a modest performance advantage: >>> from timeit import Timer >>>",
    "content_length": 3526
  },
  {
    "id": "stdlib_chunk_2",
    "source_file": "stdlib",
    "chunk_index": 2,
    "content": "the same problem. Python provides a measurement tool that answers those questions immediately. For example, it may be tempting to use the tuple packing and unpacking feature instead of the traditional approach to swapping arguments. The timeit module quickly demonstrates a modest performance advantage: >>> from timeit import Timer >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit() 0.57535828626024577 >>> Timer('a,b = b,a', 'a=1; b=2').timeit() 0.54962537085770791 In contrast to timeitâs fine level of granularity, the profile and pstats modules provide tools for identifying time critical sections in larger blocks of code. 10.11. Quality ControlÂ¶ One approach for developing high quality software is to write tests for each function as it is developed and to run those tests frequently during the development process. The doctest module provides a tool for scanning a module and validating tests embedded in a programâs docstrings. Test construction is as simple as cutting-and-pasting a typical call along with its results into the docstring. This improves the documentation by providing the user with an example and it allows the doctest module to make sure the code remains true to the documentation: def average(values): \"\"\"Computes the arithmetic mean of a list of numbers. >>> print(average([20, 30, 70])) 40.0 \"\"\" return sum(values) / len(values) import doctest doctest.testmod() # automatically validate the embedded tests The unittest module is not as effortless as the doctest module, but it allows a more comprehensive set of tests to be maintained in a separate file: import unittest class TestStatisticalFunctions(unittest.TestCase): def test_average(self): self.assertEqual(average([20, 30, 70]), 40.0) self.assertEqual(round(average([1, 5, 7]), 1), 4.3) with self.assertRaises(ZeroDivisionError): average([]) with self.assertRaises(TypeError): average(20, 30, 70) unittest.main() # Calling from the command line invokes all tests 10.12. Batteries IncludedÂ¶ Python has a âbatteries includedâ philosophy. This is best seen through the sophisticated and robust capabilities of its larger packages. For example: The xmlrpc.client and xmlrpc.server modules make implementing remote procedure calls into an almost trivial task. Despite the modulesâ names, no direct knowledge or handling of XML is needed. The email package is a library for managing email messages, including MIME and other RFC 2822-based message documents. Unlike smtplib and poplib which actually send and receive messages, the email package has a complete toolset for building or decoding complex message structures (including attachments) and for implementing internet encoding and header protocols. The json package provides robust support for parsing this popular data interchange format. The csv module supports direct reading and writing of files in Comma-Separated Value format, commonly supported by databases and spreadsheets. XML processing is supported by the xml.etree.ElementTree, xml.dom and xml.sax packages. Together, these modules and packages greatly simplify data interchange between Python applications and other tools. The sqlite3 module is a wrapper for the SQLite database library, providing a persistent database that can be updated and accessed using slightly nonstandard SQL syntax. Internationalization is supported by a number of modules including gettext, locale, and the codecs package.",
    "content_length": 3409
  },
  {
    "id": "stdlib_chunk_3",
    "source_file": "stdlib",
    "chunk_index": 3,
    "content": "that can be updated and accessed using slightly nonstandard SQL syntax. Internationalization is supported by a number of modules including gettext, locale, and the codecs package.",
    "content_length": 179
  },
  {
    "id": "functions_chunk_0",
    "source_file": "functions",
    "chunk_index": 0,
    "content": "Built-in FunctionsÂ¶ The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order. Built-in Functions A abs() aiter() all() anext() any() ascii() B bin() bool() breakpoint() bytearray() bytes() C callable() chr() classmethod() compile() complex() D delattr() dict() dir() divmod() E enumerate() eval() exec() F filter() float() format() frozenset() G getattr() globals() H hasattr() hash() help() hex() I id() input() int() isinstance() issubclass() iter() L len() list() locals() M map() max() memoryview() min() N next() O object() oct() open() ord() P pow() print() property() R range() repr() reversed() round() S set() setattr() slice() sorted() staticmethod() str() sum() super() T tuple() type() V vars() Z zip() _ __import__() abs(number, /)Â¶ Return the absolute value of a number. The argument may be an integer, a floating-point number, or an object implementing __abs__(). If the argument is a complex number, its magnitude is returned. aiter(async_iterable, /)Â¶ Return an asynchronous iterator for an asynchronous iterable. Equivalent to calling x.__aiter__(). Note: Unlike iter(), aiter() has no 2-argument variant. Added in version 3.10. all(iterable, /)Â¶ Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: def all(iterable): for element in iterable: if not element: return False return True awaitable anext(async_iterator, /)Â¶ awaitable anext(async_iterator, default, /) When awaited, return the next item from the given asynchronous iterator, or default if given and the iterator is exhausted. This is the async variant of the next() builtin, and behaves similarly. This calls the __anext__() method of async_iterator, returning an awaitable. Awaiting this returns the next value of the iterator. If default is given, it is returned if the iterator is exhausted, otherwise StopAsyncIteration is raised. Added in version 3.10. any(iterable, /)Â¶ Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to: def any(iterable): for element in iterable: if element: return True return False ascii(object, /)Â¶ As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by repr() using \\x, \\u, or \\U escapes. This generates a string similar to that returned by repr() in Python 2. bin(integer, /)Â¶ Convert an integer number to a binary string prefixed with â0bâ. The result is a valid Python expression. If integer is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> bin(3) '0b11' >>> bin(-10) '-0b1010' If the prefix â0bâ is desired or not, you can use either of the following ways. >>> format(14, '#b'), format(14, 'b') ('0b1110', '1110') >>> f'{14:#b}', f'{14:b}' ('0b1110', '1110') See also format() for more information. class bool(object=False, /)Â¶ Return a Boolean value, i.e. one of True or False. The argument is converted using the standard truth testing procedure. If the argument is false or omitted, this returns False; otherwise, it returns True. The bool class is a subclass of int (see Numeric Types â int, float, complex).",
    "content_length": 3280
  },
  {
    "id": "functions_chunk_1",
    "source_file": "functions",
    "chunk_index": 1,
    "content": "/)Â¶ Return a Boolean value, i.e. one of True or False. The argument is converted using the standard truth testing procedure. If the argument is false or omitted, this returns False; otherwise, it returns True. The bool class is a subclass of int (see Numeric Types â int, float, complex). It cannot be subclassed further. Its only instances are False and True (see Boolean Type - bool). Changed in version 3.7: The parameter is now positional-only. breakpoint(*args, **kws)Â¶ This function drops you into the debugger at the call site. Specifically, it calls sys.breakpointhook(), passing args and kws straight through. By default, sys.breakpointhook() calls pdb.set_trace() expecting no arguments. In this case, it is purely a convenience function so you donât have to explicitly import pdb or type as much code to enter the debugger. However, sys.breakpointhook() can be set to some other function and breakpoint() will automatically call that, allowing you to drop into the debugger of choice. If sys.breakpointhook() is not accessible, this function will raise RuntimeError. By default, the behavior of breakpoint() can be changed with the PYTHONBREAKPOINT environment variable. See sys.breakpointhook() for usage details. Note that this is not guaranteed if sys.breakpointhook() has been replaced. Raises an auditing event builtins.breakpoint with argument breakpointhook. Added in version 3.7. class bytearray(source=b'') class bytearray(source, encoding, errors='strict') Return a new array of bytes. The bytearray class is a mutable sequence of integers in the range 0 <= x < 256. It has most of the usual methods of mutable sequences, described in Mutable Sequence Types, as well as most methods that the bytes type has, see Bytes and Bytearray Operations. The optional source parameter can be used to initialize the array in a few different ways: If it is a string, you must also give the encoding (and optionally, errors) parameters; bytearray() then converts the string to bytes using str.encode(). If it is an integer, the array will have that size and will be initialized with null bytes. If it is an object conforming to the buffer interface, a read-only buffer of the object will be used to initialize the bytes array. If it is an iterable, it must be an iterable of integers in the range 0 <= x < 256, which are used as the initial contents of the array. Without an argument, an array of size 0 is created. See also Binary Sequence Types â bytes, bytearray, memoryview and Bytearray Objects. class bytes(source=b'') class bytes(source, encoding, errors='strict') Return a new âbytesâ object which is an immutable sequence of integers in the range 0 <= x < 256. bytes is an immutable version of bytearray â it has the same non-mutating methods and the same indexing and slicing behavior. Accordingly, constructor arguments are interpreted as for bytearray(). Bytes objects can also be created with literals, see String and Bytes literals. See also Binary Sequence Types â bytes, bytearray, memoryview, Bytes Objects, and Bytes and Bytearray Operations. callable(object, /)Â¶ Return True if the object argument appears callable, False if not. If",
    "content_length": 3175
  },
  {
    "id": "functions_chunk_2",
    "source_file": "functions",
    "chunk_index": 2,
    "content": "constructor arguments are interpreted as for bytearray(). Bytes objects can also be created with literals, see String and Bytes literals. See also Binary Sequence Types â bytes, bytearray, memoryview, Bytes Objects, and Bytes and Bytearray Operations. callable(object, /)Â¶ Return True if the object argument appears callable, False if not. If this returns True, it is still possible that a call fails, but if it is False, calling object will never succeed. Note that classes are callable (calling a class returns a new instance); instances are callable if their class has a __call__() method. Added in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2. chr(codepoint, /)Â¶ Return the string representing a character with the specified Unicode code point. For example, chr(97) returns the string 'a', while chr(8364) returns the string 'â¬'. This is the inverse of ord(). The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in base 16). ValueError will be raised if it is outside that range. @classmethodÂ¶ Transform a method into a class method. A class method receives the class as an implicit first argument, just like an instance method receives the instance. To declare a class method, use this idiom: class C: @classmethod def f(cls, arg1, arg2): ... The @classmethod form is a function decorator â see Function definitions for details. A class method can be called either on the class (such as C.f()) or on an instance (such as C().f()). The instance is ignored except for its class. If a class method is called for a derived class, the derived class object is passed as the implied first argument. Class methods are different than C++ or Java static methods. If you want those, see staticmethod() in this section. For more information on class methods, see The standard type hierarchy. Changed in version 3.9: Class methods can now wrap other descriptors such as property(). Changed in version 3.10: Class methods now inherit the method attributes (__module__, __name__, __qualname__, __doc__ and __annotations__) and have a new __wrapped__ attribute. Deprecated since version 3.11, removed in version 3.13: Class methods can no longer wrap other descriptors such as property(). compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)Â¶ Compile the source into a code or AST object. Code objects can be executed by exec() or eval(). source can either be a normal string, a byte string, or an AST object. Refer to the ast module documentation for information on how to work with AST objects. The filename argument should give the file from which the code was read; pass some recognizable value if it wasnât read from a file ('<string>' is commonly used). The mode argument specifies what kind of code must be compiled; it can be 'exec' if source consists of a sequence of statements, 'eval' if it consists of a single expression, or 'single' if it consists of a single interactive statement (in the latter case, expression statements that evaluate to something other than None will be printed). The",
    "content_length": 3094
  },
  {
    "id": "functions_chunk_3",
    "source_file": "functions",
    "chunk_index": 3,
    "content": "must be compiled; it can be 'exec' if source consists of a sequence of statements, 'eval' if it consists of a single expression, or 'single' if it consists of a single interactive statement (in the latter case, expression statements that evaluate to something other than None will be printed). The optional arguments flags and dont_inherit control which compiler options should be activated and which future features should be allowed. If neither is present (or both are zero) the code is compiled with the same flags that affect the code that is calling compile(). If the flags argument is given and dont_inherit is not (or is zero) then the compiler options and the future statements specified by the flags argument are used in addition to those that would be used anyway. If dont_inherit is a non-zero integer then the flags argument is it â the flags (future features and compiler options) in the surrounding code are ignored. Compiler options and future statements are specified by bits which can be bitwise ORed together to specify multiple options. The bitfield required to specify a given future feature can be found as the compiler_flag attribute on the _Feature instance in the __future__ module. Compiler flags can be found in ast module, with PyCF_ prefix. The argument optimize specifies the optimization level of the compiler; the default value of -1 selects the optimization level of the interpreter as given by -O options. Explicit levels are 0 (no optimization; __debug__ is true), 1 (asserts are removed, __debug__ is false) or 2 (docstrings are removed too). This function raises SyntaxError if the compiled source is invalid, and ValueError if the source contains null bytes. If you want to parse Python code into its AST representation, see ast.parse(). Raises an auditing event compile with arguments source and filename. This event may also be raised by implicit compilation. Note When compiling a string with multi-line code in 'single' or 'eval' mode, input must be terminated by at least one newline character. This is to facilitate detection of incomplete and complete statements in the code module. Warning It is possible to crash the Python interpreter with a sufficiently large/complex string when compiling to an AST object due to stack depth limitations in Pythonâs AST compiler. Changed in version 3.2: Allowed use of Windows and Mac newlines. Also, input in 'exec' mode does not have to end in a newline anymore. Added the optimize parameter. Changed in version 3.5: Previously, TypeError was raised when null bytes were encountered in source. Added in version 3.8: ast.PyCF_ALLOW_TOP_LEVEL_AWAIT can now be passed in flags to enable support for top-level await, async for, and async with. class complex(number=0, /)Â¶ class complex(string, /) class complex(real=0, imag=0) Convert a single string or number to a complex number, or create a complex number from real and imaginary parts. Examples: >>> complex('+1.23') (1.23+0j) >>> complex('-4.5j') -4.5j >>> complex('-1.23+4.5j') (-1.23+4.5j) >>> complex('\\t( -1.23+4.5J )\\n') (-1.23+4.5j) >>> complex('-Infinity+NaNj') (-inf+nanj) >>> complex(1.23) (1.23+0j) >>> complex(imag=-4.5) -4.5j >>> complex(-1.23, 4.5) (-1.23+4.5j) If the",
    "content_length": 3221
  },
  {
    "id": "functions_chunk_4",
    "source_file": "functions",
    "chunk_index": 4,
    "content": "Convert a single string or number to a complex number, or create a complex number from real and imaginary parts. Examples: >>> complex('+1.23') (1.23+0j) >>> complex('-4.5j') -4.5j >>> complex('-1.23+4.5j') (-1.23+4.5j) >>> complex('\\t( -1.23+4.5J )\\n') (-1.23+4.5j) >>> complex('-Infinity+NaNj') (-inf+nanj) >>> complex(1.23) (1.23+0j) >>> complex(imag=-4.5) -4.5j >>> complex(-1.23, 4.5) (-1.23+4.5j) If the argument is a string, it must contain either a real part (in the same format as for float()) or an imaginary part (in the same format but with a 'j' or 'J' suffix), or both real and imaginary parts (the sign of the imaginary part is mandatory in this case). The string can optionally be surrounded by whitespaces and the round parentheses '(' and ')', which are ignored. The string must not contain whitespace between '+', '-', the 'j' or 'J' suffix, and the decimal number. For example, complex('1+2j') is fine, but complex('1 + 2j') raises ValueError. More precisely, the input must conform to the complexvalue production rule in the following grammar, after parentheses and leading and trailing whitespace characters are removed: complexvalue ::= floatvalue | floatvalue (\"j\" | \"J\") | floatvalue sign absfloatvalue (\"j\" | \"J\") If the argument is a number, the constructor serves as a numeric conversion like int and float. For a general Python object x, complex(x) delegates to x.__complex__(). If __complex__() is not defined then it falls back to __float__(). If __float__() is not defined then it falls back to __index__(). If two arguments are provided or keyword arguments are used, each argument may be any numeric type (including complex). If both arguments are real numbers, return a complex number with the real component real and the imaginary component imag. If both arguments are complex numbers, return a complex number with the real component real.real-imag.imag and the imaginary component real.imag+imag.real. If one of arguments is a real number, only its real component is used in the above expressions. If all arguments are omitted, returns 0j. The complex type is described in Numeric Types â int, float, complex. Changed in version 3.6: Grouping digits with underscores as in code literals is allowed. Changed in version 3.8: Falls back to __index__() if __complex__() and __float__() are not defined. delattr(object, name, /)Â¶ This is a relative of setattr(). The arguments are an object and a string. The string must be the name of one of the objectâs attributes. The function deletes the named attribute, provided the object allows it. For example, delattr(x, 'foobar') is equivalent to del x.foobar. name need not be a Python identifier (see setattr()). class dict(**kwargs) class dict(mapping, /, **kwargs) class dict(iterable, /, **kwargs) Create a new dictionary. The dict object is the dictionary class. See dict and Mapping Types â dict for documentation about this class. For other containers see the built-in list, set, and tuple classes, as well as the collections module. dir()Â¶ dir(object, /) Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object. If the",
    "content_length": 3207
  },
  {
    "id": "functions_chunk_5",
    "source_file": "functions",
    "chunk_index": 5,
    "content": "this class. For other containers see the built-in list, set, and tuple classes, as well as the collections module. dir()Â¶ dir(object, /) Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object. If the object has a method named __dir__(), this method will be called and must return the list of attributes. This allows objects that implement a custom __getattr__() or __getattribute__() function to customize the way dir() reports their attributes. If the object does not provide __dir__(), the function tries its best to gather information from the objectâs __dict__ attribute, if defined, and from its type object. The resulting list is not necessarily complete and may be inaccurate when the object has a custom __getattr__(). The default dir() mechanism behaves differently with different types of objects, as it attempts to produce the most relevant, rather than complete, information: If the object is a module object, the list contains the names of the moduleâs attributes. If the object is a type or class object, the list contains the names of its attributes, and recursively of the attributes of its bases. Otherwise, the list contains the objectâs attributesâ names, the names of its classâs attributes, and recursively of the attributes of its classâs base classes. The resulting list is sorted alphabetically. For example: >>> import struct >>> dir() # show the names in the module namespace ['__builtins__', '__name__', 'struct'] >>> dir(struct) # show the names in the struct module ['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__initializing__', '__loader__', '__name__', '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into', 'unpack', 'unpack_from'] >>> class Shape: ... def __dir__(self): ... return ['area', 'perimeter', 'location'] ... >>> s = Shape() >>> dir(s) ['area', 'location', 'perimeter'] Note Because dir() is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names, and its detailed behavior may change across releases. For example, metaclass attributes are not in the result list when the argument is a class. divmod(a, b, /)Â¶ Take two (non-complex) numbers as arguments and return a pair of numbers consisting of their quotient and remainder when using integer division. With mixed operand types, the rules for binary arithmetic operators apply. For integers, the result is the same as (a // b, a % b). For floating-point numbers the result is (q, a % b), where q is usually math.floor(a / b) but may be 1 less than that. In any case q * b + a % b is very close to a, if a % b is non-zero it has the same sign as b, and 0 <= abs(a % b) < abs(b). enumerate(iterable, start=0)Â¶ Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from",
    "content_length": 3124
  },
  {
    "id": "functions_chunk_6",
    "source_file": "functions",
    "chunk_index": 6,
    "content": "has the same sign as b, and 0 <= abs(a % b) < abs(b). enumerate(iterable, start=0)Â¶ Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable. >>> seasons = ['Spring', 'Summer', 'Fall', 'Winter'] >>> list(enumerate(seasons)) [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')] >>> list(enumerate(seasons, start=1)) [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] Equivalent to: def enumerate(iterable, start=0): n = start for elem in iterable: yield n, elem n += 1 eval(source, /, globals=None, locals=None)Â¶ Parameters: source (str | code object) â A Python expression. globals (dict | None) â The global namespace (default: None). locals (mapping | None) â The local namespace (default: None). Returns: The result of the evaluated expression. Raises: Syntax errors are reported as exceptions. Warning This function executes arbitrary code. Calling it with user-supplied input may lead to security vulnerabilities. The expression argument is parsed and evaluated as a Python expression (technically speaking, a condition list) using the globals and locals mappings as global and local namespace. If the globals dictionary is present and does not contain a value for the key __builtins__, a reference to the dictionary of the built-in module builtins is inserted under that key before expression is parsed. That way you can control what builtins are available to the executed code by inserting your own __builtins__ dictionary into globals before passing it to eval(). If the locals mapping is omitted it defaults to the globals dictionary. If both mappings are omitted, the expression is executed with the globals and locals in the environment where eval() is called. Note, eval() will only have access to the nested scopes (non-locals) in the enclosing environment if they are already referenced in the scope that is calling eval() (e.g. via a nonlocal statement). Example: >>> x = 1 >>> eval('x+1') 2 This function can also be used to execute arbitrary code objects (such as those created by compile()). In this case, pass a code object instead of a string. If the code object has been compiled with 'exec' as the mode argument, eval()'s return value will be None. Hints: dynamic execution of statements is supported by the exec() function. The globals() and locals() functions return the current global and local dictionary, respectively, which may be useful to pass around for use by eval() or exec(). If the given source is a string, then leading and trailing spaces and tabs are stripped. See ast.literal_eval() for a function that can safely evaluate strings with expressions containing only literals. Raises an auditing event exec with the code object as the argument. Code compilation events may also be raised. Changed in version 3.13: The globals and locals arguments can now be passed as keywords. Changed in version 3.13: The semantics of the default locals namespace have been adjusted as described for",
    "content_length": 3185
  },
  {
    "id": "functions_chunk_7",
    "source_file": "functions",
    "chunk_index": 7,
    "content": "an auditing event exec with the code object as the argument. Code compilation events may also be raised. Changed in version 3.13: The globals and locals arguments can now be passed as keywords. Changed in version 3.13: The semantics of the default locals namespace have been adjusted as described for the locals() builtin. exec(source, /, globals=None, locals=None, *, closure=None)Â¶ Warning This function executes arbitrary code. Calling it with user-supplied input may lead to security vulnerabilities. This function supports dynamic execution of Python code. source must be either a string or a code object. If it is a string, the string is parsed as a suite of Python statements which is then executed (unless a syntax error occurs). [1] If it is a code object, it is simply executed. In all cases, the code thatâs executed is expected to be valid as file input (see the section File input in the Reference Manual). Be aware that the nonlocal, yield, and return statements may not be used outside of function definitions even within the context of code passed to the exec() function. The return value is None. In all cases, if the optional parts are omitted, the code is executed in the current scope. If only globals is provided, it must be a dictionary (and not a subclass of dictionary), which will be used for both the global and the local variables. If globals and locals are given, they are used for the global and local variables, respectively. If provided, locals can be any mapping object. Remember that at the module level, globals and locals are the same dictionary. Note When exec gets two separate objects as globals and locals, the code will be executed as if it were embedded in a class definition. This means functions and classes defined in the executed code will not be able to access variables assigned at the top level (as the âtop levelâ variables are treated as class variables in a class definition). If the globals dictionary does not contain a value for the key __builtins__, a reference to the dictionary of the built-in module builtins is inserted under that key. That way you can control what builtins are available to the executed code by inserting your own __builtins__ dictionary into globals before passing it to exec(). The closure argument specifies a closureâa tuple of cellvars. Itâs only valid when the object is a code object containing free (closure) variables. The length of the tuple must exactly match the length of the code objectâs co_freevars attribute. Raises an auditing event exec with the code object as the argument. Code compilation events may also be raised. Note The built-in functions globals() and locals() return the current global and local namespace, respectively, which may be useful to pass around for use as the second and third argument to exec(). Note The default locals act as described for function locals() below. Pass an explicit locals dictionary if you need to see effects of the code on locals after",
    "content_length": 2986
  },
  {
    "id": "functions_chunk_8",
    "source_file": "functions",
    "chunk_index": 8,
    "content": "global and local namespace, respectively, which may be useful to pass around for use as the second and third argument to exec(). Note The default locals act as described for function locals() below. Pass an explicit locals dictionary if you need to see effects of the code on locals after function exec() returns. Changed in version 3.11: Added the closure parameter. Changed in version 3.13: The globals and locals arguments can now be passed as keywords. Changed in version 3.13: The semantics of the default locals namespace have been adjusted as described for the locals() builtin. filter(function, iterable, /)Â¶ Construct an iterator from those elements of iterable for which function is true. iterable may be either a sequence, a container which supports iteration, or an iterator. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed. Note that filter(function, iterable) is equivalent to the generator expression (item for item in iterable if function(item)) if function is not None and (item for item in iterable if item) if function is None. See itertools.filterfalse() for the complementary function that returns elements of iterable for which function is false. class float(number=0.0, /)Â¶ class float(string, /) Return a floating-point number constructed from a number or a string. Examples: >>> float('+1.23') 1.23 >>> float(' -12345\\n') -12345.0 >>> float('1e-003') 0.001 >>> float('+1E6') 1000000.0 >>> float('-Infinity') -inf If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. The optional sign may be '+' or '-'; a '+' sign has no effect on the value produced. The argument may also be a string representing a NaN (not-a-number), or positive or negative infinity. More precisely, the input must conform to the floatvalue production rule in the following grammar, after leading and trailing whitespace characters are removed: sign ::= \"+\" | \"-\" infinity ::= \"Infinity\" | \"inf\" nan ::= \"nan\" digit ::= <a Unicode decimal digit, i.e. characters in Unicode general category Nd> digitpart ::= digit ([\"_\"] digit)* number ::= [digitpart] \".\" digitpart | digitpart [\".\"] exponent ::= (\"e\" | \"E\") [sign] digitpart floatnumber ::= number [exponent] absfloatvalue ::= floatnumber | infinity | nan floatvalue ::= [sign] absfloatvalue Case is not significant, so, for example, âinfâ, âInfâ, âINFINITYâ, and âiNfINityâ are all acceptable spellings for positive infinity. Otherwise, if the argument is an integer or a floating-point number, a floating-point number with the same value (within Pythonâs floating-point precision) is returned. If the argument is outside the range of a Python float, an OverflowError will be raised. For a general Python object x, float(x) delegates to x.__float__(). If __float__() is not defined then it falls back to __index__(). If no argument is given, 0.0 is returned. The float type is described in Numeric Types â int, float, complex. Changed in version 3.6: Grouping digits with underscores as in code literals is allowed. Changed in version 3.7: The parameter is now positional-only. Changed in version 3.8: Falls back to",
    "content_length": 3234
  },
  {
    "id": "functions_chunk_9",
    "source_file": "functions",
    "chunk_index": 9,
    "content": "If no argument is given, 0.0 is returned. The float type is described in Numeric Types â int, float, complex. Changed in version 3.6: Grouping digits with underscores as in code literals is allowed. Changed in version 3.7: The parameter is now positional-only. Changed in version 3.8: Falls back to __index__() if __float__() is not defined. format(value, format_spec='', /)Â¶ Convert a value to a âformattedâ representation, as controlled by format_spec. The interpretation of format_spec will depend on the type of the value argument; however, there is a standard formatting syntax that is used by most built-in types: Format Specification Mini-Language. The default format_spec is an empty string which usually gives the same effect as calling str(value). A call to format(value, format_spec) is translated to type(value).__format__(value, format_spec) which bypasses the instance dictionary when searching for the valueâs __format__() method. A TypeError exception is raised if the method search reaches object and the format_spec is non-empty, or if either the format_spec or the return value are not strings. Changed in version 3.4: object().__format__(format_spec) raises TypeError if format_spec is not an empty string. class frozenset(iterable=(), /) Return a new frozenset object, optionally with elements taken from iterable. frozenset is a built-in class. See frozenset and Set Types â set, frozenset for documentation about this class. For other containers see the built-in set, list, tuple, and dict classes, as well as the collections module. getattr(object, name, /)Â¶ getattr(object, name, default, /) Return the value of the named attribute of object. name must be a string. If the string is the name of one of the objectâs attributes, the result is the value of that attribute. For example, getattr(x, 'foobar') is equivalent to x.foobar. If the named attribute does not exist, default is returned if provided, otherwise AttributeError is raised. name need not be a Python identifier (see setattr()). Note Since private name mangling happens at compilation time, one must manually mangle a private attributeâs (attributes with two leading underscores) name in order to retrieve it with getattr(). globals()Â¶ Return the dictionary implementing the current module namespace. For code within functions, this is set when the function is defined and remains the same regardless of where the function is called. hasattr(object, name, /)Â¶ The arguments are an object and a string. The result is True if the string is the name of one of the objectâs attributes, False if not. (This is implemented by calling getattr(object, name) and seeing whether it raises an AttributeError or not.) hash(object, /)Â¶ Return the hash value of the object (if it has one). Hash values are integers. They are used to quickly compare dictionary keys during a dictionary lookup. Numeric values that compare equal have the same hash value (even if they are of different types, as is the case for 1 and 1.0). Note For objects with custom __hash__() methods, note that hash() truncates the return value based on the bit width of the host machine. help()Â¶ help(request) Invoke the built-in help system. (This function is intended for",
    "content_length": 3240
  },
  {
    "id": "functions_chunk_10",
    "source_file": "functions",
    "chunk_index": 10,
    "content": "(even if they are of different types, as is the case for 1 and 1.0). Note For objects with custom __hash__() methods, note that hash() truncates the return value based on the bit width of the host machine. help()Â¶ help(request) Invoke the built-in help system. (This function is intended for interactive use.) If no argument is given, the interactive help system starts on the interpreter console. If the argument is a string, then the string is looked up as the name of a module, function, class, method, keyword, or documentation topic, and a help page is printed on the console. If the argument is any other kind of object, a help page on the object is generated. Note that if a slash(/) appears in the parameter list of a function when invoking help(), it means that the parameters prior to the slash are positional-only. For more info, see the FAQ entry on positional-only parameters. This function is added to the built-in namespace by the site module. Changed in version 3.4: Changes to pydoc and inspect mean that the reported signatures for callables are now more comprehensive and consistent. hex(integer, /)Â¶ Convert an integer number to a lowercase hexadecimal string prefixed with â0xâ. If integer is not a Python int object, it has to define an __index__() method that returns an integer. Some examples: >>> hex(255) '0xff' >>> hex(-42) '-0x2a' If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways: >>> '%#x' % 255, '%x' % 255, '%X' % 255 ('0xff', 'ff', 'FF') >>> format(255, '#x'), format(255, 'x'), format(255, 'X') ('0xff', 'ff', 'FF') >>> f'{255:#x}', f'{255:x}', f'{255:X}' ('0xff', 'ff', 'FF') See also format() for more information. See also int() for converting a hexadecimal string to an integer using a base of 16. Note To obtain a hexadecimal string representation for a float, use the float.hex() method. id(object, /)Â¶ Return the âidentityâ of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value. CPython implementation detail: This is the address of the object in memory. Raises an auditing event builtins.id with argument id. input()Â¶ input(prompt, /) If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. Example: >>> s = input('--> ') --> Monty Python's Flying Circus >>> s \"Monty Python's Flying Circus\" If the readline module was loaded, then input() will use it to provide elaborate line editing and history features. Raises an auditing event builtins.input with argument prompt before reading input Raises an auditing event builtins.input/result with the result after successfully reading input. class int(number=0, /)Â¶ class int(string, /, base=10) Return an integer object constructed from a number or",
    "content_length": 3074
  },
  {
    "id": "functions_chunk_11",
    "source_file": "functions",
    "chunk_index": 11,
    "content": "will use it to provide elaborate line editing and history features. Raises an auditing event builtins.input with argument prompt before reading input Raises an auditing event builtins.input/result with the result after successfully reading input. class int(number=0, /)Â¶ class int(string, /, base=10) Return an integer object constructed from a number or a string, or return 0 if no arguments are given. Examples: >>> int(123.45) 123 >>> int('123') 123 >>> int(' -12_345\\n') -12345 >>> int('FACE', 16) 64206 >>> int('0xface', 0) 64206 >>> int('01110011', base=2) 115 If the argument defines __int__(), int(x) returns x.__int__(). If the argument defines __index__(), it returns x.__index__(). If the argument defines __trunc__(), it returns x.__trunc__(). For floating-point numbers, this truncates towards zero. If the argument is not a number or if base is given, then it must be a string, bytes, or bytearray instance representing an integer in radix base. Optionally, the string can be preceded by + or - (with no space in between), have leading zeros, be surrounded by whitespace, and have single underscores interspersed between digits. A base-n integer string contains digits, each representing a value from 0 to n-1. The values 0â9 can be represented by any Unicode decimal digit. The values 10â35 can be represented by a to z (or A to Z). The default base is 10. The allowed bases are 0 and 2â36. Base-2, -8, and -16 strings can be optionally prefixed with 0b/0B, 0o/0O, or 0x/0X, as with integer literals in code. For base 0, the string is interpreted in a similar way to an integer literal in code, in that the actual base is 2, 8, 10, or 16 as determined by the prefix. Base 0 also disallows leading zeros: int('010', 0) is not legal, while int('010') and int('010', 8) are. The integer type is described in Numeric Types â int, float, complex. Changed in version 3.4: If base is not an instance of int and the base object has a base.__index__ method, that method is called to obtain an integer for the base. Previous versions used base.__int__ instead of base.__index__. Changed in version 3.6: Grouping digits with underscores as in code literals is allowed. Changed in version 3.7: The first parameter is now positional-only. Changed in version 3.8: Falls back to __index__() if __int__() is not defined. Changed in version 3.11: The delegation to __trunc__() is deprecated. Changed in version 3.11: int string inputs and string representations can be limited to help avoid denial of service attacks. A ValueError is raised when the limit is exceeded while converting a string to an int or when converting an int into a string would exceed the limit. See the integer string conversion length limitation documentation. isinstance(object, classinfo, /)Â¶ Return True if the object argument is an instance of the classinfo argument, or of a (direct, indirect, or virtual) subclass thereof. If object is not an object of the given type, the function always returns False. If classinfo is a tuple of type objects (or recursively, other such tuples) or a",
    "content_length": 3072
  },
  {
    "id": "functions_chunk_12",
    "source_file": "functions",
    "chunk_index": 12,
    "content": "if the object argument is an instance of the classinfo argument, or of a (direct, indirect, or virtual) subclass thereof. If object is not an object of the given type, the function always returns False. If classinfo is a tuple of type objects (or recursively, other such tuples) or a Union Type of multiple types, return True if object is an instance of any of the types. If classinfo is not a type or tuple of types and such tuples, a TypeError exception is raised. TypeError may not be raised for an invalid type if an earlier check succeeds. Changed in version 3.10: classinfo can be a Union Type. issubclass(class, classinfo, /)Â¶ Return True if class is a subclass (direct, indirect, or virtual) of classinfo. A class is considered a subclass of itself. classinfo may be a tuple of class objects (or recursively, other such tuples) or a Union Type, in which case return True if class is a subclass of any entry in classinfo. In any other case, a TypeError exception is raised. Changed in version 3.10: classinfo can be a Union Type. iter(iterable, /)Â¶ iter(callable, sentinel, /) Return an iterator object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, the single argument must be a collection object which supports the iterable protocol (the __iter__() method), or it must support the sequence protocol (the __getitem__() method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel, is given, then the first argument must be a callable object. The iterator created in this case will call callable with no arguments for each call to its __next__() method; if the value returned is equal to sentinel, StopIteration will be raised, otherwise the value will be returned. See also Iterator Types. One useful application of the second form of iter() is to build a block-reader. For example, reading fixed-width blocks from a binary database file until the end of file is reached: from functools import partial with open('mydata.db', 'rb') as f: for block in iter(partial(f.read, 64), b''): process_block(block) len(object, /)Â¶ Return the length (the number of items) of an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or a collection (such as a dictionary, set, or frozen set). CPython implementation detail: len raises OverflowError on lengths larger than sys.maxsize, such as range(2 ** 100). class list(iterable=(), /) Rather than being a function, list is actually a mutable sequence type, as documented in Lists and Sequence Types â list, tuple, range. locals()Â¶ Return a mapping object representing the current local symbol table, with variable names as the keys, and their currently bound references as the values. At module scope, as well as when using exec() or eval() with a single namespace, this function returns the same namespace as globals(). At class scope, it returns the namespace that will be passed to",
    "content_length": 3041
  },
  {
    "id": "functions_chunk_13",
    "source_file": "functions",
    "chunk_index": 13,
    "content": "table, with variable names as the keys, and their currently bound references as the values. At module scope, as well as when using exec() or eval() with a single namespace, this function returns the same namespace as globals(). At class scope, it returns the namespace that will be passed to the metaclass constructor. When using exec() or eval() with separate local and global arguments, it returns the local namespace passed in to the function call. In all of the above cases, each call to locals() in a given frame of execution will return the same mapping object. Changes made through the mapping object returned from locals() will be visible as assigned, reassigned, or deleted local variables, and assigning, reassigning, or deleting local variables will immediately affect the contents of the returned mapping object. In an optimized scope (including functions, generators, and coroutines), each call to locals() instead returns a fresh dictionary containing the current bindings of the functionâs local variables and any nonlocal cell references. In this case, name binding changes made via the returned dict are not written back to the corresponding local variables or nonlocal cell references, and assigning, reassigning, or deleting local variables and nonlocal cell references does not affect the contents of previously returned dictionaries. Calling locals() as part of a comprehension in a function, generator, or coroutine is equivalent to calling it in the containing scope, except that the comprehensionâs initialised iteration variables will be included. In other scopes, it behaves as if the comprehension were running as a nested function. Calling locals() as part of a generator expression is equivalent to calling it in a nested generator function. Changed in version 3.12: The behaviour of locals() in a comprehension has been updated as described in PEP 709. Changed in version 3.13: As part of PEP 667, the semantics of mutating the mapping objects returned from this function are now defined. The behavior in optimized scopes is now as described above. Aside from being defined, the behaviour in other scopes remains unchanged from previous versions. map(function, iterable, *iterables)Â¶ Return an iterator that applies function to every item of iterable, yielding the results. If additional iterables arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see itertools.starmap(). max(iterable, /, *, key=None)Â¶ max(iterable, /, *, default, key=None) max(arg1, arg2, /, *args, key=None) Return the largest item in an iterable or the largest of two or more arguments. If one positional argument is provided, it should be an iterable. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided",
    "content_length": 3250
  },
  {
    "id": "functions_chunk_14",
    "source_file": "functions",
    "chunk_index": 14,
    "content": "the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc). Changed in version 3.4: Added the default keyword-only parameter. Changed in version 3.8: The key can be None. class memoryview(object) Return a âmemory viewâ object created from the given argument. See Memory Views for more information. min(iterable, /, *, key=None)Â¶ min(iterable, /, *, default, key=None) min(arg1, arg2, /, *args, key=None) Return the smallest item in an iterable or the smallest of two or more arguments. If one positional argument is provided, it should be an iterable. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned. There are two optional keyword-only arguments. The key argument specifies a one-argument ordering function like that used for list.sort(). The default argument specifies an object to return if the provided iterable is empty. If the iterable is empty and default is not provided, a ValueError is raised. If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc). Changed in version 3.4: Added the default keyword-only parameter. Changed in version 3.8: The key can be None. next(iterator, /)Â¶ next(iterator, default, /) Retrieve the next item from the iterator by calling its __next__() method. If default is given, it is returned if the iterator is exhausted, otherwise StopIteration is raised. class objectÂ¶ This is the ultimate base class of all other classes. It has methods that are common to all instances of Python classes. When the constructor is called, it returns a new featureless object. The constructor does not accept any arguments. Note object instances do not have __dict__ attributes, so you canât assign arbitrary attributes to an instance of object. oct(integer, /)Â¶ Convert an integer number to an octal string prefixed with â0oâ. The result is a valid Python expression. If integer is not a Python int object, it has to define an __index__() method that returns an integer. For example: >>> oct(8) '0o10' >>> oct(-56) '-0o70' If you want to convert an integer number to an octal string either with the prefix â0oâ or not, you can use either of the following ways. >>> '%#o' % 10, '%o' % 10 ('0o12', '12') >>> format(10, '#o'), format(10, 'o') ('0o12', '12') >>> f'{10:#o}', f'{10:o}' ('0o12', '12') See also format() for more information. open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)Â¶ Open file and return a corresponding file object.",
    "content_length": 3319
  },
  {
    "id": "functions_chunk_15",
    "source_file": "functions",
    "chunk_index": 15,
    "content": "can use either of the following ways. >>> '%#o' % 10, '%o' % 10 ('0o12', '12') >>> format(10, '#o'), format(10, 'o') ('0o12', '12') >>> f'{10:#o}', f'{10:o}' ('0o12', '12') See also format() for more information. open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)Â¶ Open file and return a corresponding file object. If the file cannot be opened, an OSError is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to False.) mode is an optional string that specifies the mode in which the file is opened. It defaults to 'r' which means open for reading in text mode. Other common values are 'w' for writing (truncating the file if it already exists), 'x' for exclusive creation, and 'a' for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: locale.getencoding() is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: Character Meaning 'r' open for reading (default) 'w' open for writing, truncating the file first 'x' open for exclusive creation, failing if the file already exists 'a' open for writing, appending to the end of file if it exists 'b' binary mode 't' text mode (default) '+' open for updating (reading and writing) The default mode is 'r' (open for reading text, a synonym of 'rt'). Modes 'w+' and 'w+b' open and truncate the file. Modes 'r+' and 'r+b' open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including 'b' in the mode argument) return contents as bytes objects without any decoding. In text mode (the default, or when 't' is included in the mode argument), the contents of the file are returned as str, the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Note Python doesnât depend on the underlying operating systemâs notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but TextIOWrapper (i.e., files opened with mode='r+') would have another buffering. To disable buffering in TextIOWrapper, consider",
    "content_length": 3036
  },
  {
    "id": "functions_chunk_16",
    "source_file": "functions",
    "chunk_index": 16,
    "content": "writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but TextIOWrapper (i.e., files opened with mode='r+') would have another buffering. To disable buffering in TextIOWrapper, consider using the write_through flag for io.TextIOWrapper.reconfigure(). When no buffering argument is given, the default buffering policy works as follows: Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying deviceâs âblock sizeâ and falling back on io.DEFAULT_BUFFER_SIZE. On many systems, the buffer will typically be 4096 or 8192 bytes long. âInteractiveâ text files (files for which isatty() returns True) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever locale.getencoding() returns), but any text encoding supported by Python can be used. See the codecs module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handledâthis cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with codecs.register_error() is also valid. The standard names include: 'strict' to raise a ValueError exception if there is an encoding error. The default value of None has the same effect. 'ignore' ignores errors. Note that ignoring encoding errors can lead to data loss. 'replace' causes a replacement marker (such as '?') to be inserted where there is malformed data. 'surrogateescape' will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the surrogateescape error handler is used when writing data. This is useful for processing files in an unknown encoding. 'xmlcharrefreplace' is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference &#nnn;. 'backslashreplace' replaces malformed data by Pythonâs backslashed escape sequences. 'namereplace' (also only supported when writing) replaces unsupported characters with \\N{...} escape sequences. newline determines how to parse newline characters from the stream. It can be None, '', '\\n', '\\r', and '\\r\\n'. It works as follows: When reading input from the stream, if newline is None, universal newlines mode is enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and these are translated into '\\n' before being returned to the caller. If it is '', universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated. When writing output to the stream, if newline is None,",
    "content_length": 3187
  },
  {
    "id": "functions_chunk_17",
    "source_file": "functions",
    "chunk_index": 17,
    "content": "mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated. When writing output to the stream, if newline is None, any '\\n' characters written are translated to the system default line separator, os.linesep. If newline is '' or '\\n', no translation takes place. If newline is any of the other legal values, any '\\n' characters written are translated to the given string. If closefd is False and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be True (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing os.open as opener results in functionality similar to passing None). The newly created file is non-inheritable. The following example uses the dir_fd parameter of the os.open() function to open a file relative to a given directory: >>> import os >>> dir_fd = os.open('somedir', os.O_RDONLY) >>> def opener(path, flags): ... return os.open(path, flags, dir_fd=dir_fd) ... >>> with open('spamspam.txt', 'w', opener=opener) as f: ... print('This will be written to somedir/spamspam.txt', file=f) ... >>> os.close(dir_fd) # don't leak a file descriptor The type of file object returned by the open() function depends on the mode. When open() is used to open a file in a text mode ('w', 'r', 'wt', 'rt', etc.), it returns a subclass of io.TextIOBase (specifically io.TextIOWrapper). When used to open a file in a binary mode with buffering, the returned class is a subclass of io.BufferedIOBase. The exact class varies: in read binary mode, it returns an io.BufferedReader; in write binary and append binary modes, it returns an io.BufferedWriter, and in read/write mode, it returns an io.BufferedRandom. When buffering is disabled, the raw stream, a subclass of io.RawIOBase, io.FileIO, is returned. See also the file handling modules, such as fileinput, io (where open() is declared), os, os.path, tempfile, and shutil. Raises an auditing event open with arguments path, mode, flags. The mode and flags arguments may have been modified or inferred from the original call. Changed in version 3.3: The opener parameter was added. The 'x' mode was added. IOError used to be raised, it is now an alias of OSError. FileExistsError is now raised if the file opened in exclusive creation mode ('x') already exists. Changed in version 3.4: The file is now non-inheritable. Changed in version 3.5: If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an InterruptedError exception (see PEP 475 for the rationale). The 'namereplace' error handler was added. Changed in version 3.6: Support added to",
    "content_length": 3082
  },
  {
    "id": "functions_chunk_18",
    "source_file": "functions",
    "chunk_index": 18,
    "content": "in version 3.5: If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an InterruptedError exception (see PEP 475 for the rationale). The 'namereplace' error handler was added. Changed in version 3.6: Support added to accept objects implementing os.PathLike. On Windows, opening a console buffer may return a subclass of io.RawIOBase other than io.FileIO. Changed in version 3.11: The 'U' mode has been removed. ord(character, /)Â¶ Return the ordinal value of a character. If the argument is a one-character string, return the Unicode code point of that character. For example, ord('a') returns the integer 97 and ord('â¬') (Euro sign) returns 8364. This is the inverse of chr(). If the argument is a bytes or bytearray object of length 1, return its single byte value. For example, ord(b'a') returns the integer 97. pow(base, exp, mod=None)Â¶ Return base to the power exp; if mod is present, return base to the power exp, modulo mod (computed more efficiently than pow(base, exp) % mod). The two-argument form pow(base, exp) is equivalent to using the power operator: base**exp. When arguments are builtin numeric types with mixed operand types, the coercion rules for binary arithmetic operators apply. For int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, pow(10, 2) returns 100, but pow(10, -2) returns 0.01. For a negative base of type int or float and a non-integral exponent, a complex result is delivered. For example, pow(-9, 0.5) returns a value close to 3j. Whereas, for a negative base of type int or float with an integral exponent, a float result is delivered. For example, pow(-9, 2.0) returns 81.0. For int operands base and exp, if mod is present, mod must also be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod. In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod. Hereâs an example of computing an inverse for 38 modulo 97: >>> pow(38, -1, mod=97) 23 >>> 23 * 38 % 97 == 1 True Changed in version 3.8: For int operands, the three-argument form of pow now allows the second argument to be negative, permitting computation of modular inverses. Changed in version 3.8: Allow keyword arguments. Formerly, only positional arguments were supported. print(*objects, sep=' ', end='\\n', file=None, flush=False)Â¶ Print objects to the text stream file, separated by sep and followed by end. sep, end, file, and flush, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are",
    "content_length": 2995
  },
  {
    "id": "functions_chunk_19",
    "source_file": "functions",
    "chunk_index": 19,
    "content": "be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Output buffering is usually determined by file. However, if flush is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. class property(fget=None, fset=None, fdel=None, doc=None)Â¶ Return a property attribute. fget is a function for getting an attribute value. fset is a function for setting an attribute value. fdel is a function for deleting an attribute value. And doc creates a docstring for the attribute. A typical use is to define a managed attribute x: class C: def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, \"I'm the 'x' property.\") If c is an instance of C, c.x will invoke the getter, c.x = value will invoke the setter, and del c.x the deleter. If given, doc will be the docstring of the property attribute. Otherwise, the property will copy fgetâs docstring (if it exists). This makes it possible to create read-only properties easily using property() as a decorator: class Parrot: def __init__(self): self._voltage = 100000 @property def voltage(self): \"\"\"Get the current voltage.\"\"\" return self._voltage The @property decorator turns the voltage() method into a âgetterâ for a read-only attribute with the same name, and it sets the docstring for voltage to âGet the current voltage.â @getterÂ¶ @setterÂ¶ @deleterÂ¶ A property object has getter, setter, and deleter methods usable as decorators that create a copy of the property with the corresponding accessor function set to the decorated function. This is best explained with an example: class C: def __init__(self): self._x = None @property def x(self): \"\"\"I'm the 'x' property.\"\"\" return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x This code is exactly equivalent to the first example. Be sure to give the additional functions the same name as the original property (x in this case.) The returned property object also has the attributes fget, fset, and fdel corresponding to the constructor arguments. Changed in version 3.5: The docstrings of property objects are now writeable. __name__Â¶ Attribute holding the name of the property. The name of the property can be changed at runtime. Added in version 3.13. class range(stop, /) class range(start, stop, step=1, /) Rather than being a function, range is actually an immutable sequence type, as documented in Ranges and Sequence Types â list, tuple, range. repr(object, /)Â¶ Return a string containing a printable representation",
    "content_length": 3151
  },
  {
    "id": "functions_chunk_20",
    "source_file": "functions",
    "chunk_index": 20,
    "content": "property can be changed at runtime. Added in version 3.13. class range(stop, /) class range(start, stop, step=1, /) Rather than being a function, range is actually an immutable sequence type, as documented in Ranges and Sequence Types â list, tuple, range. repr(object, /)Â¶ Return a string containing a printable representation of an object. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(); otherwise, the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a __repr__() method. If sys.displayhook() is not accessible, this function will raise RuntimeError. This class has a custom representation that can be evaluated: class Person: def __init__(self, name, age): self.name = name self.age = age def __repr__(self): return f\"Person('{self.name}', {self.age})\" reversed(object, /)Â¶ Return a reverse iterator. The argument must be an object which has a __reversed__() method or supports the sequence protocol (the __len__() method and the __getitem__() method with integer arguments starting at 0). round(number, ndigits=None)Â¶ Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None, it returns the nearest integer to its input. For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2). Any integer value is valid for ndigits (positive, zero, or negative). The return value is an integer if ndigits is omitted or None. Otherwise, the return value has the same type as number. For a general Python object number, round delegates to number.__round__. Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: itâs a result of the fact that most decimal fractions canât be represented exactly as a float. See Floating-Point Arithmetic: Issues and Limitations for more information. class set(iterable=(), /) Return a new set object, optionally with elements taken from iterable. set is a built-in class. See set and Set Types â set, frozenset for documentation about this class. For other containers see the built-in frozenset, list, tuple, and dict classes, as well as the collections module. setattr(object, name, value, /)Â¶ This is the counterpart of getattr(). The arguments are an object, a string, and an arbitrary value. The string may name an existing attribute or a new attribute. The function assigns the value to the attribute, provided the object allows it. For example, setattr(x, 'foobar', 123) is equivalent to x.foobar = 123. name need not be a Python identifier as defined in Identifiers and keywords unless the object chooses to enforce that, for example in a custom __getattribute__() or",
    "content_length": 3170
  },
  {
    "id": "functions_chunk_21",
    "source_file": "functions",
    "chunk_index": 21,
    "content": "function assigns the value to the attribute, provided the object allows it. For example, setattr(x, 'foobar', 123) is equivalent to x.foobar = 123. name need not be a Python identifier as defined in Identifiers and keywords unless the object chooses to enforce that, for example in a custom __getattribute__() or via __slots__. An attribute whose name is not an identifier will not be accessible using the dot notation, but is accessible through getattr() etc.. Note Since private name mangling happens at compilation time, one must manually mangle a private attributeâs (attributes with two leading underscores) name in order to set it with setattr(). class slice(stop, /)Â¶ class slice(start, stop, step=None, /) Return a slice object representing the set of indices specified by range(start, stop, step). The start and step arguments default to None. Slice objects have read-only data attributes start, stop, and step which merely return the argument values (or their default). They have no other explicit functionality; however, they are used by NumPy and other third-party packages. startÂ¶ stopÂ¶ stepÂ¶ Slice objects are also generated when extended indexing syntax is used. For example: a[start:stop:step] or a[start:stop, i]. See itertools.islice() for an alternate version that returns an iterator. Changed in version 3.12: Slice objects are now hashable (provided start, stop, and step are hashable). sorted(iterable, /, *, key=None, reverse=False)Â¶ Return a new sorted list from the items in iterable. Has two optional arguments which must be specified as keyword arguments. key specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). The default value is None (compare the elements directly). reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. Use functools.cmp_to_key() to convert an old-style cmp function to a key function. The built-in sorted() function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal â this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). The sort algorithm uses only < comparisons between items. While defining an __lt__() method will suffice for sorting, PEP 8 recommends that all six rich comparisons be implemented. This will help avoid bugs when using the same data with other ordering tools such as max() that rely on a different underlying method. Implementing all six comparisons also helps avoid confusion for mixed type comparisons which can call reflected the __gt__() method. For sorting examples and a brief sorting tutorial, see Sorting Techniques. @staticmethodÂ¶ Transform a method into a static method. A static method does not receive an implicit first argument. To declare a static method, use this idiom: class C: @staticmethod def f(arg1, arg2, argN): ... The @staticmethod form is a function decorator â see Function definitions for details. A static method can be called either on the class (such as C.f()) or on an instance (such as C().f()). Moreover,",
    "content_length": 3193
  },
  {
    "id": "functions_chunk_22",
    "source_file": "functions",
    "chunk_index": 22,
    "content": "To declare a static method, use this idiom: class C: @staticmethod def f(arg1, arg2, argN): ... The @staticmethod form is a function decorator â see Function definitions for details. A static method can be called either on the class (such as C.f()) or on an instance (such as C().f()). Moreover, the static method descriptor is also callable, so it can be used in the class definition (such as f()). Static methods in Python are similar to those found in Java or C++. Also, see classmethod() for a variant that is useful for creating alternate class constructors. Like all decorators, it is also possible to call staticmethod as a regular function and do something with its result. This is needed in some cases where you need a reference to a function from a class body and you want to avoid the automatic transformation to instance method. For these cases, use this idiom: def regular_function(): ... class C: method = staticmethod(regular_function) For more information on static methods, see The standard type hierarchy. Changed in version 3.10: Static methods now inherit the method attributes (__module__, __name__, __qualname__, __doc__ and __annotations__), have a new __wrapped__ attribute, and are now callable as regular functions. class str(*, encoding='utf-8', errors='strict') class str(object) class str(object, encoding, errors='strict') class str(object, *, errors) Return a str version of object. See str() for details. str is the built-in string class. For general information about strings, see Text Sequence Type â str. sum(iterable, /, start=0)Â¶ Sums start and the items of an iterable from left to right and returns the total. The iterableâs items are normally numbers, and the start value is not allowed to be a string. For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence). To add floating-point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain(). Changed in version 3.8: The start parameter can be specified as a keyword argument. Changed in version 3.12: Summation of floats switched to an algorithm that gives higher accuracy and better commutativity on most builds. class superÂ¶ class super(type, object_or_type=None, /) Return a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if __mro__ of object_or_type is D -> B -> C -> A -> object and the value of type is B, then super() searches C -> A -> object. The __mro__ attribute of the class corresponding to object_or_type lists the method resolution search order used by both getattr() and super(). The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, isinstance(obj, type) must be true. If the",
    "content_length": 3148
  },
  {
    "id": "functions_chunk_23",
    "source_file": "functions",
    "chunk_index": 23,
    "content": "the method resolution search order used by both getattr() and super(). The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, isinstance(obj, type) must be true. If the second argument is a type, issubclass(type2, type) must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (âzero-argument super()â). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically self). (This means that zero-argument super() will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement âdiamond diagramsâ where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: class C(B): def method(self, arg): super().method(arg) # This does the same thing as: # super(C, self).method(arg) In addition to method lookups, super() also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that super() is implemented as part of the binding process for explicit dotted attribute lookups such as super().__getitem__(name). It does so by implementing its own __getattribute__() method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, super() is undefined for implicit lookups using statements or operators such as super()[name]. Also note that, aside from the zero argument form, super() is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using super(), see guide to using super(). class tuple(iterable=(), /) Rather than being a function, tuple is actually an immutable sequence type, as documented in Tuples and Sequence Types â list, tuple, range. class type(object, /)Â¶ class type(name, bases, dict, /, **kwargs) With one argument, return the",
    "content_length": 3279
  },
  {
    "id": "functions_chunk_24",
    "source_file": "functions",
    "chunk_index": 24,
    "content": "design cooperative classes using super(), see guide to using super(). class tuple(iterable=(), /) Rather than being a function, tuple is actually an immutable sequence type, as documented in Tuples and Sequence Types â list, tuple, range. class type(object, /)Â¶ class type(name, bases, dict, /, **kwargs) With one argument, return the type of an object. The return value is a type object and generally the same object as returned by object.__class__. The isinstance() built-in function is recommended for testing the type of an object, because it takes subclasses into account. With three arguments, return a new type object. This is essentially a dynamic form of the class statement. The name string is the class name and becomes the __name__ attribute. The bases tuple contains the base classes and becomes the __bases__ attribute; if empty, object, the ultimate base of all classes, is added. The dict dictionary contains attribute and method definitions for the class body; it may be copied or wrapped before becoming the __dict__ attribute. The following two statements create identical type objects: >>> class X: ... a = 1 ... >>> X = type('X', (), dict(a=1)) See also: Documentation on attributes and methods on classes. Type Objects Keyword arguments provided to the three argument form are passed to the appropriate metaclass machinery (usually __init_subclass__()) in the same way that keywords in a class definition (besides metaclass) would. See also Customizing class creation. Changed in version 3.6: Subclasses of type which donât override type.__new__ may no longer use the one-argument form to get the type of an object. vars()Â¶ vars(object, /) Return the __dict__ attribute for a module, class, instance, or any other object with a __dict__ attribute. Objects such as modules and instances have an updateable __dict__ attribute; however, other objects may have write restrictions on their __dict__ attributes (for example, classes use a types.MappingProxyType to prevent direct dictionary updates). Without an argument, vars() acts like locals(). A TypeError exception is raised if an object is specified but it doesnât have a __dict__ attribute (for example, if its class defines the __slots__ attribute). Changed in version 3.13: The result of calling this function without an argument has been updated as described for the locals() builtin. zip(*iterables, strict=False)Â¶ Iterate over several iterables in parallel, producing tuples with an item from each one. Example: >>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']): ... print(item) ... (1, 'sugar') (2, 'spice') (3, 'everything nice') More formally: zip() returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument iterables. Another way to think of zip() is that it turns rows into columns, and columns into rows. This is similar to transposing a matrix. zip() is lazy: The elements wonât be processed until the iterable is iterated on, e.g. by a for loop or by wrapping in a list. One thing to consider is that the iterables passed to zip() could have different lengths; sometimes by design, and sometimes because of a bug in",
    "content_length": 3179
  },
  {
    "id": "functions_chunk_25",
    "source_file": "functions",
    "chunk_index": 25,
    "content": "zip() is lazy: The elements wonât be processed until the iterable is iterated on, e.g. by a for loop or by wrapping in a list. One thing to consider is that the iterables passed to zip() could have different lengths; sometimes by design, and sometimes because of a bug in the code that prepared these iterables. Python offers three different approaches to dealing with this issue: By default, zip() stops when the shortest iterable is exhausted. It will ignore the remaining items in the longer iterables, cutting off the result to the length of the shortest iterable: >>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum'])) [(0, 'fee'), (1, 'fi'), (2, 'fo')] zip() is often used in cases where the iterables are assumed to be of equal length. In such cases, itâs recommended to use the strict=True option. Its output is the same as regular zip(): >>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True)) [('a', 1), ('b', 2), ('c', 3)] Unlike the default behavior, it raises a ValueError if one iterable is exhausted before the others: >>> for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True): ... print(item) ... (0, 'fee') (1, 'fi') (2, 'fo') Traceback (most recent call last): ... ValueError: zip() argument 2 is longer than argument 1 Without the strict=True argument, any bug that results in iterables of different lengths will be silenced, possibly manifesting as a hard-to-find bug in another part of the program. Shorter iterables can be padded with a constant value to make all the iterables have the same length. This is done by itertools.zip_longest(). Edge cases: With a single iterable argument, zip() returns an iterator of 1-tuples. With no arguments, it returns an empty iterator. Tips and tricks: The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(*[iter(s)]*n, strict=True). This repeats the same iterator n times so that each output tuple has the result of n calls to the iterator. This has the effect of dividing the input into n-length chunks. zip() in conjunction with the * operator can be used to unzip a list: >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> list(zip(x, y)) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True Changed in version 3.10: Added the strict argument. __import__(name, globals=None, locals=None, fromlist=(), level=0)Â¶ Note This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module(). This function is invoked by the import statement. It can be replaced (by importing the builtins module and assigning to builtins.__import__) in order to change semantics of the import statement, but doing so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function",
    "content_length": 3051
  },
  {
    "id": "functions_chunk_26",
    "source_file": "functions",
    "chunk_index": 26,
    "content": "so is strongly discouraged as it is usually simpler to use import hooks (see PEP 302) to attain the same goals and does not cause issues with code which assumes the default import implementation is in use. Direct use of __import__() is also discouraged in favor of importlib.import_module(). The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all and uses its globals only to determine the package context of the import statement. level specifies whether to use absolute or relative imports. 0 (the default) means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling __import__() (see PEP 328 for the details). When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned. For example, the statement import spam results in bytecode resembling the following code: spam = __import__('spam', globals(), locals(), [], 0) The statement import spam.ham results in this call: spam = __import__('spam.ham', globals(), locals(), [], 0) Note how __import__() returns the toplevel module here because this is the object that is bound to a name by the import statement. On the other hand, the statement from spam.ham import eggs, sausage as saus results in _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0) eggs = _temp.eggs saus = _temp.sausage Here, the spam.ham module is returned from __import__(). From this object, the names to import are retrieved and assigned to their respective names. If you simply want to import a module (potentially within a package) by name, use importlib.import_module(). Changed in version 3.3: Negative values for level are no longer supported (which also changes the default value to 0). Changed in version 3.9: When the command line options -E or -I are being used, the environment variable PYTHONCASEOK is now ignored. Footnotes [1] Note that the parser only accepts the Unix-style end of line convention. If you are reading the code from a file, make sure to use newline conversion mode to convert Windows or Mac-style newlines.",
    "content_length": 2544
  },
  {
    "id": "modules_chunk_0",
    "source_file": "modules",
    "chunk_index": 0,
    "content": "6. ModulesÂ¶ If you quit from the Python interpreter and enter it again, the definitions you have made (functions and variables) are lost. Therefore, if you want to write a somewhat longer program, you are better off using a text editor to prepare the input for the interpreter and running it with that file as input instead. This is known as creating a script. As your program gets longer, you may want to split it into several files for easier maintenance. You may also want to use a handy function that youâve written in several programs without copying its definition into each program. To support this, Python has a way to put definitions in a file and use them in a script or in an interactive instance of the interpreter. Such a file is called a module; definitions from a module can be imported into other modules or into the main module (the collection of variables that you have access to in a script executed at the top level and in calculator mode). A module is a file containing Python definitions and statements. The file name is the module name with the suffix .py appended. Within a module, the moduleâs name (as a string) is available as the value of the global variable __name__. For instance, use your favorite text editor to create a file called fibo.py in the current directory with the following contents: # Fibonacci numbers module def fib(n): \"\"\"Write Fibonacci series up to n.\"\"\" a, b = 0, 1 while a < n: print(a, end=' ') a, b = b, a+b print() def fib2(n): \"\"\"Return Fibonacci series up to n.\"\"\" result = [] a, b = 0, 1 while a < n: result.append(a) a, b = b, a+b return result Now enter the Python interpreter and import this module with the following command: >>> import fibo This does not add the names of the functions defined in fibo directly to the current namespace (see Python Scopes and Namespaces for more details); it only adds the module name fibo there. Using the module name you can access the functions: >>> fibo.fib(1000) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 >>> fibo.fib2(100) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] >>> fibo.__name__ 'fibo' If you intend to use a function often you can assign it to a local name: >>> fib = fibo.fib >>> fib(500) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 6.1. More on ModulesÂ¶ A module can contain executable statements as well as function definitions. These statements are intended to initialize the module. They are executed only the first time the module name is encountered in an import statement. [1] (They are also run if the file is executed as a script.) Each module has its own private namespace, which is used as the global namespace by all functions defined in the module. Thus, the author",
    "content_length": 2695
  },
  {
    "id": "modules_chunk_1",
    "source_file": "modules",
    "chunk_index": 1,
    "content": "only the first time the module name is encountered in an import statement. [1] (They are also run if the file is executed as a script.) Each module has its own private namespace, which is used as the global namespace by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a userâs global variables. On the other hand, if you know what you are doing you can touch a moduleâs global variables with the same notation used to refer to its functions, modname.itemname. Modules can import other modules. It is customary but not required to place all import statements at the beginning of a module (or script, for that matter). The imported module names, if placed at the top level of a module (outside any functions or classes), are added to the moduleâs global namespace. There is a variant of the import statement that imports names from a module directly into the importing moduleâs namespace. For example: >>> from fibo import fib, fib2 >>> fib(500) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 This does not introduce the module name from which the imports are taken in the local namespace (so in the example, fibo is not defined). There is even a variant to import all names that a module defines: >>> from fibo import * >>> fib(500) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 This imports all names except those beginning with an underscore (_). In most cases Python programmers do not use this facility since it introduces an unknown set of names into the interpreter, possibly hiding some things you have already defined. Note that in general the practice of importing * from a module or package is frowned upon, since it often causes poorly readable code. However, it is okay to use it to save typing in interactive sessions. If the module name is followed by as, then the name following as is bound directly to the imported module. >>> import fibo as fib >>> fib.fib(500) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 This is effectively importing the module in the same way that import fibo will do, with the only difference of it being available as fib. It can also be used when utilising from with similar effects: >>> from fibo import fib as fibonacci >>> fibonacci(500) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 Note For efficiency reasons, each module is only imported once per interpreter session. Therefore, if you change your modules, you must restart the interpreter â or, if itâs just one module you want to test interactively, use importlib.reload(), e.g. import importlib; importlib.reload(modulename). 6.1.1. Executing modules as scriptsÂ¶ When you run a Python module with python fibo.py <arguments> the code in the module will be executed,",
    "content_length": 2760
  },
  {
    "id": "modules_chunk_2",
    "source_file": "modules",
    "chunk_index": 2,
    "content": "you change your modules, you must restart the interpreter â or, if itâs just one module you want to test interactively, use importlib.reload(), e.g. import importlib; importlib.reload(modulename). 6.1.1. Executing modules as scriptsÂ¶ When you run a Python module with python fibo.py <arguments> the code in the module will be executed, just as if you imported it, but with the __name__ set to \"__main__\". That means that by adding this code at the end of your module: if __name__ == \"__main__\": import sys fib(int(sys.argv[1])) you can make the file usable as a script as well as an importable module, because the code that parses the command line only runs if the module is executed as the âmainâ file: $ python fibo.py 50 0 1 1 2 3 5 8 13 21 34 If the module is imported, the code is not run: >>> import fibo >>> This is often used either to provide a convenient user interface to a module, or for testing purposes (running the module as a script executes a test suite). 6.1.2. The Module Search PathÂ¶ When a module named spam is imported, the interpreter first searches for a built-in module with that name. These module names are listed in sys.builtin_module_names. If not found, it then searches for a file named spam.py in a list of directories given by the variable sys.path. sys.path is initialized from these locations: The directory containing the input script (or the current directory when no file is specified). PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH). The installation-dependent default (by convention including a site-packages directory, handled by the site module). More details are at The initialization of the sys.path module search path. Note On file systems which support symlinks, the directory containing the input script is calculated after the symlink is followed. In other words the directory containing the symlink is not added to the module search path. After initialization, Python programs can modify sys.path. The directory containing the script being run is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in that directory will be loaded instead of modules of the same name in the library directory. This is an error unless the replacement is intended. See section Standard Modules for more information. 6.1.3. âCompiledâ Python filesÂ¶ To speed up loading modules, Python caches the compiled version of each module in the __pycache__ directory under the name module.version.pyc, where the version encodes the format of the compiled file; it generally contains the Python version number. For example, in CPython release 3.3 the compiled version of spam.py would be cached as __pycache__/spam.cpython-33.pyc. This naming convention allows compiled modules from different releases and different versions of Python to coexist. Python checks the modification date of the source against the compiled version to see if itâs out of date and needs to be recompiled. This is a completely automatic process. Also, the compiled modules are platform-independent, so the",
    "content_length": 3109
  },
  {
    "id": "modules_chunk_3",
    "source_file": "modules",
    "chunk_index": 3,
    "content": "compiled modules from different releases and different versions of Python to coexist. Python checks the modification date of the source against the compiled version to see if itâs out of date and needs to be recompiled. This is a completely automatic process. Also, the compiled modules are platform-independent, so the same library can be shared among systems with different architectures. Python does not check the cache in two circumstances. First, it always recompiles and does not store the result for the module thatâs loaded directly from the command line. Second, it does not check the cache if there is no source module. To support a non-source (compiled only) distribution, the compiled module must be in the source directory, and there must not be a source module. Some tips for experts: You can use the -O or -OO switches on the Python command to reduce the size of a compiled module. The -O switch removes assert statements, the -OO switch removes both assert statements and __doc__ strings. Since some programs may rely on having these available, you should only use this option if you know what youâre doing. âOptimizedâ modules have an opt- tag and are usually smaller. Future releases may change the effects of optimization. A program doesnât run any faster when it is read from a .pyc file than when it is read from a .py file; the only thing thatâs faster about .pyc files is the speed with which they are loaded. The module compileall can create .pyc files for all modules in a directory. There is more detail on this process, including a flow chart of the decisions, in PEP 3147. 6.2. Standard ModulesÂ¶ Python comes with a library of standard modules, described in a separate document, the Python Library Reference (âLibrary Referenceâ hereafter). Some modules are built into the interpreter; these provide access to operations that are not part of the core of the language but are nevertheless built in, either for efficiency or to provide access to operating system primitives such as system calls. The set of such modules is a configuration option which also depends on the underlying platform. For example, the winreg module is only provided on Windows systems. One particular module deserves some attention: sys, which is built into every Python interpreter. The variables sys.ps1 and sys.ps2 define the strings used as primary and secondary prompts: >>> import sys >>> sys.ps1 '>>> ' >>> sys.ps2 '... ' >>> sys.ps1 = 'C> ' C> print('Yuck!') Yuck! C> These two variables are only defined if the interpreter is in interactive mode. The variable sys.path is a list of strings that determines the interpreterâs search path for modules. It is initialized to a default path taken from the environment variable PYTHONPATH, or from a built-in default if PYTHONPATH is not set. You can modify it using standard list operations: >>> import sys >>> sys.path.append('/ufs/guido/lib/python') 6.3. The dir() FunctionÂ¶ The built-in function dir() is used to find out which names a module defines. It returns a",
    "content_length": 3043
  },
  {
    "id": "modules_chunk_4",
    "source_file": "modules",
    "chunk_index": 4,
    "content": "taken from the environment variable PYTHONPATH, or from a built-in default if PYTHONPATH is not set. You can modify it using standard list operations: >>> import sys >>> sys.path.append('/ufs/guido/lib/python') 6.3. The dir() FunctionÂ¶ The built-in function dir() is used to find out which names a module defines. It returns a sorted list of strings: >>> import fibo, sys >>> dir(fibo) ['__name__', 'fib', 'fib2'] >>> dir(sys) ['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__', '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__', '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__', '_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework', '_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook', 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix', 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth', 'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags', 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix', 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info', 'warnoptions'] Without arguments, dir() lists the names you have defined currently: >>> a = [1, 2, 3, 4, 5] >>> import fibo >>> fib = fibo.fib >>> dir() ['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys'] Note that it lists all types of names: variables, modules, functions, etc. dir() does not list the names of built-in functions and variables. If you want a list of those, they are defined in the standard module builtins: >>> import builtins >>> dir(builtins) ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] 6.4. PackagesÂ¶ Packages are a way of structuring Pythonâs module namespace by using âdotted module namesâ. For example, the module name A.B designates a submodule named B in a package named A. Just like the use of modules saves the authors of different modules from having to worry about each otherâs global variable names, the use of dotted module names saves the authors of multi-module packages like NumPy or Pillow from having to worry about each otherâs module names. Suppose you want to design a collection of modules (a âpackageâ) for the uniform handling of sound files and sound data. There are many different sound file formats (usually recognized by their extension, for example: .wav, .aiff, .au), so you",
    "content_length": 5023
  },
  {
    "id": "modules_chunk_5",
    "source_file": "modules",
    "chunk_index": 5,
    "content": "Pillow from having to worry about each otherâs module names. Suppose you want to design a collection of modules (a âpackageâ) for the uniform handling of sound files and sound data. There are many different sound file formats (usually recognized by their extension, for example: .wav, .aiff, .au), so you may need to create and maintain a growing collection of modules for the conversion between the various file formats. There are also many different operations you might want to perform on sound data (such as mixing, adding echo, applying an equalizer function, creating an artificial stereo effect), so in addition you will be writing a never-ending stream of modules to perform these operations. Hereâs a possible structure for your package (expressed in terms of a hierarchical filesystem): sound/ Top-level package __init__.py Initialize the sound package formats/ Subpackage for file format conversions __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ Subpackage for sound effects __init__.py echo.py surround.py reverse.py ... filters/ Subpackage for filters __init__.py equalizer.py vocoder.py karaoke.py ... When importing the package, Python searches through the directories on sys.path looking for the package subdirectory. The __init__.py files are required to make Python treat directories containing the file as packages (unless using a namespace package, a relatively advanced feature). This prevents directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, __init__.py can just be an empty file, but it can also execute initialization code for the package or set the __all__ variable, described later. Users of the package can import individual modules from the package, for example: import sound.effects.echo This loads the submodule sound.effects.echo. It must be referenced with its full name. sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) An alternative way of importing the submodule is: from sound.effects import echo This also loads the submodule echo, and makes it available without its package prefix, so it can be used as follows: echo.echofilter(input, output, delay=0.7, atten=4) Yet another variation is to import the desired function or variable directly: from sound.effects.echo import echofilter Again, this loads the submodule echo, but this makes its function echofilter() directly available: echofilter(input, output, delay=0.7, atten=4) Note that when using from package import item, the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable. The import statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts to load it. If it fails to find it, an ImportError exception is raised. Contrarily, when using syntax like import item.subitem.subsubitem, each item except for the last must be a package; the last item can be a module or a package but canât be a class or function or variable defined in the previous item. 6.4.1. Importing * From a PackageÂ¶ Now what happens when the user writes from sound.effects import *? Ideally, one would hope that this somehow goes out",
    "content_length": 3324
  },
  {
    "id": "modules_chunk_6",
    "source_file": "modules",
    "chunk_index": 6,
    "content": "the last item can be a module or a package but canât be a class or function or variable defined in the previous item. 6.4.1. Importing * From a PackageÂ¶ Now what happens when the user writes from sound.effects import *? Ideally, one would hope that this somehow goes out to the filesystem, finds which submodules are present in the package, and imports them all. This could take a long time and importing sub-modules might have unwanted side-effects that should only happen when the sub-module is explicitly imported. The only solution is for the package author to provide an explicit index of the package. The import statement uses the following convention: if a packageâs __init__.py code defines a list named __all__, it is taken to be the list of module names that should be imported when from package import * is encountered. It is up to the package author to keep this list up-to-date when a new version of the package is released. Package authors may also decide not to support it, if they donât see a use for importing * from their package. For example, the file sound/effects/__init__.py could contain the following code: __all__ = [\"echo\", \"surround\", \"reverse\"] This would mean that from sound.effects import * would import the three named submodules of the sound.effects package. Be aware that submodules might become shadowed by locally defined names. For example, if you added a reverse function to the sound/effects/__init__.py file, the from sound.effects import * would only import the two submodules echo and surround, but not the reverse submodule, because it is shadowed by the locally defined reverse function: __all__ = [ \"echo\", # refers to the 'echo.py' file \"surround\", # refers to the 'surround.py' file \"reverse\", # !!! refers to the 'reverse' function now !!! ] def reverse(msg: str): # <-- this name shadows the 'reverse.py' submodule return msg[::-1] # in the case of a 'from sound.effects import *' If __all__ is not defined, the statement from sound.effects import * does not import all submodules from the package sound.effects into the current namespace; it only ensures that the package sound.effects has been imported (possibly running any initialization code in __init__.py) and then imports whatever names are defined in the package. This includes any names defined (and submodules explicitly loaded) by __init__.py. It also includes any submodules of the package that were explicitly loaded by previous import statements. Consider this code: import sound.effects.echo import sound.effects.surround from sound.effects import * In this example, the echo and surround modules are imported in the current namespace because they are defined in the sound.effects package when the from...import statement is executed. (This also works when __all__ is defined.) Although certain modules are designed to export only names that follow certain patterns when you use import *, it is still considered bad practice in production code. Remember, there is nothing wrong with using from package import specific_submodule! In fact, this is the recommended notation unless the importing module needs to use submodules with the same",
    "content_length": 3158
  },
  {
    "id": "modules_chunk_7",
    "source_file": "modules",
    "chunk_index": 7,
    "content": "export only names that follow certain patterns when you use import *, it is still considered bad practice in production code. Remember, there is nothing wrong with using from package import specific_submodule! In fact, this is the recommended notation unless the importing module needs to use submodules with the same name from different packages. 6.4.2. Intra-package ReferencesÂ¶ When packages are structured into subpackages (as with the sound package in the example), you can use absolute imports to refer to submodules of siblings packages. For example, if the module sound.filters.vocoder needs to use the echo module in the sound.effects package, it can use from sound.effects import echo. You can also write relative imports, with the from module import name form of import statement. These imports use leading dots to indicate the current and parent packages involved in the relative import. From the surround module for example, you might use: from . import echo from .. import formats from ..filters import equalizer Note that relative imports are based on the name of the current moduleâs package. Since the main module does not have a package, modules intended for use as the main module of a Python application must always use absolute imports. 6.4.3. Packages in Multiple DirectoriesÂ¶ Packages support one more special attribute, __path__. This is initialized to be a sequence of strings containing the name of the directory holding the packageâs __init__.py before the code in that file is executed. This variable can be modified; doing so affects future searches for modules and subpackages contained in the package. While this feature is not often needed, it can be used to extend the set of modules found in a package. Footnotes [1] In fact function definitions are also âstatementsâ that are âexecutedâ; the execution of a module-level function definition adds the function name to the moduleâs global namespace.",
    "content_length": 1947
  },
  {
    "id": "inputoutput_chunk_0",
    "source_file": "inputoutput",
    "chunk_index": 0,
    "content": "7. Input and OutputÂ¶ There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities. 7.1. Fancier Output FormattingÂ¶ So far weâve encountered two ways of writing values: expression statements and the print() function. (A third way is using the write() method of file objects; the standard output file can be referenced as sys.stdout. See the Library Reference for more information on this.) Often youâll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output. To use formatted string literals, begin a string with f or F before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between { and } characters that can refer to variables or literal values. >>> year = 2016 >>> event = 'Referendum' >>> f'Results of the {year} {event}' 'Results of the 2016 Referendum' The str.format() method of strings requires more manual effort. Youâll still use { and } to mark where a variable will be substituted and can provide detailed formatting directives, but youâll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: >>> yes_votes = 42_572_654 >>> total_votes = 85_705_149 >>> percentage = yes_votes / total_votes >>> '{:-9} YES votes {:2.2%}'.format(yes_votes, percentage) ' 42572654 YES votes 49.67%' Notice how the yes_votes are padded with spaces and a negative sign only for negative numbers. The example also prints percentage multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details). Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you donât need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the repr() or str() functions. The str() function is meant to return representations of values which are fairly human-readable, while repr() is meant to generate representations which can be read by the interpreter (or will force a SyntaxError if there is no equivalent syntax). For objects which donât have a particular representation for human consumption, str() will return the same value as repr(). Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. Some examples: >>> s = 'Hello, world.' >>> str(s) 'Hello, world.' >>> repr(s) \"'Hello, world.'\" >>> str(1/7) '0.14285714285714285' >>> x = 10 * 3.25 >>> y = 200 * 200 >>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...' >>> print(s)",
    "content_length": 3055
  },
  {
    "id": "inputoutput_chunk_1",
    "source_file": "inputoutput",
    "chunk_index": 1,
    "content": "s = 'Hello, world.' >>> str(s) 'Hello, world.' >>> repr(s) \"'Hello, world.'\" >>> str(1/7) '0.14285714285714285' >>> x = 10 * 3.25 >>> y = 200 * 200 >>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...' >>> print(s) The value of x is 32.5, and y is 40000... >>> # The repr() of a string adds string quotes and backslashes: >>> hello = 'hello, world\\n' >>> hellos = repr(hello) >>> print(hellos) 'hello, world\\n' >>> # The argument to repr() may be any Python object: >>> repr((x, y, ('spam', 'eggs'))) \"(32.5, 40000, ('spam', 'eggs'))\" The string module contains a Template class that offers yet another way to substitute values into strings, using placeholders like $x and replacing them with values from a dictionary, but offers much less control of the formatting. 7.1.1. Formatted String LiteralsÂ¶ Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with f or F and writing expressions as {expression}. An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: >>> import math >>> print(f'The value of pi is approximately {math.pi:.3f}.') The value of pi is approximately 3.142. Passing an integer after the ':' will cause that field to be a minimum number of characters wide. This is useful for making columns line up. >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678} >>> for name, phone in table.items(): ... print(f'{name:10} ==> {phone:10d}') ... Sjoerd ==> 4127 Jack ==> 4098 Dcab ==> 7678 Other modifiers can be used to convert the value before it is formatted. '!a' applies ascii(), '!s' applies str(), and '!r' applies repr(): >>> animals = 'eels' >>> print(f'My hovercraft is full of {animals}.') My hovercraft is full of eels. >>> print(f'My hovercraft is full of {animals!r}.') My hovercraft is full of 'eels'. The = specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: >>> bugs = 'roaches' >>> count = 13 >>> area = 'living room' >>> print(f'Debugging {bugs=} {count=} {area=}') Debugging bugs='roaches' count=13 area='living room' See self-documenting expressions for more information on the = specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. 7.1.2. The String format() MethodÂ¶ Basic usage of the str.format() method looks like this: >>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni')) We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the str.format() method. A number in the brackets can be used to refer to the position of the object passed into the str.format() method. >>> print('{0} and {1}'.format('spam', 'eggs')) spam and eggs >>> print('{1} and {0}'.format('spam', 'eggs')) eggs and spam If keyword arguments are used in",
    "content_length": 3068
  },
  {
    "id": "inputoutput_chunk_2",
    "source_file": "inputoutput",
    "chunk_index": 2,
    "content": "the objects passed into the str.format() method. A number in the brackets can be used to refer to the position of the object passed into the str.format() method. >>> print('{0} and {1}'.format('spam', 'eggs')) spam and eggs >>> print('{1} and {0}'.format('spam', 'eggs')) eggs and spam If keyword arguments are used in the str.format() method, their values are referred to by using the name of the argument. >>> print('This {food} is {adjective}.'.format( ... food='spam', adjective='absolutely horrible')) This spam is absolutely horrible. Positional and keyword arguments can be arbitrarily combined: >>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred', ... other='Georg')) The story of Bill, Manfred, and Georg. If you have a really long format string that you donât want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets '[]' to access the keys. >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678} >>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; ' ... 'Dcab: {0[Dcab]:d}'.format(table)) Jack: 4098; Sjoerd: 4127; Dcab: 8637678 This could also be done by passing the table dictionary as keyword arguments with the ** notation. >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678} >>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table)) Jack: 4098; Sjoerd: 4127; Dcab: 8637678 This is particularly useful in combination with the built-in function vars(), which returns a dictionary containing all local variables: >>> table = {k: str(v) for k, v in vars().items()} >>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()]) >>> print(message.format(**table)) __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: >>> for x in range(1, 11): ... print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x)) ... 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 8 64 512 9 81 729 10 100 1000 For a complete overview of string formatting with str.format(), see Format String Syntax. 7.1.3. Manual String FormattingÂ¶ Hereâs the same table of squares and cubes, formatted manually: >>> for x in range(1, 11): ... print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ') ... # Note use of 'end' on previous line ... print(repr(x*x*x).rjust(4)) ... 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 8 64 512 9 81 729 10 100 1000 (Note that the one space between each column was added by the way print() works: it always adds spaces between its arguments.) The str.rjust() method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods str.ljust() and str.center(). These methods do not write anything, they just return a new string. If the input string is too long, they donât truncate it, but return it unchanged; this will mess",
    "content_length": 3055
  },
  {
    "id": "inputoutput_chunk_3",
    "source_file": "inputoutput",
    "chunk_index": 3,
    "content": "field of a given width by padding it with spaces on the left. There are similar methods str.ljust() and str.center(). These methods do not write anything, they just return a new string. If the input string is too long, they donât truncate it, but return it unchanged; this will mess up your column lay-out but thatâs usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in x.ljust(n)[:n].) There is another method, str.zfill(), which pads a numeric string on the left with zeros. It understands about plus and minus signs: >>> '12'.zfill(5) '00012' >>> '-3.14'.zfill(7) '-003.14' >>> '3.14159265359'.zfill(5) '3.14159265359' 7.1.4. Old string formattingÂ¶ The % operator (modulo) can also be used for string formatting. Given format % values (where format is a string), % conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: >>> import math >>> print('The value of pi is approximately %5.3f.' % math.pi) The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section. 7.2. Reading and Writing FilesÂ¶ open() returns a file object, and is most commonly used with two positional arguments and one keyword argument: open(filename, mode, encoding=None) >>> f = open('workfile', 'w', encoding=\"utf-8\") The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be 'r' when the file will only be read, 'w' for only writing (an existing file with the same name will be erased), and 'a' opens the file for appending; any data written to the file is automatically added to the end. 'r+' opens the file for both reading and writing. The mode argument is optional; 'r' will be assumed if itâs omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see open()). Because UTF-8 is the modern de-facto standard, encoding=\"utf-8\" is recommended unless you know that you need to use a different encoding. Appending a 'b' to the mode opens the file in binary mode. Binary mode data is read and written as bytes objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings (\\n on Unix, \\r\\n on Windows) to just \\n. When writing in text mode, the default is to convert occurrences of \\n back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in JPEG or EXE files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the with keyword when dealing with file",
    "content_length": 3016
  },
  {
    "id": "inputoutput_chunk_4",
    "source_file": "inputoutput",
    "chunk_index": 4,
    "content": "endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in JPEG or EXE files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the with keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using with is also much shorter than writing equivalent try-finally blocks: >>> with open('workfile', encoding=\"utf-8\") as f: ... read_data = f.read() >>> # We can check that the file has been automatically closed. >>> f.closed True If youâre not using the with keyword, then you should call f.close() to close the file and immediately free up any system resources used by it. Warning Calling f.write() without using the with keyword or calling f.close() might result in the arguments of f.write() not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a with statement or by calling f.close(), attempts to use the file object will automatically fail. >>> f.close() >>> f.read() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: I/O operation on closed file. 7.2.1. Methods of File ObjectsÂ¶ The rest of the examples in this section will assume that a file object called f has already been created. To read a fileâs contents, call f.read(size), which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; itâs your problem if the file is twice as large as your machineâs memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, f.read() will return an empty string (''). >>> f.read() 'This is the entire file.\\n' >>> f.read() '' f.readline() reads a single line from the file; a newline character (\\n) is left at the end of the string, and is only omitted on the last line of the file if the file doesnât end in a newline. This makes the return value unambiguous; if f.readline() returns an empty string, the end of the file has been reached, while a blank line is represented by '\\n', a string containing only a single newline. >>> f.readline() 'This is the first line of the file.\\n' >>> f.readline() 'Second line of the file\\n' >>> f.readline() '' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: >>> for line in f: ... print(line, end='') ... This is the first line of the file. Second line of the file If you want to read all the lines of a file in a list you can",
    "content_length": 2844
  },
  {
    "id": "inputoutput_chunk_5",
    "source_file": "inputoutput",
    "chunk_index": 5,
    "content": "file object. This is memory efficient, fast, and leads to simple code: >>> for line in f: ... print(line, end='') ... This is the first line of the file. Second line of the file If you want to read all the lines of a file in a list you can also use list(f) or f.readlines(). f.write(string) writes the contents of string to the file, returning the number of characters written. >>> f.write('This is a test\\n') 15 Other types of objects need to be converted â either to a string (in text mode) or a bytes object (in binary mode) â before writing them: >>> value = ('the answer', 42) >>> s = str(value) # convert the tuple to string >>> f.write(s) 18 f.tell() returns an integer giving the file objectâs current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file objectâs position, use f.seek(offset, whence). The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. >>> f = open('workfile', 'rb+') >>> f.write(b'0123456789abcdef') 16 >>> f.seek(5) # Go to the 6th byte in the file 5 >>> f.read(1) b'5' >>> f.seek(-3, 2) # Go to the 3rd byte before the end 13 >>> f.read(1) b'd' In text files (those opened without a b in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with seek(0, 2)) and the only valid offset values are those returned from the f.tell(), or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as isatty() and truncate() which are less frequently used; consult the Library Reference for a complete guide to file objects. 7.2.2. Saving structured data with jsonÂ¶ Strings can easily be written to and read from a file. Numbers take a bit more effort, since the read() method only returns strings, which will have to be passed to a function like int(), which takes a string like '123' and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called json can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing",
    "content_length": 2932
  },
  {
    "id": "inputoutput_chunk_6",
    "source_file": "inputoutput",
    "chunk_index": 6,
    "content": "to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called json can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. Note The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object x, you can view its JSON string representation with a simple line of code: >>> import json >>> x = [1, 'simple', 'list'] >>> json.dumps(x) '[1, \"simple\", \"list\"]' Another variant of the dumps() function, called dump(), simply serializes the object to a text file. So if f is a text file object opened for writing, we can do this: json.dump(x, f) To decode the object again, if f is a binary file or text file object which has been opened for reading: x = json.load(f) Note JSON files must be encoded in UTF-8. Use encoding=\"utf-8\" when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the json module contains an explanation of this. See also pickle - the pickle module Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker.",
    "content_length": 1938
  },
  {
    "id": "stdlib2_chunk_0",
    "source_file": "stdlib2",
    "chunk_index": 0,
    "content": "11. Brief Tour of the Standard Library â Part IIÂ¶ This second tour covers more advanced modules that support professional programming needs. These modules rarely occur in small scripts. 11.1. Output FormattingÂ¶ The reprlib module provides a version of repr() customized for abbreviated displays of large or deeply nested containers: >>> import reprlib >>> reprlib.repr(set('supercalifragilisticexpialidocious')) \"{'a', 'c', 'd', 'e', 'f', 'g', ...}\" The pprint module offers more sophisticated control over printing both built-in and user defined objects in a way that is readable by the interpreter. When the result is longer than one line, the âpretty printerâ adds line breaks and indentation to more clearly reveal data structure: >>> import pprint >>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta', ... 'yellow'], 'blue']]] ... >>> pprint.pprint(t, width=30) [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta', 'yellow'], 'blue']]] The textwrap module formats paragraphs of text to fit a given screen width: >>> import textwrap >>> doc = \"\"\"The wrap() method is just like fill() except that it returns ... a list of strings instead of one big string with newlines to separate ... the wrapped lines.\"\"\" ... >>> print(textwrap.fill(doc, width=40)) The wrap() method is just like fill() except that it returns a list of strings instead of one big string with newlines to separate the wrapped lines. The locale module accesses a database of culture specific data formats. The grouping attribute of localeâs format function provides a direct way of formatting numbers with group separators: >>> import locale >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252') 'English_United States.1252' >>> conv = locale.localeconv() # get a mapping of conventions >>> x = 1234567.8 >>> locale.format_string(\"%d\", x, grouping=True) '1,234,567' >>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'], ... conv['frac_digits'], x), grouping=True) '$1,234,567.80' 11.2. TemplatingÂ¶ The string module includes a versatile Template class with a simplified syntax suitable for editing by end-users. This allows users to customize their applications without having to alter the application. The format uses placeholder names formed by $ with valid Python identifiers (alphanumeric characters and underscores). Surrounding the placeholder with braces allows it to be followed by more alphanumeric letters with no intervening spaces. Writing $$ creates a single escaped $: >>> from string import Template >>> t = Template('${village}folk send $$10 to $cause.') >>> t.substitute(village='Nottingham', cause='the ditch fund') 'Nottinghamfolk send $10 to the ditch fund.' The substitute() method raises a KeyError when a placeholder is not supplied in a dictionary or a keyword argument. For mail-merge style applications, user supplied data may be incomplete and the safe_substitute() method may be more appropriate â it will leave placeholders unchanged if data is missing: >>> t = Template('Return the $item to $owner.') >>> d = dict(item='unladen swallow') >>> t.substitute(d) Traceback (most recent call last): ... KeyError: 'owner' >>> t.safe_substitute(d) 'Return the unladen swallow to $owner.' Template subclasses can specify a custom delimiter. For example, a batch renaming utility for a photo browser may elect to use percent signs for placeholders such as the current date, image sequence number, or file format: >>> import time, os.path >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']",
    "content_length": 3553
  },
  {
    "id": "stdlib2_chunk_1",
    "source_file": "stdlib2",
    "chunk_index": 1,
    "content": "unladen swallow to $owner.' Template subclasses can specify a custom delimiter. For example, a batch renaming utility for a photo browser may elect to use percent signs for placeholders such as the current date, image sequence number, or file format: >>> import time, os.path >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg'] >>> class BatchRename(Template): ... delimiter = '%' ... >>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format): ') Enter rename style (%d-date %n-seqnum %f-format): Ashley_%n%f >>> t = BatchRename(fmt) >>> date = time.strftime('%d%b%y') >>> for i, filename in enumerate(photofiles): ... base, ext = os.path.splitext(filename) ... newname = t.substitute(d=date, n=i, f=ext) ... print('{0} --> {1}'.format(filename, newname)) img_1074.jpg --> Ashley_0.jpg img_1076.jpg --> Ashley_1.jpg img_1077.jpg --> Ashley_2.jpg Another application for templating is separating program logic from the details of multiple output formats. This makes it possible to substitute custom templates for XML files, plain text reports, and HTML web reports. 11.3. Working with Binary Data Record LayoutsÂ¶ The struct module provides pack() and unpack() functions for working with variable length binary record formats. The following example shows how to loop through header information in a ZIP file without using the zipfile module. Pack codes \"H\" and \"I\" represent two and four byte unsigned numbers respectively. The \"<\" indicates that they are standard size and in little-endian byte order: import struct with open('myfile.zip', 'rb') as f: data = f.read() start = 0 for i in range(3): # show the first 3 file headers start += 14 fields = struct.unpack('<IIIHH', data[start:start+16]) crc32, comp_size, uncomp_size, filenamesize, extra_size = fields start += 16 filename = data[start:start+filenamesize] start += filenamesize extra = data[start:start+extra_size] print(filename, hex(crc32), comp_size, uncomp_size) start += extra_size + comp_size # skip to the next header 11.4. Multi-threadingÂ¶ Threading is a technique for decoupling tasks which are not sequentially dependent. Threads can be used to improve the responsiveness of applications that accept user input while other tasks run in the background. A related use case is running I/O in parallel with computations in another thread. The following code shows how the high level threading module can run tasks in background while the main program continues to run: import threading, zipfile class AsyncZip(threading.Thread): def __init__(self, infile, outfile): threading.Thread.__init__(self) self.infile = infile self.outfile = outfile def run(self): f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED) f.write(self.infile) f.close() print('Finished background zip of:', self.infile) background = AsyncZip('mydata.txt', 'myarchive.zip') background.start() print('The main program continues to run in foreground.') background.join() # Wait for the background task to finish print('Main program waited until background was done.') The principal challenge of multi-threaded applications is coordinating threads that share data or other resources. To that end, the threading module provides a number of synchronization primitives including locks, events, condition variables, and semaphores. While those tools are powerful, minor design errors can result in problems that are difficult to reproduce. So, the preferred approach to task coordination is to concentrate all access to a resource in a single thread and then use the queue module to feed that thread with requests from other threads. Applications using Queue objects for",
    "content_length": 3629
  },
  {
    "id": "stdlib2_chunk_2",
    "source_file": "stdlib2",
    "chunk_index": 2,
    "content": "design errors can result in problems that are difficult to reproduce. So, the preferred approach to task coordination is to concentrate all access to a resource in a single thread and then use the queue module to feed that thread with requests from other threads. Applications using Queue objects for inter-thread communication and coordination are easier to design, more readable, and more reliable. 11.5. LoggingÂ¶ The logging module offers a full featured and flexible logging system. At its simplest, log messages are sent to a file or to sys.stderr: import logging logging.debug('Debugging information') logging.info('Informational message') logging.warning('Warning:config file %s not found', 'server.conf') logging.error('Error occurred') logging.critical('Critical error -- shutting down') This produces the following output: WARNING:root:Warning:config file server.conf not found ERROR:root:Error occurred CRITICAL:root:Critical error -- shutting down By default, informational and debugging messages are suppressed and the output is sent to standard error. Other output options include routing messages through email, datagrams, sockets, or to an HTTP Server. New filters can select different routing based on message priority: DEBUG, INFO, WARNING, ERROR, and CRITICAL. The logging system can be configured directly from Python or can be loaded from a user editable configuration file for customized logging without altering the application. 11.6. Weak ReferencesÂ¶ Python does automatic memory management (reference counting for most objects and garbage collection to eliminate cycles). The memory is freed shortly after the last reference to it has been eliminated. This approach works fine for most applications but occasionally there is a need to track objects only as long as they are being used by something else. Unfortunately, just tracking them creates a reference that makes them permanent. The weakref module provides tools for tracking objects without creating a reference. When the object is no longer needed, it is automatically removed from a weakref table and a callback is triggered for weakref objects. Typical applications include caching objects that are expensive to create: >>> import weakref, gc >>> class A: ... def __init__(self, value): ... self.value = value ... def __repr__(self): ... return str(self.value) ... >>> a = A(10) # create a reference >>> d = weakref.WeakValueDictionary() >>> d['primary'] = a # does not create a reference >>> d['primary'] # fetch the object if it is still alive 10 >>> del a # remove the one reference >>> gc.collect() # run garbage collection right away 0 >>> d['primary'] # entry was automatically removed Traceback (most recent call last): File \"<stdin>\", line 1, in <module> d['primary'] # entry was automatically removed File \"C:/python313/lib/weakref.py\", line 46, in __getitem__ o = self.data[key]() KeyError: 'primary' 11.7. Tools for Working with ListsÂ¶ Many data structure needs can be met with the built-in list type. However, sometimes there is a need for alternative implementations with different performance trade-offs. The array module provides an array object that is like a list that stores only homogeneous data and stores it more compactly. The following example shows an array of numbers stored as two byte unsigned binary numbers (typecode \"H\") rather than the usual 16 bytes per entry",
    "content_length": 3379
  },
  {
    "id": "stdlib2_chunk_3",
    "source_file": "stdlib2",
    "chunk_index": 3,
    "content": "different performance trade-offs. The array module provides an array object that is like a list that stores only homogeneous data and stores it more compactly. The following example shows an array of numbers stored as two byte unsigned binary numbers (typecode \"H\") rather than the usual 16 bytes per entry for regular lists of Python int objects: >>> from array import array >>> a = array('H', [4000, 10, 700, 22222]) >>> sum(a) 26932 >>> a[1:3] array('H', [10, 700]) The collections module provides a deque object that is like a list with faster appends and pops from the left side but slower lookups in the middle. These objects are well suited for implementing queues and breadth first tree searches: >>> from collections import deque >>> d = deque([\"task1\", \"task2\", \"task3\"]) >>> d.append(\"task4\") >>> print(\"Handling\", d.popleft()) Handling task1 unsearched = deque([starting_node]) def breadth_first_search(unsearched): node = unsearched.popleft() for m in gen_moves(node): if is_goal(m): return m unsearched.append(m) In addition to alternative list implementations, the library also offers other tools such as the bisect module with functions for manipulating sorted lists: >>> import bisect >>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')] >>> bisect.insort(scores, (300, 'ruby')) >>> scores [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')] The heapq module provides functions for implementing heaps based on regular lists. The lowest valued entry is always kept at position zero. This is useful for applications which repeatedly access the smallest element but do not want to run a full list sort: >>> from heapq import heapify, heappop, heappush >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] >>> heapify(data) # rearrange the list into heap order >>> heappush(data, -5) # add a new entry >>> [heappop(data) for i in range(3)] # fetch the three smallest entries [-5, 0, 1] 11.8. Decimal Floating-Point ArithmeticÂ¶ The decimal module offers a Decimal datatype for decimal floating-point arithmetic. Compared to the built-in float implementation of binary floating point, the class is especially helpful for financial applications and other uses which require exact decimal representation, control over precision, control over rounding to meet legal or regulatory requirements, tracking of significant decimal places, or applications where the user expects the results to match calculations done by hand. For example, calculating a 5% tax on a 70 cent phone charge gives different results in decimal floating point and binary floating point. The difference becomes significant if the results are rounded to the nearest cent: >>> from decimal import * >>> round(Decimal('0.70') * Decimal('1.05'), 2) Decimal('0.74') >>> round(.70 * 1.05, 2) 0.73 The Decimal result keeps a trailing zero, automatically inferring four place significance from multiplicands with two place significance. Decimal reproduces mathematics as done by hand and avoids issues that can arise when binary floating point cannot exactly represent decimal quantities. Exact representation enables the Decimal class to perform modulo calculations and equality tests that are unsuitable for binary floating point: >>> Decimal('1.00') % Decimal('.10') Decimal('0.00') >>> 1.00 % 0.10 0.09999999999999995 >>> sum([Decimal('0.1')]*10) == Decimal('1.0')",
    "content_length": 3373
  },
  {
    "id": "stdlib2_chunk_4",
    "source_file": "stdlib2",
    "chunk_index": 4,
    "content": "hand and avoids issues that can arise when binary floating point cannot exactly represent decimal quantities. Exact representation enables the Decimal class to perform modulo calculations and equality tests that are unsuitable for binary floating point: >>> Decimal('1.00') % Decimal('.10') Decimal('0.00') >>> 1.00 % 0.10 0.09999999999999995 >>> sum([Decimal('0.1')]*10) == Decimal('1.0') True >>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0 False The decimal module provides arithmetic with as much precision as needed: >>> getcontext().prec = 36 >>> Decimal(1) / Decimal(7) Decimal('0.142857142857142857142857142857142857')",
    "content_length": 647
  },
  {
    "id": "interpreter_chunk_0",
    "source_file": "interpreter",
    "chunk_index": 0,
    "content": "2. Using the Python InterpreterÂ¶ 2.1. Invoking the InterpreterÂ¶ The Python interpreter is usually installed as /usr/local/bin/python3.13 on those machines where it is available; putting /usr/local/bin in your Unix shellâs search path makes it possible to start it by typing the command: python3.13 to the shell. [1] Since the choice of the directory where the interpreter lives is an installation option, other places are possible; check with your local Python guru or system administrator. (E.g., /usr/local/python is a popular alternative location.) On Windows machines where you have installed Python from the Microsoft Store, the python3.13 command will be available. If you have the py.exe launcher installed, you can use the py command. See Excursus: Setting environment variables for other ways to launch Python. Typing an end-of-file character (Control-D on Unix, Control-Z on Windows) at the primary prompt causes the interpreter to exit with a zero exit status. If that doesnât work, you can exit the interpreter by typing the following command: quit(). The interpreterâs line-editing features include interactive editing, history substitution and code completion on systems that support the GNU Readline library. Perhaps the quickest check to see whether command line editing is supported is typing Control-P to the first Python prompt you get. If it beeps, you have command line editing; see Appendix Interactive Input Editing and History Substitution for an introduction to the keys. If nothing appears to happen, or if ^P is echoed, command line editing isnât available; youâll only be able to use backspace to remove characters from the current line. The interpreter operates somewhat like the Unix shell: when called with standard input connected to a tty device, it reads and executes commands interactively; when called with a file name argument or with a file as standard input, it reads and executes a script from that file. A second way of starting the interpreter is python -c command [arg] ..., which executes the statement(s) in command, analogous to the shellâs -c option. Since Python statements often contain spaces or other characters that are special to the shell, it is usually advised to quote command in its entirety. Some Python modules are also useful as scripts. These can be invoked using python -m module [arg] ..., which executes the source file for module as if you had spelled out its full name on the command line. When a script file is used, it is sometimes useful to be able to run the script and enter interactive mode afterwards. This can be done by passing -i before the script. All command line options are described in Command line and environment. 2.1.1. Argument PassingÂ¶ When known to the interpreter, the script name and additional arguments thereafter are turned into a list of strings and assigned to the argv variable in the sys module. You can access this list by executing import sys. The length of the list is at least one; when no script and no arguments are given, sys.argv[0] is an empty string. When the script name",
    "content_length": 3092
  },
  {
    "id": "interpreter_chunk_1",
    "source_file": "interpreter",
    "chunk_index": 1,
    "content": "into a list of strings and assigned to the argv variable in the sys module. You can access this list by executing import sys. The length of the list is at least one; when no script and no arguments are given, sys.argv[0] is an empty string. When the script name is given as '-' (meaning standard input), sys.argv[0] is set to '-'. When -c command is used, sys.argv[0] is set to '-c'. When -m module is used, sys.argv[0] is set to the full name of the located module. Options found after -c command or -m module are not consumed by the Python interpreterâs option processing but left in sys.argv for the command or module to handle. 2.1.2. Interactive ModeÂ¶ When commands are read from a tty, the interpreter is said to be in interactive mode. In this mode it prompts for the next command with the primary prompt, usually three greater-than signs (>>>); for continuation lines it prompts with the secondary prompt, by default three dots (...). The interpreter prints a welcome message stating its version number and a copyright notice before printing the first prompt: $ python3.13 Python 3.13 (default, April 4 2023, 09:25:04) [GCC 10.2.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Continuation lines are needed when entering a multi-line construct. As an example, take a look at this if statement: >>> the_world_is_flat = True >>> if the_world_is_flat: ... print(\"Be careful not to fall off!\") ... Be careful not to fall off! For more on interactive mode, see Interactive Mode. 2.2. The Interpreter and Its EnvironmentÂ¶ 2.2.1. Source Code EncodingÂ¶ By default, Python source files are treated as encoded in UTF-8. In that encoding, characters of most languages in the world can be used simultaneously in string literals, identifiers and comments â although the standard library only uses ASCII characters for identifiers, a convention that any portable code should follow. To display all these characters properly, your editor must recognize that the file is UTF-8, and it must use a font that supports all the characters in the file. To declare an encoding other than the default one, a special comment line should be added as the first line of the file. The syntax is as follows: # -*- coding: encoding -*- where encoding is one of the valid codecs supported by Python. For example, to declare that Windows-1252 encoding is to be used, the first line of your source code file should be: # -*- coding: cp1252 -*- One exception to the first line rule is when the source code starts with a UNIX âshebangâ line. In this case, the encoding declaration should be added as the second line of the file. For example: #!/usr/bin/env python3 # -*- coding: cp1252 -*- Footnotes [1] On Unix, the Python 3.x interpreter is by default not installed with the executable named python, so that it does not conflict with a simultaneously installed Python 2.x executable.",
    "content_length": 2907
  },
  {
    "id": "interpreter_chunk_2",
    "source_file": "interpreter",
    "chunk_index": 2,
    "content": "For example: #!/usr/bin/env python3 # -*- coding: cp1252 -*- Footnotes [1] On Unix, the Python 3.x interpreter is by default not installed with the executable named python, so that it does not conflict with a simultaneously installed Python 2.x executable.",
    "content_length": 256
  },
  {
    "id": "string_chunk_0",
    "source_file": "string",
    "chunk_index": 0,
    "content": "string â Common string operationsÂ¶ Source code: Lib/string.py See also Text Sequence Type â str String Methods String constantsÂ¶ The constants defined in this module are: string.ascii_lettersÂ¶ The concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent. string.ascii_lowercaseÂ¶ The lowercase letters 'abcdefghijklmnopqrstuvwxyz'. This value is not locale-dependent and will not change. string.ascii_uppercaseÂ¶ The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. This value is not locale-dependent and will not change. string.digitsÂ¶ The string '0123456789'. string.hexdigitsÂ¶ The string '0123456789abcdefABCDEF'. string.octdigitsÂ¶ The string '01234567'. string.punctuationÂ¶ String of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~. string.printableÂ¶ String of ASCII characters which are considered printable by Python. This is a combination of digits, ascii_letters, punctuation, and whitespace. Note By design, string.printable.isprintable() returns False. In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE). string.whitespaceÂ¶ A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab. Custom String FormattingÂ¶ The built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101. The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method. class string.FormatterÂ¶ The Formatter class has the following public methods: format(format_string, /, *args, **kwargs)Â¶ The primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat(). Changed in version 3.7: A format string argument is now positional-only. vformat(format_string, args, kwargs)Â¶ This function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below. In addition, the Formatter defines a number of methods that are intended to be replaced by subclasses: parse(format_string)Â¶ Loop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields. The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None. get_field(field_name, args, kwargs)Â¶ Given field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101, such as â0[name]â or âlabel.titleâ. args and kwargs are as passed in to vformat(). The return value used_key has the same meaning as the key parameter",
    "content_length": 3606
  },
  {
    "id": "string_chunk_1",
    "source_file": "string",
    "chunk_index": 1,
    "content": "it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101, such as â0[name]â or âlabel.titleâ. args and kwargs are as passed in to vformat(). The return value used_key has the same meaning as the key parameter to get_value(). get_value(key, args, kwargs)Â¶ Retrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs. The args parameter is set to the list of positional arguments to vformat(), and the kwargs parameter is set to the dictionary of keyword arguments. For compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations. So for example, the field expression â0.nameâ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function. If the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised. check_unused_args(used_args, args, kwargs)Â¶ Implement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails. format_field(value, format_spec)Â¶ format_field() simply calls the global format() built-in. The method is provided so that subclasses can override it. convert_field(value, conversion)Â¶ Converts the value (returned by get_field()) given a conversion type (as in the tuple returned by the parse() method). The default version understands âsâ (str), ârâ (repr) and âaâ (ascii) conversion types. Format String SyntaxÂ¶ The str.format() method and the Formatter class share the same syntax for format strings (although in the case of Formatter, subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions. Format strings contain âreplacement fieldsâ surrounded by curly braces {}. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}. The grammar for a replacement field is as follows: replacement_field ::= \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\" field_name ::= arg_name (\".\" attribute_name | \"[\" element_index \"]\")* arg_name ::= [identifier | digit+] attribute_name ::= identifier element_index ::= digit+ | index_string index_string ::= <any source character except \"]\"> + conversion ::= \"r\" | \"s\" | \"a\" format_spec ::= format-spec:format_spec In less formal terms,",
    "content_length": 3223
  },
  {
    "id": "string_chunk_2",
    "source_file": "string",
    "chunk_index": 2,
    "content": "[field_name] [\"!\" conversion] [\":\" format_spec] \"}\" field_name ::= arg_name (\".\" attribute_name | \"[\" element_index \"]\")* arg_name ::= [identifier | digit+] attribute_name ::= identifier element_index ::= digit+ | index_string index_string ::= <any source character except \"]\"> + conversion ::= \"r\" | \"s\" | \"a\" format_spec ::= format-spec:format_spec In less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point '!', and a format_spec, which is preceded by a colon ':'. These specify a non-default format for the replacement value. See also the Format Specification Mini-Language section. The field_name itself begins with an arg_name that is either a number or a keyword. If itâs a number, it refers to a positional argument, and if itâs a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to str.isdecimal() on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, â¦ in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, â¦ will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings '10' or ':-]') within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form '.name' selects the named attribute using getattr(), while an expression of the form '[index]' does an index lookup using __getitem__(). Changed in version 3.1: The positional argument specifiers can be omitted for str.format(), so '{} {}'.format(a, b) is equivalent to '{0} {1}'.format(a, b). Changed in version 3.4: The positional argument specifiers can be omitted for Formatter. Some simple format string examples: \"First, thou shalt count to {0}\" # References first positional argument \"Bring me a {}\" # Implicitly references the first positional argument \"From {} to {}\" # Same as \"From {0} to {1}\" \"My quest is {name}\" # References keyword argument 'name' \"Weight in tons {0.weight}\" # 'weight' attribute of first positional arg \"Units destroyed: {players[0]}\" # First element of keyword argument 'players'. The conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the __format__() method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling __format__(), the normal formatting logic is bypassed. Three conversion flags are currently supported: '!s' which calls str() on the value, '!r' which calls repr() and '!a' which calls ascii(). Some examples: \"Harold's a clever {0!s}\" # Calls str() on the argument first \"Bring out the holy {name!r}\" # Calls repr() on the argument first \"More {!a}\" # Calls ascii() on the argument first",
    "content_length": 3115
  },
  {
    "id": "string_chunk_3",
    "source_file": "string",
    "chunk_index": 3,
    "content": "'!s' which calls str() on the value, '!r' which calls repr() and '!a' which calls ascii(). Some examples: \"Harold's a clever {0!s}\" # Calls str() on the argument first \"Bring out the holy {name!r}\" # Calls repr() on the argument first \"More {!a}\" # Calls ascii() on the argument first The format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own âformatting mini-languageâ or interpretation of the format_spec. Most built-in types support a common formatting mini-language, which is described in the next section. A format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified. See the Format examples section for some examples. Format Specification Mini-LanguageÂ¶ âFormat specificationsâ are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in format() function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called str() on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: format_spec ::= [options][width][grouping][\".\" precision][type] options ::= [[fill]align][sign][\"z\"][\"#\"][\"0\"] fill ::= <any character> align ::= \"<\" | \">\" | \"=\" | \"^\" sign ::= \"+\" | \"-\" | \" \" width ::= digit+ grouping ::= \",\" | \"_\" precision ::= digit+ type ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\" If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (â{â or â}â) as the fill character in a formatted string literal or when using the str.format() method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesnât affect the format() function. The meaning of the various alignment options is as follows: Option Meaning '<' Forces the field to be left-aligned within the available space (this is the default for most objects). '>' Forces the field to be right-aligned within the available space (this is the default for numbers). '=' Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the",
    "content_length": 3067
  },
  {
    "id": "string_chunk_4",
    "source_file": "string",
    "chunk_index": 4,
    "content": "available space (this is the default for most objects). '>' Forces the field to be right-aligned within the available space (this is the default for numbers). '=' Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form â+000000120â. This alignment option is only valid for numeric types, excluding complex. It becomes the default for numbers when â0â immediately precedes the field width. '^' Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: Option Meaning '+' Indicates that a sign should be used for both positive as well as negative numbers. '-' Indicates that a sign should be used only for negative numbers (this is the default behavior). space Indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The 'z' option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the 'z' option (see also PEP 682). The '#' option causes the âalternate formâ to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result. The width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types, excluding complex. This is equivalent to a fill character of '0' with an alignment type of '='. Changed in version 3.10: Preceding the width field by '0' no longer affects the default alignment for strings. The grouping option after the width field specifies a digit group separator for the integral part of a number. It can be one of the following: Option Meaning ',' Inserts a comma every 3 digits for integer presentation type 'd' and floating-point presentation types, excluding 'n'. For other presentation types, this option is not supported. '_' Inserts an underscore every 3 digits for integer presentation type",
    "content_length": 3024
  },
  {
    "id": "string_chunk_5",
    "source_file": "string",
    "chunk_index": 5,
    "content": "of a number. It can be one of the following: Option Meaning ',' Inserts a comma every 3 digits for integer presentation type 'd' and floating-point presentation types, excluding 'n'. For other presentation types, this option is not supported. '_' Inserts an underscore every 3 digits for integer presentation type 'd' and floating-point presentation types, excluding 'n'. For integer presentation types 'b', 'o', 'x', and 'X', underscores are inserted every 4 digits. For other presentation types, this option is not supported. For a locale aware separator, use the 'n' presentation type instead. Changed in version 3.1: Added the ',' option (see also PEP 378). Changed in version 3.6: Added the '_' option (see also PEP 515). The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'. For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: Type Meaning 's' String format. This is the default type for strings and may be omitted. None The same as 's'. The available integer presentation types are: Type Meaning 'b' Binary format. Outputs the number in base 2. 'c' Character. Converts the integer to the corresponding unicode character before printing. 'd' Decimal Integer. Outputs the number in base 10. 'o' Octal format. Outputs the number in base 8. 'x' Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. 'X' Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case '#' is specified, the prefix '0x' will be upper-cased to '0X' as well. 'n' Number. This is the same as 'd', except that it uses the current locale setting to insert the appropriate digit group separators. None The same as 'd'. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating-point number before formatting. The available presentation types for float and Decimal values are: Type Meaning 'e' Scientific notation. For a given precision p, formats the number in scientific notation with the letter âeâ separating the coefficient from the exponent. The coefficient has one digit before and p digits after the decimal point, for a total of p + 1 significant digits. With no precision given, uses a precision of 6 digits after the decimal point for float, and shows all coefficient digits for Decimal. If p=0, the decimal point is omitted unless the # option is used. 'E' Scientific notation. Same as 'e' except it uses an upper case âEâ as the separator character. 'f' Fixed-point notation. For",
    "content_length": 3037
  },
  {
    "id": "string_chunk_6",
    "source_file": "string",
    "chunk_index": 6,
    "content": "of 6 digits after the decimal point for float, and shows all coefficient digits for Decimal. If p=0, the decimal point is omitted unless the # option is used. 'E' Scientific notation. Same as 'e' except it uses an upper case âEâ as the separator character. 'f' Fixed-point notation. For a given precision p, formats the number as a decimal number with exactly p digits following the decimal point. With no precision given, uses a precision of 6 digits after the decimal point for float, and uses a precision large enough to show all coefficient digits for Decimal. If p=0, the decimal point is omitted unless the # option is used. 'F' Fixed-point notation. Same as 'f', but converts nan to NAN and inf to INF. 'g' General format. For a given precision p >= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of 0 is treated as equivalent to a precision of 1. The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then, if m <= exp < p, where m is -4 for floats and -6 for Decimals, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the '#' option is used. With no precision given, uses a precision of 6 significant digits for float. For Decimal, the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than 1e-6 in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision. 'G' General format. Same as 'g' except switches to 'E' if the number gets too large. The representations of infinity and NaN are uppercased, too. 'n' Number. This is the same as 'g', except that it uses the current locale setting to insert the appropriate digit group separators for the integral part of a number. '%' Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign. None For float this is like the 'g' type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when exp >= p - 1. When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For Decimal, this is the same as either 'g' or",
    "content_length": 2885
  },
  {
    "id": "string_chunk_7",
    "source_file": "string",
    "chunk_index": 7,
    "content": "at least one digit past the decimal point, and switches to the scientific notation when exp >= p - 1. When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For Decimal, this is the same as either 'g' or 'G' depending on the value of context.capitals for the current decimal context. The overall effect is to match the output of str() as altered by the other format modifiers. The result should be correctly rounded to a given precision p of digits after the decimal point. The rounding mode for float matches that of the round() builtin. For Decimal, the rounding mode of the current context will be used. The available presentation types for complex are the same as those for float ('%' is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a j suffix. If the presentation type is missing, the result will match the output of str() (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers. Format examplesÂ¶ This section contains examples of the str.format() syntax and comparison with the old %-formatting. In most of the cases the syntax is similar to the old %-formatting, with the addition of the {} and with : used instead of %. For example, '%03.2f' can be translated to '{:03.2f}'. The new format syntax also supports new and different options, shown in the following examples. Accessing arguments by position: >>> '{0}, {1}, {2}'.format('a', 'b', 'c') 'a, b, c' >>> '{}, {}, {}'.format('a', 'b', 'c') # 3.1+ only 'a, b, c' >>> '{2}, {1}, {0}'.format('a', 'b', 'c') 'c, b, a' >>> '{2}, {1}, {0}'.format(*'abc') # unpacking argument sequence 'c, b, a' >>> '{0}{1}{0}'.format('abra', 'cad') # arguments' indices can be repeated 'abracadabra' Accessing arguments by name: >>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W') 'Coordinates: 37.24N, -115.81W' >>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'} >>> 'Coordinates: {latitude}, {longitude}'.format(**coord) 'Coordinates: 37.24N, -115.81W' Accessing argumentsâ attributes: >>> c = 3-5j >>> ('The complex number {0} is formed from the real part {0.real} ' ... 'and the imaginary part {0.imag}.').format(c) 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' >>> class Point: ... def __init__(self, x, y): ... self.x, self.y = x, y ... def __str__(self): ... return 'Point({self.x}, {self.y})'.format(self=self) ... >>> str(Point(4, 2)) 'Point(4, 2)' Accessing argumentsâ items: >>> coord = (3, 5) >>> 'X: {0[0]}; Y: {0[1]}'.format(coord) 'X: 3; Y: 5' Replacing %s and %r: >>> \"repr() shows quotes: {!r}; str() doesn't: {!s}\".format('test1', 'test2') \"repr() shows quotes: 'test1'; str() doesn't: test2\" Aligning the text and specifying a width: >>> '{:<30}'.format('left aligned') 'left aligned ' >>> '{:>30}'.format('right aligned') ' right aligned' >>> '{:^30}'.format('centered') ' centered ' >>> '{:*^30}'.format('centered') # use '*' as a fill char '***********centered***********' Replacing %+f, %-f, and % f",
    "content_length": 3298
  },
  {
    "id": "string_chunk_8",
    "source_file": "string",
    "chunk_index": 8,
    "content": "doesn't: {!s}\".format('test1', 'test2') \"repr() shows quotes: 'test1'; str() doesn't: test2\" Aligning the text and specifying a width: >>> '{:<30}'.format('left aligned') 'left aligned ' >>> '{:>30}'.format('right aligned') ' right aligned' >>> '{:^30}'.format('centered') ' centered ' >>> '{:*^30}'.format('centered') # use '*' as a fill char '***********centered***********' Replacing %+f, %-f, and % f and specifying a sign: >>> '{:+f}; {:+f}'.format(3.14, -3.14) # show it always '+3.140000; -3.140000' >>> '{: f}; {: f}'.format(3.14, -3.14) # show a space for positive numbers ' 3.140000; -3.140000' >>> '{:-f}; {:-f}'.format(3.14, -3.14) # show only the minus -- same as '{:f}; {:f}' '3.140000; -3.140000' Replacing %x and %o and converting the value to different bases: >>> # format also supports binary numbers >>> \"int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}\".format(42) 'int: 42; hex: 2a; oct: 52; bin: 101010' >>> # with 0x, 0o, or 0b as prefix: >>> \"int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}\".format(42) 'int: 42; hex: 0x2a; oct: 0o52; bin: 0b101010' Using the comma or the underscore as a digit group separator: >>> '{:,}'.format(1234567890) '1,234,567,890' >>> '{:_}'.format(1234567890) '1_234_567_890' >>> '{:_b}'.format(1234567890) '100_1001_1001_0110_0000_0010_1101_0010' >>> '{:_x}'.format(1234567890) '4996_02d2' Expressing a percentage: >>> points = 19 >>> total = 22 >>> 'Correct answers: {:.2%}'.format(points/total) 'Correct answers: 86.36%' Using type-specific formatting: >>> import datetime >>> d = datetime.datetime(2010, 7, 4, 12, 15, 58) >>> '{:%Y-%m-%d %H:%M:%S}'.format(d) '2010-07-04 12:15:58' Nesting arguments and more complex examples: >>> for align, text in zip('<^>', ['left', 'center', 'right']): ... '{0:{fill}{align}16}'.format(text, fill=align, align=align) ... 'left<<<<<<<<<<<<' '^^^^^center^^^^^' '>>>>>>>>>>>right' >>> >>> octets = [192, 168, 0, 1] >>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets) 'C0A80001' >>> int(_, 16) 3232235521 >>> >>> width = 5 >>> for num in range(5,12): ... for base in 'dXob': ... print('{0:{width}{base}}'.format(num, base=base, width=width), end=' ') ... print() ... 5 5 5 101 6 6 6 110 7 7 7 111 8 8 10 1000 9 9 11 1001 10 A 12 1010 11 B 13 1011 Template stringsÂ¶ Template strings provide simpler string substitutions as described in PEP 292. A primary use case for template strings is for internationalization (i18n) since in that context, the simpler syntax and functionality makes it easier to translate than other built-in string formatting facilities in Python. As an example of a library built on template strings for i18n, see the flufl.i18n package. Template strings support $-based substitutions, using the following rules: $$ is an escape; it is replaced with a single $. $identifier names a substitution placeholder matching a mapping key of \"identifier\". By default, \"identifier\" is restricted to any case-insensitive ASCII alphanumeric string (including underscores) that starts with an underscore or ASCII letter. The first non-identifier character after the $ character terminates this placeholder specification. ${identifier} is equivalent to $identifier. It is required when valid identifier characters follow the placeholder but are not part of the placeholder, such as \"${noun}ification\". Any other appearance of $ in the string will result in a ValueError being raised. The string module provides a Template class that implements these rules. The methods of Template are: class string.Template(template)Â¶ The constructor takes a single argument which is",
    "content_length": 3560
  },
  {
    "id": "string_chunk_9",
    "source_file": "string",
    "chunk_index": 9,
    "content": "are not part of the placeholder, such as \"${noun}ification\". Any other appearance of $ in the string will result in a ValueError being raised. The string module provides a Template class that implements these rules. The methods of Template are: class string.Template(template)Â¶ The constructor takes a single argument which is the template string. substitute(mapping={}, /, **kwds)Â¶ Performs the template substitution, returning a new string. mapping is any dictionary-like object with keys that match the placeholders in the template. Alternatively, you can provide keyword arguments, where the keywords are the placeholders. When both mapping and kwds are given and there are duplicates, the placeholders from kwds take precedence. safe_substitute(mapping={}, /, **kwds)Â¶ Like substitute(), except that if placeholders are missing from mapping and kwds, instead of raising a KeyError exception, the original placeholder will appear in the resulting string intact. Also, unlike with substitute(), any other appearances of the $ will simply return $ instead of raising ValueError. While other exceptions may still occur, this method is called âsafeâ because it always tries to return a usable string instead of raising an exception. In another sense, safe_substitute() may be anything other than safe, since it will silently ignore malformed templates containing dangling delimiters, unmatched braces, or placeholders that are not valid Python identifiers. is_valid()Â¶ Returns False if the template has invalid placeholders that will cause substitute() to raise ValueError. Added in version 3.11. get_identifiers()Â¶ Returns a list of the valid identifiers in the template, in the order they first appear, ignoring any invalid identifiers. Added in version 3.11. Template instances also provide one public data attribute: templateÂ¶ This is the object passed to the constructorâs template argument. In general, you shouldnât change it, but read-only access is not enforced. Here is an example of how to use a Template: >>> from string import Template >>> s = Template('$who likes $what') >>> s.substitute(who='tim', what='kung pao') 'tim likes kung pao' >>> d = dict(who='tim') >>> Template('Give $who $100').substitute(d) Traceback (most recent call last): ... ValueError: Invalid placeholder in string: line 1, col 11 >>> Template('$who likes $what').substitute(d) Traceback (most recent call last): ... KeyError: 'what' >>> Template('$who likes $what').safe_substitute(d) 'tim likes $what' Advanced usage: you can derive subclasses of Template to customize the placeholder syntax, delimiter character, or the entire regular expression used to parse template strings. To do this, you can override these class attributes: delimiter â This is the literal string describing a placeholder introducing delimiter. The default value is $. Note that this should not be a regular expression, as the implementation will call re.escape() on this string as needed. Note further that you cannot change the delimiter after class creation (i.e. a different delimiter must be set in the subclassâs class namespace). idpattern â This is the regular expression describing the pattern for non-braced placeholders. The default value is the regular expression (?a:[_a-z][_a-z0-9]*). If this is given and braceidpattern is None this pattern will also apply to braced placeholders. Note Since default flags is re.IGNORECASE, pattern [a-z] can match with",
    "content_length": 3450
  },
  {
    "id": "string_chunk_10",
    "source_file": "string",
    "chunk_index": 10,
    "content": "class namespace). idpattern â This is the regular expression describing the pattern for non-braced placeholders. The default value is the regular expression (?a:[_a-z][_a-z0-9]*). If this is given and braceidpattern is None this pattern will also apply to braced placeholders. Note Since default flags is re.IGNORECASE, pattern [a-z] can match with some non-ASCII characters. Thatâs why we use the local a flag here. Changed in version 3.7: braceidpattern can be used to define separate patterns used inside and outside the braces. braceidpattern â This is like idpattern but describes the pattern for braced placeholders. Defaults to None which means to fall back to idpattern (i.e. the same pattern is used both inside and outside braces). If given, this allows you to define different patterns for braced and unbraced placeholders. Added in version 3.7. flags â The regular expression flags that will be applied when compiling the regular expression used for recognizing substitutions. The default value is re.IGNORECASE. Note that re.VERBOSE will always be added to the flags, so custom idpatterns must follow conventions for verbose regular expressions. Added in version 3.2. Alternatively, you can provide the entire regular expression pattern by overriding the class attribute pattern. If you do this, the value must be a regular expression object with four named capturing groups. The capturing groups correspond to the rules given above, along with the invalid placeholder rule: escaped â This group matches the escape sequence, e.g. $$, in the default pattern. named â This group matches the unbraced placeholder name; it should not include the delimiter in capturing group. braced â This group matches the brace enclosed placeholder name; it should not include either the delimiter or braces in the capturing group. invalid â This group matches any other delimiter pattern (usually a single delimiter), and it should appear last in the regular expression. The methods on this class will raise ValueError if the pattern matches the template without one of these named groups matching. Helper functionsÂ¶ string.capwords(s, sep=None)Â¶ Split the argument into words using str.split(), capitalize each word using str.capitalize(), and join the capitalized words using str.join(). If the optional second argument sep is absent or None, runs of whitespace characters are replaced by a single space and leading and trailing whitespace are removed, otherwise sep is used to split and join the words.",
    "content_length": 2519
  },
  {
    "id": "datastructures_chunk_0",
    "source_file": "datastructures",
    "chunk_index": 0,
    "content": "5. Data StructuresÂ¶ This chapter describes some things youâve learned about already in more detail, and adds some new things as well. 5.1. More on ListsÂ¶ The list data type has some more methods. Here are all of the methods of list objects: list.append(x) Add an item to the end of the list. Similar to a[len(a):] = [x]. list.extend(iterable) Extend the list by appending all the items from the iterable. Similar to a[len(a):] = iterable. list.insert(i, x) Insert an item at a given position. The first argument is the index of the element before which to insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to a.append(x). list.remove(x) Remove the first item from the list whose value is equal to x. It raises a ValueError if there is no such item. list.pop([i]) Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes and returns the last item in the list. It raises an IndexError if the list is empty or the index is outside the list range. list.clear() Remove all items from the list. Similar to del a[:]. list.index(x[, start[, end]]) Return zero-based index of the first occurrence of x in the list. Raises a ValueError if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. list.count(x) Return the number of times x appears in the list. list.sort(*, key=None, reverse=False) Sort the items of the list in place (the arguments can be used for sort customization, see sorted() for their explanation). list.reverse() Reverse the elements of the list in place. list.copy() Return a shallow copy of the list. Similar to a[:]. An example that uses most of the list methods: >>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] >>> fruits.count('apple') 2 >>> fruits.count('tangerine') 0 >>> fruits.index('banana') 3 >>> fruits.index('banana', 4) # Find next banana starting at position 4 6 >>> fruits.reverse() >>> fruits ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange'] >>> fruits.append('grape') >>> fruits ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape'] >>> fruits.sort() >>> fruits ['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear'] >>> fruits.pop() 'pear' You might have noticed that methods like insert, remove or sort that only modify the list have no return value printed â they return the default None. [1] This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, [None, 'hello', 10] doesnât sort because integers canât be compared to strings and None canât be compared to other types. Also, there are some types that donât have a defined ordering relation. For example, 3+4j < 5+7j isnât a valid comparison. 5.1.1. Using Lists as StacksÂ¶",
    "content_length": 3094
  },
  {
    "id": "datastructures_chunk_1",
    "source_file": "datastructures",
    "chunk_index": 1,
    "content": "or compared. For instance, [None, 'hello', 10] doesnât sort because integers canât be compared to strings and None canât be compared to other types. Also, there are some types that donât have a defined ordering relation. For example, 3+4j < 5+7j isnât a valid comparison. 5.1.1. Using Lists as StacksÂ¶ The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (âlast-in, first-outâ). To add an item to the top of the stack, use append(). To retrieve an item from the top of the stack, use pop() without an explicit index. For example: >>> stack = [3, 4, 5] >>> stack.append(6) >>> stack.append(7) >>> stack [3, 4, 5, 6, 7] >>> stack.pop() 7 >>> stack [3, 4, 5, 6] >>> stack.pop() 6 >>> stack.pop() 5 >>> stack [3, 4] 5.1.2. Using Lists as QueuesÂ¶ It is also possible to use a list as a queue, where the first element added is the first element retrieved (âfirst-in, first-outâ); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use collections.deque which was designed to have fast appends and pops from both ends. For example: >>> from collections import deque >>> queue = deque([\"Eric\", \"John\", \"Michael\"]) >>> queue.append(\"Terry\") # Terry arrives >>> queue.append(\"Graham\") # Graham arrives >>> queue.popleft() # The first to arrive now leaves 'Eric' >>> queue.popleft() # The second to arrive now leaves 'John' >>> queue # Remaining queue in order of arrival deque(['Michael', 'Terry', 'Graham']) 5.1.3. List ComprehensionsÂ¶ List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: >>> squares = [] >>> for x in range(10): ... squares.append(x**2) ... >>> squares [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] Note that this creates (or overwrites) a variable named x that still exists after the loop completes. We can calculate the list of squares without any side effects using: squares = list(map(lambda x: x**2, range(10))) or, equivalently: squares = [x**2 for x in range(10)] which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses. The result will be a new list resulting from evaluating the expression in the context of the for and if clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] [(1, 3),",
    "content_length": 2901
  },
  {
    "id": "datastructures_chunk_2",
    "source_file": "datastructures",
    "chunk_index": 2,
    "content": "list resulting from evaluating the expression in the context of the for and if clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] and itâs equivalent to: >>> combs = [] >>> for x in [1,2,3]: ... for y in [3,1,4]: ... if x != y: ... combs.append((x, y)) ... >>> combs [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] Note how the order of the for and if statements is the same in both these snippets. If the expression is a tuple (e.g. the (x, y) in the previous example), it must be parenthesized. >>> vec = [-4, -2, 0, 2, 4] >>> # create a new list with the values doubled >>> [x*2 for x in vec] [-8, -4, 0, 4, 8] >>> # filter the list to exclude negative numbers >>> [x for x in vec if x >= 0] [0, 2, 4] >>> # apply a function to all the elements >>> [abs(x) for x in vec] [4, 2, 0, 2, 4] >>> # call a method on each element >>> freshfruit = [' banana', ' loganberry ', 'passion fruit '] >>> [weapon.strip() for weapon in freshfruit] ['banana', 'loganberry', 'passion fruit'] >>> # create a list of 2-tuples like (number, square) >>> [(x, x**2) for x in range(6)] [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)] >>> # the tuple must be parenthesized, otherwise an error is raised >>> [x, x**2 for x in range(6)] File \"<stdin>\", line 1 [x, x**2 for x in range(6)] ^^^^^^^ SyntaxError: did you forget parentheses around the comprehension target? >>> # flatten a list using a listcomp with two 'for' >>> vec = [[1,2,3], [4,5,6], [7,8,9]] >>> [num for elem in vec for num in elem] [1, 2, 3, 4, 5, 6, 7, 8, 9] List comprehensions can contain complex expressions and nested functions: >>> from math import pi >>> [str(round(pi, i)) for i in range(1, 6)] ['3.1', '3.14', '3.142', '3.1416', '3.14159'] 5.1.4. Nested List ComprehensionsÂ¶ The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... ] The following list comprehension will transpose rows and columns: >>> [[row[i] for row in matrix] for i in range(4)] [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] As we saw in the previous section, the inner list comprehension is evaluated in the context of the for that follows it, so this example is equivalent to: >>> transposed = [] >>> for i in range(4): ... transposed.append([row[i]",
    "content_length": 2598
  },
  {
    "id": "datastructures_chunk_3",
    "source_file": "datastructures",
    "chunk_index": 3,
    "content": "5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] As we saw in the previous section, the inner list comprehension is evaluated in the context of the for that follows it, so this example is equivalent to: >>> transposed = [] >>> for i in range(4): ... transposed.append([row[i] for row in matrix]) ... >>> transposed [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] which, in turn, is the same as: >>> transposed = [] >>> for i in range(4): ... # the following 3 lines implement the nested listcomp ... transposed_row = [] ... for row in matrix: ... transposed_row.append(row[i]) ... transposed.append(transposed_row) ... >>> transposed [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] In the real world, you should prefer built-in functions to complex flow statements. The zip() function would do a great job for this use case: >>> list(zip(*matrix)) [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)] See Unpacking Argument Lists for details on the asterisk in this line. 5.2. The del statementÂ¶ There is a way to remove an item from a list given its index instead of its value: the del statement. This differs from the pop() method which returns a value. The del statement can also be used to remove slices from a list or clear the entire list (which we did earlier by assignment of an empty list to the slice). For example: >>> a = [-1, 1, 66.25, 333, 333, 1234.5] >>> del a[0] >>> a [1, 66.25, 333, 333, 1234.5] >>> del a[2:4] >>> a [1, 66.25, 1234.5] >>> del a[:] >>> a [] del can also be used to delete entire variables: >>> del a Referencing the name a hereafter is an error (at least until another value is assigned to it). Weâll find other uses for del later. 5.3. Tuples and SequencesÂ¶ We saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types â list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: >>> t = 12345, 54321, 'hello!' >>> t[0] 12345 >>> t (12345, 54321, 'hello!') >>> # Tuples may be nested: >>> u = t, (1, 2, 3, 4, 5) >>> u ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5)) >>> # Tuples are immutable: >>> t[0] = 88888 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> # but they can contain mutable objects: >>> v = ([1, 2, 3], [3, 2, 1]) >>> v ([1, 2, 3], [3, 2, 1]) As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding",
    "content_length": 2712
  },
  {
    "id": "datastructures_chunk_4",
    "source_file": "datastructures",
    "chunk_index": 4,
    "content": "# but they can contain mutable objects: >>> v = ([1, 2, 3], [3, 2, 1]) >>> v ([1, 2, 3], [3, 2, 1]) As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of namedtuples). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: >>> empty = () >>> singleton = 'hello', # <-- note trailing comma >>> len(empty) 0 >>> len(singleton) 1 >>> singleton ('hello',) The statement t = 12345, 54321, 'hello!' is an example of tuple packing: the values 12345, 54321 and 'hello!' are packed together in a tuple. The reverse operation is also possible: >>> x, y, z = t This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking. 5.4. SetsÂ¶ Python also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the set() function can be used to create sets. Note: to create an empty set you have to use set(), not {}; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: >>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} >>> print(basket) # show that duplicates have been removed {'orange', 'banana', 'pear', 'apple'} >>> 'orange' in basket # fast membership testing True >>> 'crabgrass' in basket False >>> # Demonstrate set operations on unique letters from two words >>> >>> a = set('abracadabra') >>> b = set('alacazam') >>> a # unique letters in a {'a', 'r', 'b', 'c', 'd'} >>> a - b # letters in a",
    "content_length": 2974
  },
  {
    "id": "datastructures_chunk_5",
    "source_file": "datastructures",
    "chunk_index": 5,
    "content": "# fast membership testing True >>> 'crabgrass' in basket False >>> # Demonstrate set operations on unique letters from two words >>> >>> a = set('abracadabra') >>> b = set('alacazam') >>> a # unique letters in a {'a', 'r', 'b', 'c', 'd'} >>> a - b # letters in a but not in b {'r', 'd', 'b'} >>> a | b # letters in a or b or both {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'} >>> a & b # letters in both a and b {'a', 'c'} >>> a ^ b # letters in a or b but not both {'r', 'd', 'b', 'm', 'z', 'l'} Similarly to list comprehensions, set comprehensions are also supported: >>> a = {x for x in 'abracadabra' if x not in 'abc'} >>> a {'r', 'd'} 5.5. DictionariesÂ¶ Another useful data type built into Python is the dictionary (see Mapping Types â dict). Dictionaries are sometimes found in other languages as âassociative memoriesâ or âassociative arraysâ. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You canât use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like append() and extend(). It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: {}. Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with del. If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing list(d) on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use sorted(d) instead). To check whether a single key is in the dictionary, use the in keyword. Here is a small example using a dictionary: >>> tel = {'jack': 4098, 'sape': 4139} >>> tel['guido'] = 4127 >>> tel {'jack': 4098, 'sape': 4139, 'guido': 4127} >>> tel['jack'] 4098 >>> del tel['sape'] >>> tel['irv'] = 4127 >>> tel {'jack': 4098, 'guido': 4127, 'irv': 4127} >>> list(tel) ['jack', 'guido', 'irv'] >>> sorted(tel) ['guido', 'irv', 'jack'] >>> 'guido' in tel True >>> 'jack' not in tel False The dict() constructor builds dictionaries directly from sequences of key-value pairs: >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])",
    "content_length": 2823
  },
  {
    "id": "datastructures_chunk_6",
    "source_file": "datastructures",
    "chunk_index": 6,
    "content": "tel['irv'] = 4127 >>> tel {'jack': 4098, 'guido': 4127, 'irv': 4127} >>> list(tel) ['jack', 'guido', 'irv'] >>> sorted(tel) ['guido', 'irv', 'jack'] >>> 'guido' in tel True >>> 'jack' not in tel False The dict() constructor builds dictionaries directly from sequences of key-value pairs: >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)]) {'sape': 4139, 'guido': 4127, 'jack': 4098} In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: >>> {x: x**2 for x in (2, 4, 6)} {2: 4, 4: 16, 6: 36} When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments: >>> dict(sape=4139, guido=4127, jack=4098) {'sape': 4139, 'guido': 4127, 'jack': 4098} 5.6. Looping TechniquesÂ¶ When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the items() method. >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'} >>> for k, v in knights.items(): ... print(k, v) ... gallahad the pure robin the brave When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the enumerate() function. >>> for i, v in enumerate(['tic', 'tac', 'toe']): ... print(i, v) ... 0 tic 1 tac 2 toe To loop over two or more sequences at the same time, the entries can be paired with the zip() function. >>> questions = ['name', 'quest', 'favorite color'] >>> answers = ['lancelot', 'the holy grail', 'blue'] >>> for q, a in zip(questions, answers): ... print('What is your {0}? It is {1}.'.format(q, a)) ... What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the reversed() function. >>> for i in reversed(range(1, 10, 2)): ... print(i) ... 9 7 5 3 1 To loop over a sequence in sorted order, use the sorted() function which returns a new sorted list while leaving the source unaltered. >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana'] >>> for i in sorted(basket): ... print(i) ... apple apple banana orange orange pear Using set() on a sequence eliminates duplicate elements. The use of sorted() in combination with set() over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana'] >>> for f in sorted(set(basket)): ... print(f) ... apple banana orange pear It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead. >>> import math >>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8] >>> filtered_data = [] >>> for value in raw_data: ... if not math.isnan(value): ... filtered_data.append(value) ... >>> filtered_data [56.2, 51.7, 55.3, 52.5, 47.8] 5.7. More on ConditionsÂ¶ The conditions used in while and if statements can contain any operators, not just comparisons. The comparison operators in",
    "content_length": 3074
  },
  {
    "id": "datastructures_chunk_7",
    "source_file": "datastructures",
    "chunk_index": 7,
    "content": "55.3, 52.5, float('NaN'), 47.8] >>> filtered_data = [] >>> for value in raw_data: ... if not math.isnan(value): ... filtered_data.append(value) ... >>> filtered_data [56.2, 51.7, 55.3, 52.5, 47.8] 5.7. More on ConditionsÂ¶ The conditions used in while and if statements can contain any operators, not just comparisons. The comparison operators in and not in are membership tests that determine whether a value is in (or not in) a container. The operators is and is not compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, a < b == c tests whether a is less than b and moreover b equals c. Comparisons may be combined using the Boolean operators and and or, and the outcome of a comparison (or of any other Boolean expression) may be negated with not. These have lower priorities than comparison operators; between them, not has the highest priority and or the lowest, so that A and not B or C is equivalent to (A and (not B)) or C. As always, parentheses can be used to express the desired composition. The Boolean operators and and or are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if A and C are true but B is false, A and B and C does not evaluate the expression C. When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance' >>> non_null = string1 or string2 or string3 >>> non_null 'Trondheim' Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator :=. This avoids a common class of problems encountered in C programs: typing = in an expression when == was intended. 5.8. Comparing Sequences and Other TypesÂ¶ Sequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: (1, 2, 3) < (1, 2, 4) [1, 2, 3] < [1, 2, 4] 'ABC' < 'C'",
    "content_length": 2952
  },
  {
    "id": "datastructures_chunk_8",
    "source_file": "datastructures",
    "chunk_index": 8,
    "content": "other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: (1, 2, 3) < (1, 2, 4) [1, 2, 3] < [1, 2, 4] 'ABC' < 'C' < 'Pascal' < 'Python' (1, 2, 3, 4) < (1, 2, 4) (1, 2) < (1, 2, -1) (1, 2, 3) == (1.0, 2.0, 3.0) (1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4) Note that comparing objects of different types with < or > is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a TypeError exception. Footnotes [1] Other languages may return the mutated object, which allows method chaining, such as d->insert(\"a\")->remove(\"b\")->sort();.",
    "content_length": 900
  },
  {
    "id": "controlflow_chunk_0",
    "source_file": "controlflow",
    "chunk_index": 0,
    "content": "4. More Control Flow ToolsÂ¶ As well as the while statement just introduced, Python uses a few more that we will encounter in this chapter. 4.1. if StatementsÂ¶ Perhaps the most well-known statement type is the if statement. For example: >>> x = int(input(\"Please enter an integer: \")) Please enter an integer: 42 >>> if x < 0: ... x = 0 ... print('Negative changed to zero') ... elif x == 0: ... print('Zero') ... elif x == 1: ... print('Single') ... else: ... print('More') ... More There can be zero or more elif parts, and the else part is optional. The keyword âelifâ is short for âelse ifâ, and is useful to avoid excessive indentation. An if â¦ elif â¦ elif â¦ sequence is a substitute for the switch or case statements found in other languages. If youâre comparing the same value to several constants, or checking for specific types or attributes, you may also find the match statement useful. For more details see match Statements. 4.2. for StatementsÂ¶ The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration step and halting condition (as C), Pythonâs for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended): >>> # Measure some strings: >>> words = ['cat', 'window', 'defenestrate'] >>> for w in words: ... print(w, len(w)) ... cat 3 window 6 defenestrate 12 Code that modifies a collection while iterating over that same collection can be tricky to get right. Instead, it is usually more straight-forward to loop over a copy of the collection or to create a new collection: # Create a sample collection users = {'Hans': 'active', 'ÃlÃ©onore': 'inactive', 'æ¯å¤ªé': 'active'} # Strategy: Iterate over a copy for user, status in users.copy().items(): if status == 'inactive': del users[user] # Strategy: Create a new collection active_users = {} for user, status in users.items(): if status == 'active': active_users[user] = status 4.3. The range() FunctionÂ¶ If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions: >>> for i in range(5): ... print(i) ... 0 1 2 3 4 The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a different increment (even negative; sometimes this is called the âstepâ): >>> list(range(5, 10)) [5, 6, 7, 8, 9] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(-10, -100, -30)) [-10, -40, -70] To iterate over the indices of a sequence, you can combine range() and len() as follows: >>> a = ['Mary', 'had', 'a', 'little', 'lamb'] >>>",
    "content_length": 2918
  },
  {
    "id": "controlflow_chunk_1",
    "source_file": "controlflow",
    "chunk_index": 1,
    "content": "the âstepâ): >>> list(range(5, 10)) [5, 6, 7, 8, 9] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(-10, -100, -30)) [-10, -40, -70] To iterate over the indices of a sequence, you can combine range() and len() as follows: >>> a = ['Mary', 'had', 'a', 'little', 'lamb'] >>> for i in range(len(a)): ... print(i, a[i]) ... 0 Mary 1 had 2 a 3 little 4 lamb In most such cases, however, it is convenient to use the enumerate() function, see Looping Techniques. A strange thing happens if you just print a range: >>> range(10) range(0, 10) In many ways the object returned by range() behaves as if it is a list, but in fact it isnât. It is an object which returns the successive items of the desired sequence when you iterate over it, but it doesnât really make the list, thus saving space. We say such an object is iterable, that is, suitable as a target for functions and constructs that expect something from which they can obtain successive items until the supply is exhausted. We have seen that the for statement is such a construct, while an example of a function that takes an iterable is sum(): >>> sum(range(4)) # 0 + 1 + 2 + 3 6 Later we will see more functions that return iterables and take iterables as arguments. In chapter Data Structures, we will discuss in more detail about list(). 4.4. break and continue StatementsÂ¶ The break statement breaks out of the innermost enclosing for or while loop: >>> for n in range(2, 10): ... for x in range(2, n): ... if n % x == 0: ... print(f\"{n} equals {x} * {n//x}\") ... break ... 4 equals 2 * 2 6 equals 2 * 3 8 equals 2 * 4 9 equals 3 * 3 The continue statement continues with the next iteration of the loop: >>> for num in range(2, 10): ... if num % 2 == 0: ... print(f\"Found an even number {num}\") ... continue ... print(f\"Found an odd number {num}\") ... Found an even number 2 Found an odd number 3 Found an even number 4 Found an odd number 5 Found an even number 6 Found an odd number 7 Found an even number 8 Found an odd number 9 4.5. else Clauses on LoopsÂ¶ In a for or while loop the break statement may be paired with an else clause. If the loop finishes without executing the break, the else clause executes. In a for loop, the else clause is executed after the loop finishes its final iteration, that is, if no break occurred. In a while loop, itâs executed after the loopâs condition becomes false. In either kind of loop, the else clause is not executed if the loop was terminated by a break. Of course, other ways of ending the loop early, such as a return or a raised exception, will also skip execution of the else clause. This is exemplified in the following",
    "content_length": 2647
  },
  {
    "id": "controlflow_chunk_2",
    "source_file": "controlflow",
    "chunk_index": 2,
    "content": "In either kind of loop, the else clause is not executed if the loop was terminated by a break. Of course, other ways of ending the loop early, such as a return or a raised exception, will also skip execution of the else clause. This is exemplified in the following for loop, which searches for prime numbers: >>> for n in range(2, 10): ... for x in range(2, n): ... if n % x == 0: ... print(n, 'equals', x, '*', n//x) ... break ... else: ... # loop fell through without finding a factor ... print(n, 'is a prime number') ... 2 is a prime number 3 is a prime number 4 equals 2 * 2 5 is a prime number 6 equals 2 * 3 7 is a prime number 8 equals 2 * 4 9 equals 3 * 3 (Yes, this is the correct code. Look closely: the else clause belongs to the for loop, not the if statement.) One way to think of the else clause is to imagine it paired with the if inside the loop. As the loop executes, it will run a sequence like if/if/if/else. The if is inside the loop, encountered a number of times. If the condition is ever true, a break will happen. If the condition is never true, the else clause outside the loop will execute. When used with a loop, the else clause has more in common with the else clause of a try statement than it does with that of if statements: a try statementâs else clause runs when no exception occurs, and a loopâs else clause runs when no break occurs. For more on the try statement and exceptions, see Handling Exceptions. 4.6. pass StatementsÂ¶ The pass statement does nothing. It can be used when a statement is required syntactically but the program requires no action. For example: >>> while True: ... pass # Busy-wait for keyboard interrupt (Ctrl+C) ... This is commonly used for creating minimal classes: >>> class MyEmptyClass: ... pass ... Another place pass can be used is as a place-holder for a function or conditional body when you are working on new code, allowing you to keep thinking at a more abstract level. The pass is silently ignored: >>> def initlog(*args): ... pass # Remember to implement this! ... For this last case, many people use the ellipsis literal ... instead of pass. This use has no special meaning to Python, and is not part of the language definition (you could use any constant expression here), but ... is used conventionally as a placeholder body as well. See The Ellipsis Object. 4.7. match StatementsÂ¶ A match statement takes an expression and compares its value to successive patterns given as one or more case blocks. This is superficially similar to a switch statement in C, Java or JavaScript (and many other languages), but itâs more similar to pattern matching in languages like Rust or Haskell. Only the first pattern that matches gets executed",
    "content_length": 2716
  },
  {
    "id": "controlflow_chunk_3",
    "source_file": "controlflow",
    "chunk_index": 3,
    "content": "its value to successive patterns given as one or more case blocks. This is superficially similar to a switch statement in C, Java or JavaScript (and many other languages), but itâs more similar to pattern matching in languages like Rust or Haskell. Only the first pattern that matches gets executed and it can also extract components (sequence elements or object attributes) from the value into variables. The simplest form compares a subject value against one or more literals: def http_error(status): match status: case 400: return \"Bad request\" case 404: return \"Not found\" case 418: return \"I'm a teapot\" case _: return \"Something's wrong with the internet\" Note the last block: the âvariable nameâ _ acts as a wildcard and never fails to match. If no case matches, none of the branches is executed. You can combine several literals in a single pattern using | (âorâ): case 401 | 403 | 404: return \"Not allowed\" Patterns can look like unpacking assignments, and can be used to bind variables: # point is an (x, y) tuple match point: case (0, 0): print(\"Origin\") case (0, y): print(f\"Y={y}\") case (x, 0): print(f\"X={x}\") case (x, y): print(f\"X={x}, Y={y}\") case _: raise ValueError(\"Not a point\") Study that one carefully! The first pattern has two literals, and can be thought of as an extension of the literal pattern shown above. But the next two patterns combine a literal and a variable, and the variable binds a value from the subject (point). The fourth pattern captures two values, which makes it conceptually similar to the unpacking assignment (x, y) = point. If you are using classes to structure your data you can use the class name followed by an argument list resembling a constructor, but with the ability to capture attributes into variables: class Point: def __init__(self, x, y): self.x = x self.y = y def where_is(point): match point: case Point(x=0, y=0): print(\"Origin\") case Point(x=0, y=y): print(f\"Y={y}\") case Point(x=x, y=0): print(f\"X={x}\") case Point(): print(\"Somewhere else\") case _: print(\"Not a point\") You can use positional parameters with some builtin classes that provide an ordering for their attributes (e.g. dataclasses). You can also define a specific position for attributes in patterns by setting the __match_args__ special attribute in your classes. If itâs set to (âxâ, âyâ), the following patterns are all equivalent (and all bind the y attribute to the var variable): Point(1, var) Point(1, y=var) Point(x=1, y=var) Point(y=var, x=1) A recommended way to read patterns is to look at them as an extended form of what you would put on the left of an assignment, to understand which variables would be set to what. Only the standalone names (like var above) are assigned to by a match statement. Dotted names (like foo.bar), attribute names (the x= and y= above) or class names (recognized by the â(â¦)â next to them like Point above) are never assigned to. Patterns can be arbitrarily nested. For example, if we have a short list of Points, with __match_args__ added, we could match it like",
    "content_length": 3062
  },
  {
    "id": "controlflow_chunk_4",
    "source_file": "controlflow",
    "chunk_index": 4,
    "content": "names (like foo.bar), attribute names (the x= and y= above) or class names (recognized by the â(â¦)â next to them like Point above) are never assigned to. Patterns can be arbitrarily nested. For example, if we have a short list of Points, with __match_args__ added, we could match it like this: class Point: __match_args__ = ('x', 'y') def __init__(self, x, y): self.x = x self.y = y match points: case []: print(\"No points\") case [Point(0, 0)]: print(\"The origin\") case [Point(x, y)]: print(f\"Single point {x}, {y}\") case [Point(0, y1), Point(0, y2)]: print(f\"Two on the Y axis at {y1}, {y2}\") case _: print(\"Something else\") We can add an if clause to a pattern, known as a âguardâ. If the guard is false, match goes on to try the next case block. Note that value capture happens before the guard is evaluated: match point: case Point(x, y) if x == y: print(f\"Y=X at {x}\") case Point(x, y): print(f\"Not on the diagonal\") Several other key features of this statement: Like unpacking assignments, tuple and list patterns have exactly the same meaning and actually match arbitrary sequences. An important exception is that they donât match iterators or strings. Sequence patterns support extended unpacking: [x, y, *rest] and (x, y, *rest) work similar to unpacking assignments. The name after * may also be _, so (x, y, *_) matches a sequence of at least two items without binding the remaining items. Mapping patterns: {\"bandwidth\": b, \"latency\": l} captures the \"bandwidth\" and \"latency\" values from a dictionary. Unlike sequence patterns, extra keys are ignored. An unpacking like **rest is also supported. (But **_ would be redundant, so it is not allowed.) Subpatterns may be captured using the as keyword: case (Point(x1, y1), Point(x2, y2) as p2): ... will capture the second element of the input as p2 (as long as the input is a sequence of two points) Most literals are compared by equality, however the singletons True, False and None are compared by identity. Patterns may use named constants. These must be dotted names to prevent them from being interpreted as capture variable: from enum import Enum class Color(Enum): RED = 'red' GREEN = 'green' BLUE = 'blue' color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \")) match color: case Color.RED: print(\"I see red!\") case Color.GREEN: print(\"Grass is green\") case Color.BLUE: print(\"I'm feeling the blues :(\") For a more detailed explanation and additional examples, you can look into PEP 636 which is written in a tutorial format. 4.8. Defining FunctionsÂ¶ We can create a function that writes the Fibonacci series to an arbitrary boundary: >>> def fib(n): # write Fibonacci series less than n ... \"\"\"Print a Fibonacci series less than n.\"\"\" ... a, b = 0, 1 ... while a < n: ... print(a, end=' ') ... a, b = b, a+b ... print() ... >>> # Now call the function we just defined: >>> fib(2000) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987",
    "content_length": 2929
  },
  {
    "id": "controlflow_chunk_5",
    "source_file": "controlflow",
    "chunk_index": 5,
    "content": "b = 0, 1 ... while a < n: ... print(a, end=' ') ... a, b = b, a+b ... print() ... >>> # Now call the function we just defined: >>> fib(2000) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 The keyword def introduces a function definition. It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented. The first statement of the function body can optionally be a string literal; this string literal is the functionâs documentation string, or docstring. (More about docstrings can be found in the section Documentation Strings.) There are tools which use docstrings to automatically produce online or printed documentation, or to let the user interactively browse through code; itâs good practice to include docstrings in code that you write, so make a habit of it. The execution of a function introduces a new symbol table used for the local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in the global symbol table, and finally in the table of built-in names. Thus, global variables and variables of enclosing functions cannot be directly assigned a value within a function (unless, for global variables, named in a global statement, or, for variables of enclosing functions, named in a nonlocal statement), although they may be referenced. The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference, not the value of the object). [1] When a function calls another function, or calls itself recursively, a new local symbol table is created for that call. A function definition associates the function name with the function object in the current symbol table. The interpreter recognizes the object pointed to by that name as a user-defined function. Other names can also point to that same function object and can also be used to access the function: >>> fib <function fib at 10042ed0> >>> f = fib >>> f(100) 0 1 1 2 3 5 8 13 21 34 55 89 Coming from other languages, you might object that fib is not a function but a procedure since it doesnât return a value. In fact, even functions without a return statement do return a value, albeit a rather boring one. This value is called None (itâs a built-in name). Writing the value None is normally suppressed by the interpreter if it would be the only value written. You can see it if you really want to using print(): >>> fib(0) >>> print(fib(0)) None It is simple to write a",
    "content_length": 2835
  },
  {
    "id": "controlflow_chunk_6",
    "source_file": "controlflow",
    "chunk_index": 6,
    "content": "one. This value is called None (itâs a built-in name). Writing the value None is normally suppressed by the interpreter if it would be the only value written. You can see it if you really want to using print(): >>> fib(0) >>> print(fib(0)) None It is simple to write a function that returns a list of the numbers of the Fibonacci series, instead of printing it: >>> def fib2(n): # return Fibonacci series up to n ... \"\"\"Return a list containing the Fibonacci series up to n.\"\"\" ... result = [] ... a, b = 0, 1 ... while a < n: ... result.append(a) # see below ... a, b = b, a+b ... return result ... >>> f100 = fib2(100) # call it >>> f100 # write the result [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] This example, as usual, demonstrates some new Python features: The return statement returns with a value from a function. return without an expression argument returns None. Falling off the end of a function also returns None. The statement result.append(a) calls a method of the list object result. A method is a function that âbelongsâ to an object and is named obj.methodname, where obj is some object (this may be an expression), and methodname is the name of a method that is defined by the objectâs type. Different types define different methods. Methods of different types may have the same name without causing ambiguity. (It is possible to define your own object types and methods, using classes, see Classes) The method append() shown in the example is defined for list objects; it adds a new element at the end of the list. In this example it is equivalent to result = result + [a], but more efficient. 4.9. More on Defining FunctionsÂ¶ It is also possible to define functions with a variable number of arguments. There are three forms, which can be combined. 4.9.1. Default Argument ValuesÂ¶ The most useful form is to specify a default value for one or more arguments. This creates a function that can be called with fewer arguments than it is defined to allow. For example: def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: reply = input(prompt) if reply in {'y', 'ye', 'yes'}: return True if reply in {'n', 'no', 'nop', 'nope'}: return False retries = retries - 1 if retries < 0: raise ValueError('invalid user response') print(reminder) This function can be called in several ways: giving only the mandatory argument: ask_ok('Do you really want to quit?') giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2) or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!') This example also introduces the in keyword. This tests whether or not a sequence contains a certain value. The default values are evaluated at the point of function definition in the defining scope, so that i = 5 def f(arg=i): print(arg) i = 6 f() will print 5.",
    "content_length": 2840
  },
  {
    "id": "controlflow_chunk_7",
    "source_file": "controlflow",
    "chunk_index": 7,
    "content": "or no!') This example also introduces the in keyword. This tests whether or not a sequence contains a certain value. The default values are evaluated at the point of function definition in the defining scope, so that i = 5 def f(arg=i): print(arg) i = 6 f() will print 5. Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls: def f(a, L=[]): L.append(a) return L print(f(1)) print(f(2)) print(f(3)) This will print [1] [1, 2] [1, 2, 3] If you donât want the default to be shared between subsequent calls, you can write the function like this instead: def f(a, L=None): if L is None: L = [] L.append(a) return L 4.9.2. Keyword ArgumentsÂ¶ Functions can also be called using keyword arguments of the form kwarg=value. For instance, the following function: def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'): print(\"-- This parrot wouldn't\", action, end=' ') print(\"if you put\", voltage, \"volts through it.\") print(\"-- Lovely plumage, the\", type) print(\"-- It's\", state, \"!\") accepts one required argument (voltage) and three optional arguments (state, action, and type). This function can be called in any of the following ways: parrot(1000) # 1 positional argument parrot(voltage=1000) # 1 keyword argument parrot(voltage=1000000, action='VOOOOOM') # 2 keyword arguments parrot(action='VOOOOOM', voltage=1000000) # 2 keyword arguments parrot('a million', 'bereft of life', 'jump') # 3 positional arguments parrot('a thousand', state='pushing up the daisies') # 1 positional, 1 keyword but all the following calls would be invalid: parrot() # required argument missing parrot(voltage=5.0, 'dead') # non-keyword argument after a keyword argument parrot(110, voltage=220) # duplicate value for the same argument parrot(actor='John Cleese') # unknown keyword argument In a function call, keyword arguments must follow positional arguments. All the keyword arguments passed must match one of the arguments accepted by the function (e.g. actor is not a valid argument for the parrot function), and their order is not important. This also includes non-optional arguments (e.g. parrot(voltage=1000) is valid too). No argument may receive a value more than once. Hereâs an example that fails due to this restriction: >>> def function(a): ... pass ... >>> function(0, a=0) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: function() got multiple values for argument 'a' When a final formal parameter of the form **name is present, it receives a dictionary (see Mapping Types â dict) containing all keyword arguments except for those corresponding to a formal parameter. This may be combined with a formal parameter of the form *name (described in the next subsection) which receives a tuple containing the positional arguments beyond the formal parameter list. (*name must occur before **name.) For example, if we define a function like this: def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40)",
    "content_length": 3296
  },
  {
    "id": "controlflow_chunk_8",
    "source_file": "controlflow",
    "chunk_index": 8,
    "content": "containing the positional arguments beyond the formal parameter list. (*name must occur before **name.) For example, if we define a function like this: def cheeseshop(kind, *arguments, **keywords): print(\"-- Do you have any\", kind, \"?\") print(\"-- I'm sorry, we're all out of\", kind) for arg in arguments: print(arg) print(\"-\" * 40) for kw in keywords: print(kw, \":\", keywords[kw]) It could be called like this: cheeseshop(\"Limburger\", \"It's very runny, sir.\", \"It's really very, VERY runny, sir.\", shopkeeper=\"Michael Palin\", client=\"John Cleese\", sketch=\"Cheese Shop Sketch\") and of course it would print: -- Do you have any Limburger ? -- I'm sorry, we're all out of Limburger It's very runny, sir. It's really very, VERY runny, sir. ---------------------------------------- shopkeeper : Michael Palin client : John Cleese sketch : Cheese Shop Sketch Note that the order in which the keyword arguments are printed is guaranteed to match the order in which they were provided in the function call. 4.9.3. Special parametersÂ¶ By default, arguments may be passed to a Python function either by position or explicitly by keyword. For readability and performance, it makes sense to restrict the way arguments can be passed so that a developer need only look at the function definition to determine if items are passed by position, by position or keyword, or by keyword. A function definition may look like: def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | | Positional or keyword | | - Keyword only -- Positional only where / and * are optional. If used, these symbols indicate the kind of parameter by how the arguments may be passed to the function: positional-only, positional-or-keyword, and keyword-only. Keyword parameters are also referred to as named parameters. 4.9.3.1. Positional-or-Keyword ArgumentsÂ¶ If / and * are not present in the function definition, arguments may be passed to a function by position or by keyword. 4.9.3.2. Positional-Only ParametersÂ¶ Looking at this in a bit more detail, it is possible to mark certain parameters as positional-only. If positional-only, the parametersâ order matters, and the parameters cannot be passed by keyword. Positional-only parameters are placed before a / (forward-slash). The / is used to logically separate the positional-only parameters from the rest of the parameters. If there is no / in the function definition, there are no positional-only parameters. Parameters following the / may be positional-or-keyword or keyword-only. 4.9.3.3. Keyword-Only ArgumentsÂ¶ To mark parameters as keyword-only, indicating the parameters must be passed by keyword argument, place an * in the arguments list just before the first keyword-only parameter. 4.9.3.4. Function ExamplesÂ¶ Consider the following example function definitions paying close attention to the markers / and *: >>> def standard_arg(arg): ... print(arg) ... >>> def pos_only_arg(arg, /): ... print(arg) ... >>> def kwd_only_arg(*, arg): ... print(arg) ... >>> def combined_example(pos_only, /, standard, *, kwd_only): ... print(pos_only, standard, kwd_only) The first function definition, standard_arg, the most familiar form, places no restrictions on the calling convention and arguments may be passed by position or keyword: >>> standard_arg(2) 2 >>> standard_arg(arg=2) 2",
    "content_length": 3338
  },
  {
    "id": "controlflow_chunk_9",
    "source_file": "controlflow",
    "chunk_index": 9,
    "content": "... >>> def kwd_only_arg(*, arg): ... print(arg) ... >>> def combined_example(pos_only, /, standard, *, kwd_only): ... print(pos_only, standard, kwd_only) The first function definition, standard_arg, the most familiar form, places no restrictions on the calling convention and arguments may be passed by position or keyword: >>> standard_arg(2) 2 >>> standard_arg(arg=2) 2 The second function pos_only_arg is restricted to only use positional parameters as there is a / in the function definition: >>> pos_only_arg(1) 1 >>> pos_only_arg(arg=1) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg' The third function kwd_only_arg only allows keyword arguments as indicated by a * in the function definition: >>> kwd_only_arg(3) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given >>> kwd_only_arg(arg=3) 3 And the last uses all three calling conventions in the same function definition: >>> combined_example(1, 2, 3) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: combined_example() takes 2 positional arguments but 3 were given >>> combined_example(1, 2, kwd_only=3) 1 2 3 >>> combined_example(1, standard=2, kwd_only=3) 1 2 3 >>> combined_example(pos_only=1, standard=2, kwd_only=3) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only' Finally, consider this function definition which has a potential collision between the positional argument name and **kwds which has name as a key: def foo(name, **kwds): return 'name' in kwds There is no possible call that will make it return True as the keyword 'name' will always bind to the first parameter. For example: >>> foo(1, **{'name': 2}) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: foo() got multiple values for argument 'name' >>> But using / (positional only arguments), it is possible since it allows name as a positional argument and 'name' as a key in the keyword arguments: >>> def foo(name, /, **kwds): ... return 'name' in kwds ... >>> foo(1, **{'name': 2}) True In other words, the names of positional-only parameters can be used in **kwds without ambiguity. 4.9.3.5. RecapÂ¶ The use case will determine which parameters to use in the function definition: def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): As guidance: Use positional-only if you want the name of the parameters to not be available to the user. This is useful when parameter names have no real meaning, if you want to enforce the order of the arguments when the function is called or if you need to take some positional parameters and arbitrary keywords. Use keyword-only when names have meaning and the function definition is more understandable by being explicit with names or you want to prevent users relying on the position of the argument being passed. For an API, use positional-only to prevent breaking API changes if the parameterâs name is modified in the future. 4.9.4. Arbitrary Argument ListsÂ¶ Finally, the least frequently used option is to specify that a function",
    "content_length": 3305
  },
  {
    "id": "controlflow_chunk_10",
    "source_file": "controlflow",
    "chunk_index": 10,
    "content": "or you want to prevent users relying on the position of the argument being passed. For an API, use positional-only to prevent breaking API changes if the parameterâs name is modified in the future. 4.9.4. Arbitrary Argument ListsÂ¶ Finally, the least frequently used option is to specify that a function can be called with an arbitrary number of arguments. These arguments will be wrapped up in a tuple (see Tuples and Sequences). Before the variable number of arguments, zero or more normal arguments may occur. def write_multiple_items(file, separator, *args): file.write(separator.join(args)) Normally, these variadic arguments will be last in the list of formal parameters, because they scoop up all remaining input arguments that are passed to the function. Any formal parameters which occur after the *args parameter are âkeyword-onlyâ arguments, meaning that they can only be used as keywords rather than positional arguments. >>> def concat(*args, sep=\"/\"): ... return sep.join(args) ... >>> concat(\"earth\", \"mars\", \"venus\") 'earth/mars/venus' >>> concat(\"earth\", \"mars\", \"venus\", sep=\".\") 'earth.mars.venus' 4.9.5. Unpacking Argument ListsÂ¶ The reverse situation occurs when the arguments are already in a list or tuple but need to be unpacked for a function call requiring separate positional arguments. For instance, the built-in range() function expects separate start and stop arguments. If they are not available separately, write the function call with the *-operator to unpack the arguments out of a list or tuple: >>> list(range(3, 6)) # normal call with separate arguments [3, 4, 5] >>> args = [3, 6] >>> list(range(*args)) # call with arguments unpacked from a list [3, 4, 5] In the same fashion, dictionaries can deliver keyword arguments with the **-operator: >>> def parrot(voltage, state='a stiff', action='voom'): ... print(\"-- This parrot wouldn't\", action, end=' ') ... print(\"if you put\", voltage, \"volts through it.\", end=' ') ... print(\"E's\", state, \"!\") ... >>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"} >>> parrot(**d) -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised ! 4.9.6. Lambda ExpressionsÂ¶ Small anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: lambda a, b: a+b. Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Semantically, they are just syntactic sugar for a normal function definition. Like nested function definitions, lambda functions can reference variables from the containing scope: >>> def make_incrementor(n): ... return lambda x: x + n ... >>> f = make_incrementor(42) >>> f(0) 42 >>> f(1) 43 The above example uses a lambda expression to return a function. Another use is to pass a small function as an argument. For instance, list.sort() takes a sorting key function key which can be a lambda function: >>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')] >>> pairs.sort(key=lambda pair: pair[1]) >>> pairs [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 4.9.7. Documentation StringsÂ¶ Here are some conventions about the content and formatting of documentation strings. The first line should always be",
    "content_length": 3298
  },
  {
    "id": "controlflow_chunk_11",
    "source_file": "controlflow",
    "chunk_index": 11,
    "content": "be a lambda function: >>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')] >>> pairs.sort(key=lambda pair: pair[1]) >>> pairs [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 4.9.7. Documentation StringsÂ¶ Here are some conventions about the content and formatting of documentation strings. The first line should always be a short, concise summary of the objectâs purpose. For brevity, it should not explicitly state the objectâs name or type, since these are available by other means (except if the name happens to be a verb describing a functionâs operation). This line should begin with a capital letter and end with a period. If there are more lines in the documentation string, the second line should be blank, visually separating the summary from the rest of the description. The following lines should be one or more paragraphs describing the objectâs calling conventions, its side effects, etc. The Python parser does not strip indentation from multi-line string literals in Python, so tools that process documentation have to strip indentation if desired. This is done using the following convention. The first non-blank line after the first line of the string determines the amount of indentation for the entire documentation string. (We canât use the first line since it is generally adjacent to the stringâs opening quotes so its indentation is not apparent in the string literal.) Whitespace âequivalentâ to this indentation is then stripped from the start of all lines of the string. Lines that are indented less should not occur, but if they occur all their leading whitespace should be stripped. Equivalence of whitespace should be tested after expansion of tabs (to 8 spaces, normally). Here is an example of a multi-line docstring: >>> def my_function(): ... \"\"\"Do nothing, but document it. ... ... No, really, it doesn't do anything. ... \"\"\" ... pass ... >>> print(my_function.__doc__) Do nothing, but document it. No, really, it doesn't do anything. 4.9.8. Function AnnotationsÂ¶ Function annotations are completely optional metadata information about the types used by user-defined functions (see PEP 3107 and PEP 484 for more information). Annotations are stored in the __annotations__ attribute of the function as a dictionary and have no effect on any other part of the function. Parameter annotations are defined by a colon after the parameter name, followed by an expression evaluating to the value of the annotation. Return annotations are defined by a literal ->, followed by an expression, between the parameter list and the colon denoting the end of the def statement. The following example has a required argument, an optional argument, and the return value annotated: >>> def f(ham: str, eggs: str = 'eggs') -> str: ... print(\"Annotations:\", f.__annotations__) ... print(\"Arguments:\", ham, eggs) ... return ham + ' and ' + eggs ... >>> f('spam') Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>} Arguments: spam eggs 'spam and eggs' 4.10. Intermezzo: Coding StyleÂ¶ Now that you are about to write longer, more complex pieces of Python, it is a good time to talk about",
    "content_length": 3164
  },
  {
    "id": "controlflow_chunk_12",
    "source_file": "controlflow",
    "chunk_index": 12,
    "content": "+ ' and ' + eggs ... >>> f('spam') Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>} Arguments: spam eggs 'spam and eggs' 4.10. Intermezzo: Coding StyleÂ¶ Now that you are about to write longer, more complex pieces of Python, it is a good time to talk about coding style. Most languages can be written (or more concise, formatted) in different styles; some are more readable than others. Making it easy for others to read your code is always a good idea, and adopting a nice coding style helps tremendously for that. For Python, PEP 8 has emerged as the style guide that most projects adhere to; it promotes a very readable and eye-pleasing coding style. Every Python developer should read it at some point; here are the most important points extracted for you: Use 4-space indentation, and no tabs. 4 spaces are a good compromise between small indentation (allows greater nesting depth) and large indentation (easier to read). Tabs introduce confusion, and are best left out. Wrap lines so that they donât exceed 79 characters. This helps users with small displays and makes it possible to have several code files side-by-side on larger displays. Use blank lines to separate functions and classes, and larger blocks of code inside functions. When possible, put comments on a line of their own. Use docstrings. Use spaces around operators and after commas, but not directly inside bracketing constructs: a = f(1, 2) + g(3, 4). Name your classes and functions consistently; the convention is to use UpperCamelCase for classes and lowercase_with_underscores for functions and methods. Always use self as the name for the first method argument (see A First Look at Classes for more on classes and methods). Donât use fancy encodings if your code is meant to be used in international environments. Pythonâs default, UTF-8, or even plain ASCII work best in any case. Likewise, donât use non-ASCII characters in identifiers if there is only the slightest chance people speaking a different language will read or maintain the code. Footnotes [1] Actually, call by object reference would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it (items inserted into a list).",
    "content_length": 2268
  },
  {
    "id": "classes_chunk_0",
    "source_file": "classes",
    "chunk_index": 0,
    "content": "9. ClassesÂ¶ Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state. Compared with other programming languages, Pythonâs class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation. In C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the objectâs members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances. (Lacking universally accepted terminology to talk about classes, I will make occasional use of Smalltalk and C++ terms. I would use Modula-3 terms, since its object-oriented semantics are closer to those of Python than C++, but I expect that few readers have heard of it.) 9.1. A Word About Names and ObjectsÂ¶ Objects have individuality, and multiple names (in multiple scopes) can be bound to the same object. This is known as aliasing in other languages. This is usually not appreciated on a first glance at Python, and can be safely ignored when dealing with immutable basic types (numbers, strings, tuples). However, aliasing has a possibly surprising effect on the semantics of Python code involving mutable objects such as lists, dictionaries, and most other types. This is usually used to the benefit of the program, since aliases behave like pointers in some respects. For example, passing an object is cheap since only a pointer is passed by the implementation; and if a function modifies an object passed as an argument, the caller will see the change â this eliminates the need for two different argument passing mechanisms as in Pascal. 9.2. Python Scopes and NamespacesÂ¶ Before introducing classes, I first have to tell you something about Pythonâs scope rules. Class definitions play some neat tricks with namespaces, and you need to",
    "content_length": 3108
  },
  {
    "id": "classes_chunk_1",
    "source_file": "classes",
    "chunk_index": 1,
    "content": "caller will see the change â this eliminates the need for two different argument passing mechanisms as in Pascal. 9.2. Python Scopes and NamespacesÂ¶ Before introducing classes, I first have to tell you something about Pythonâs scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand whatâs going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer. Letâs begin with some definitions. A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but thatâs normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as abs(), and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function maximize without confusion â users of the modules must prefix it with the module name. By the way, I use the word attribute for any name following a dot â for example, in the expression z.real, real is an attribute of the object z. Strictly speaking, references to names in modules are attribute references: in the expression modname.funcname, modname is a module object and funcname is an attribute of it. In this case there happens to be a straightforward mapping between the moduleâs attributes and the global names defined in the module: they share the same namespace! [1] Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write modname.the_answer = 42. Writable attributes may also be deleted with the del statement. For example, del modname.the_answer will remove the attribute the_answer from the object named by modname. Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called __main__, so they have their own global namespace. (The built-in names actually also live in a module; this is called builtins.) The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace",
    "content_length": 3140
  },
  {
    "id": "classes_chunk_2",
    "source_file": "classes",
    "chunk_index": 2,
    "content": "when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace is directly accessible. âDirectly accessibleâ here means that an unqualified reference to a name attempts to find the name in the namespace. Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible: the innermost scope, which is searched first, contains the local names the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names the next-to-last scope contains the current moduleâs global names the outermost scope (searched last) is the namespace containing built-in names If a name is declared global, then all references and assignments go directly to the next-to-last scope containing the moduleâs global names. To rebind variables found outside of the innermost scope, the nonlocal statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged). Usually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the moduleâs namespace. Class definitions place yet another namespace in the local scope. It is important to realize that scopes are determined textually: the global scope of a function defined in a module is that moduleâs namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time â however, the language definition is evolving towards static name resolution, at âcompileâ time, so donât rely on dynamic name resolution! (In fact, local variables are already determined statically.) A special quirk of Python is that â if no global or nonlocal statement is in effect â assignments to names always go into the innermost scope. Assignments do not copy data â they just bind names to objects. The same is true for deletions: the statement del x removes the binding of x from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, import statements and function definitions bind the module or function name in the local scope. The global statement can be used to indicate that particular variables live in the global scope and should be rebound there; the nonlocal statement indicates that particular variables live in an enclosing scope and should be rebound there. 9.2.1. Scopes and Namespaces ExampleÂ¶ This is an example demonstrating how to reference the different scopes and namespaces, and how global and nonlocal affect variable binding: def scope_test(): def do_local(): spam",
    "content_length": 3186
  },
  {
    "id": "classes_chunk_3",
    "source_file": "classes",
    "chunk_index": 3,
    "content": "rebound there; the nonlocal statement indicates that particular variables live in an enclosing scope and should be rebound there. 9.2.1. Scopes and Namespaces ExampleÂ¶ This is an example demonstrating how to reference the different scopes and namespaces, and how global and nonlocal affect variable binding: def scope_test(): def do_local(): spam = \"local spam\" def do_nonlocal(): nonlocal spam spam = \"nonlocal spam\" def do_global(): global spam spam = \"global spam\" spam = \"test spam\" do_local() print(\"After local assignment:\", spam) do_nonlocal() print(\"After nonlocal assignment:\", spam) do_global() print(\"After global assignment:\", spam) scope_test() print(\"In global scope:\", spam) The output of the example code is: After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam Note how the local assignment (which is default) didnât change scope_test's binding of spam. The nonlocal assignment changed scope_test's binding of spam, and the global assignment changed the module-level binding. You can also see that there was no previous binding for spam before the global assignment. 9.3. A First Look at ClassesÂ¶ Classes introduce a little bit of new syntax, three new object types, and some new semantics. 9.3.1. Class Definition SyntaxÂ¶ The simplest form of class definition looks like this: class ClassName: <statement-1> . . . <statement-N> Class definitions, like function definitions (def statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an if statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful â weâll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods â again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope â thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; weâll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header (ClassName in the example). 9.3.2. Class ObjectsÂ¶ Class objects support two kinds of operations: attribute references and instantiation. Attribute references use the standard syntax used for all attribute references in Python: obj.name. Valid attribute names are all the names that were in the classâs namespace when the class object was created. So, if the class definition looked like this: class MyClass: \"\"\"A simple example class\"\"\" i = 12345 def f(self): return 'hello world' then MyClass.i and MyClass.f are valid attribute references, returning an integer and a function object,",
    "content_length": 3273
  },
  {
    "id": "classes_chunk_4",
    "source_file": "classes",
    "chunk_index": 4,
    "content": "names that were in the classâs namespace when the class object was created. So, if the class definition looked like this: class MyClass: \"\"\"A simple example class\"\"\" i = 12345 def f(self): return 'hello world' then MyClass.i and MyClass.f are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of MyClass.i by assignment. __doc__ is also a valid attribute, returning the docstring belonging to the class: \"A simple example class\". Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class): x = MyClass() creates a new instance of the class and assigns this object to the local variable x. The instantiation operation (âcallingâ a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named __init__(), like this: def __init__(self): self.data = [] When a class defines an __init__() method, class instantiation automatically invokes __init__() for the newly created class instance. So in this example, a new, initialized instance can be obtained by: x = MyClass() Of course, the __init__() method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to __init__(). For example, >>> class Complex: ... def __init__(self, realpart, imagpart): ... self.r = realpart ... self.i = imagpart ... >>> x = Complex(3.0, -4.5) >>> x.r, x.i (3.0, -4.5) 9.3.3. Instance ObjectsÂ¶ Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods. data attributes correspond to âinstance variablesâ in Smalltalk, and to âdata membersâ in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if x is the instance of MyClass created above, the following piece of code will print the value 16, without leaving a trace: x.counter = 1 while x.counter < 10: x.counter = x.counter * 2 print(x.counter) del x.counter The other kind of instance attribute reference is a method. A method is a function that âbelongs toâ an object. Valid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, x.f is a valid method reference, since MyClass.f is a function, but x.i is not, since MyClass.i is not. But x.f is not the same thing as MyClass.f â it is a method object, not a function object. 9.3.4. Method ObjectsÂ¶ Usually, a method is called right after it is bound: x.f() If x = MyClass(), as above, this will return the string 'hello world'. However, it is not necessary to call a method right away: x.f is a",
    "content_length": 3077
  },
  {
    "id": "classes_chunk_5",
    "source_file": "classes",
    "chunk_index": 5,
    "content": "it is a method object, not a function object. 9.3.4. Method ObjectsÂ¶ Usually, a method is called right after it is bound: x.f() If x = MyClass(), as above, this will return the string 'hello world'. However, it is not necessary to call a method right away: x.f is a method object, and can be stored away and called at a later time. For example: xf = x.f while True: print(xf()) will continue to print hello world until the end of time. What exactly happens when a method is called? You may have noticed that x.f() was called without an argument above, even though the function definition for f() specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any â even if the argument isnât actually usedâ¦ Actually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call x.f() is exactly equivalent to MyClass.f(x). In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the methodâs instance object before the first argument. In general, methods work as follows. When a non-data attribute of an instance is referenced, the instanceâs class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list. 9.3.5. Class and Instance VariablesÂ¶ Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class: class Dog: kind = 'canine' # class variable shared by all instances def __init__(self, name): self.name = name # instance variable unique to each instance >>> d = Dog('Fido') >>> e = Dog('Buddy') >>> d.kind # shared by all dogs 'canine' >>> e.kind # shared by all dogs 'canine' >>> d.name # unique to d 'Fido' >>> e.name # unique to e 'Buddy' As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances: class Dog: tricks = [] # mistaken use of a class variable def __init__(self, name): self.name = name def add_trick(self, trick): self.tricks.append(trick) >>> d = Dog('Fido') >>> e = Dog('Buddy') >>> d.add_trick('roll over') >>> e.add_trick('play dead') >>> d.tricks # unexpectedly shared by all dogs ['roll over', 'play dead'] Correct design of the class should use",
    "content_length": 2963
  },
  {
    "id": "classes_chunk_6",
    "source_file": "classes",
    "chunk_index": 6,
    "content": "# mistaken use of a class variable def __init__(self, name): self.name = name def add_trick(self, trick): self.tricks.append(trick) >>> d = Dog('Fido') >>> e = Dog('Buddy') >>> d.add_trick('roll over') >>> e.add_trick('play dead') >>> d.tricks # unexpectedly shared by all dogs ['roll over', 'play dead'] Correct design of the class should use an instance variable instead: class Dog: def __init__(self, name): self.name = name self.tricks = [] # creates a new empty list for each dog def add_trick(self, trick): self.tricks.append(trick) >>> d = Dog('Fido') >>> e = Dog('Buddy') >>> d.add_trick('roll over') >>> e.add_trick('play dead') >>> d.tricks ['roll over'] >>> e.tricks ['play dead'] 9.4. Random RemarksÂ¶ If the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance: >>> class Warehouse: ... purpose = 'storage' ... region = 'west' ... >>> w1 = Warehouse() >>> print(w1.purpose, w1.region) storage west >>> w2 = Warehouse() >>> w2.region = 'east' >>> print(w2.purpose, w2.region) storage east Data attributes may be referenced by methods as well as by ordinary users (âclientsâ) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding â it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.) Clients should use data attributes with care â clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided â again, a naming convention can save a lot of headaches here. There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method. Often, the first argument of a method is called self. This is nothing more than a convention: the name self has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention. Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example: # Function defined outside the class def f1(self, x, y): return min(x, x+y) class C: f = f1 def g(self): return 'hello world' h = g Now f, g and h are all attributes of class C that refer to function objects, and consequently they are",
    "content_length": 3066
  },
  {
    "id": "classes_chunk_7",
    "source_file": "classes",
    "chunk_index": 7,
    "content": "also ok. For example: # Function defined outside the class def f1(self, x, y): return min(x, x+y) class C: f = f1 def g(self): return 'hello world' h = g Now f, g and h are all attributes of class C that refer to function objects, and consequently they are all methods of instances of C â h being exactly equivalent to g. Note that this practice usually only serves to confuse the reader of a program. Methods may call other methods by using method attributes of the self argument: class Bag: def __init__(self): self.data = [] def add(self, x): self.data.append(x) def addtwice(self, x): self.add(x) self.add(x) Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section weâll find some good reasons why a method would want to reference its own class. Each value is an object, and therefore has a class (also called its type). It is stored as object.__class__. 9.5. InheritanceÂ¶ Of course, a language feature would not be worthy of the name âclassâ without supporting inheritance. The syntax for a derived class definition looks like this: class DerivedClassName(BaseClassName): <statement-1> . . . <statement-N> The name BaseClassName must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module: class DerivedClassName(modname.BaseClassName): Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class. Thereâs nothing special about instantiation of derived classes: DerivedClassName() creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object. Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively",
    "content_length": 3046
  },
  {
    "id": "classes_chunk_8",
    "source_file": "classes",
    "chunk_index": 8,
    "content": "have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively virtual.) An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call BaseClassName.methodname(self, arguments). This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as BaseClassName in the global scope.) Python has two built-in functions that work with inheritance: Use isinstance() to check an instanceâs type: isinstance(obj, int) will be True only if obj.__class__ is int or some class derived from int. Use issubclass() to check class inheritance: issubclass(bool, int) is True since bool is a subclass of int. However, issubclass(float, int) is False since float is not a subclass of int. 9.5.1. Multiple InheritanceÂ¶ Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this: class DerivedClassName(Base1, Base2, Base3): <statement-1> . . . <statement-N> For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in DerivedClassName, it is searched for in Base1, then (recursively) in the base classes of Base1, and if it was not found there, it was searched for in Base2, and so on. In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to super(). This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages. Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from object, so any case of multiple inheritance provides more than one path to reach object. To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order. 9.6. Private VariablesÂ¶ âPrivateâ instance variables that cannot be accessed except from inside an object donât exist in Python. However, there is a convention that is followed by most Python code: a name",
    "content_length": 3126
  },
  {
    "id": "classes_chunk_9",
    "source_file": "classes",
    "chunk_index": 9,
    "content": "reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order. 9.6. Private VariablesÂ¶ âPrivateâ instance variables that cannot be accessed except from inside an object donât exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class. See also The private name mangling specifications for details and special cases. Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example: class Mapping: def __init__(self, iterable): self.items_list = [] self.__update(iterable) def update(self, iterable): for item in iterable: self.items_list.append(item) __update = update # private copy of original update() method class MappingSubclass(Mapping): def update(self, keys, values): # provides new signature for update() # but does not break __init__() for item in zip(keys, values): self.items_list.append(item) The above example would work even if MappingSubclass were to introduce a __update identifier since it is replaced with _Mapping__update in the Mapping class and _MappingSubclass__update in the MappingSubclass class respectively. Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger. Notice that code passed to exec() or eval() does not consider the classname of the invoking class to be the current class; this is similar to the effect of the global statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to getattr(), setattr() and delattr(), as well as when referencing __dict__ directly. 9.7. Odds and EndsÂ¶ Sometimes it is useful to have a data type similar to the Pascal ârecordâ or C âstructâ, bundling together a few named data items. The idiomatic approach is to use dataclasses for this purpose: from dataclasses import dataclass @dataclass class Employee: name: str dept: str salary: int >>> john = Employee('john', 'computer lab', 1000) >>> john.dept 'computer lab' >>> john.salary 1000 A piece of Python code that expects a particular abstract data type can often be passed a class that emulates the methods of that data type instead. For instance, if you have a function that formats some data from a file object, you can define a class with",
    "content_length": 3255
  },
  {
    "id": "classes_chunk_10",
    "source_file": "classes",
    "chunk_index": 10,
    "content": "john.salary 1000 A piece of Python code that expects a particular abstract data type can often be passed a class that emulates the methods of that data type instead. For instance, if you have a function that formats some data from a file object, you can define a class with methods read() and readline() that get the data from a string buffer instead, and pass it as an argument. Instance method objects have attributes, too: m.__self__ is the instance object with the method m(), and m.__func__ is the function object corresponding to the method. 9.8. IteratorsÂ¶ By now you have probably noticed that most container objects can be looped over using a for statement: for element in [1, 2, 3]: print(element) for element in (1, 2, 3): print(element) for key in {'one':1, 'two':2}: print(key) for char in \"123\": print(char) for line in open(\"myfile.txt\"): print(line, end='') This style of access is clear, concise, and convenient. The use of iterators pervades and unifies Python. Behind the scenes, the for statement calls iter() on the container object. The function returns an iterator object that defines the method __next__() which accesses elements in the container one at a time. When there are no more elements, __next__() raises a StopIteration exception which tells the for loop to terminate. You can call the __next__() method using the next() built-in function; this example shows how it all works: >>> s = 'abc' >>> it = iter(s) >>> it <str_iterator object at 0x10c90e650> >>> next(it) 'a' >>> next(it) 'b' >>> next(it) 'c' >>> next(it) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> next(it) StopIteration Having seen the mechanics behind the iterator protocol, it is easy to add iterator behavior to your classes. Define an __iter__() method which returns an object with a __next__() method. If the class defines __next__(), then __iter__() can just return self: class Reverse: \"\"\"Iterator for looping over a sequence backwards.\"\"\" def __init__(self, data): self.data = data self.index = len(data) def __iter__(self): return self def __next__(self): if self.index == 0: raise StopIteration self.index = self.index - 1 return self.data[self.index] >>> rev = Reverse('spam') >>> iter(rev) <__main__.Reverse object at 0x00A1DB50> >>> for char in rev: ... print(char) ... m a p s 9.9. GeneratorsÂ¶ Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create: def reverse(data): for index in range(len(data)-1, -1, -1): yield data[index] >>> for char in reverse('golf'): ... print(char) ... f l o g Anything that can be done with generators can also be done with class-based iterators as described in the previous section. What makes generators so compact is that the __iter__() and __next__() methods are created automatically. Another key feature is that the local variables",
    "content_length": 3132
  },
  {
    "id": "classes_chunk_11",
    "source_file": "classes",
    "chunk_index": 11,
    "content": "... print(char) ... f l o g Anything that can be done with generators can also be done with class-based iterators as described in the previous section. What makes generators so compact is that the __iter__() and __next__() methods are created automatically. Another key feature is that the local variables and execution state are automatically saved between calls. This made the function easier to write and much more clear than an approach using instance variables like self.index and self.data. In addition to automatic method creation and saving program state, when generators terminate, they automatically raise StopIteration. In combination, these features make it easy to create iterators with no more effort than writing a regular function. 9.10. Generator ExpressionsÂ¶ Some simple generators can be coded succinctly as expressions using a syntax similar to list comprehensions but with parentheses instead of square brackets. These expressions are designed for situations where the generator is used right away by an enclosing function. Generator expressions are more compact but less versatile than full generator definitions and tend to be more memory friendly than equivalent list comprehensions. Examples: >>> sum(i*i for i in range(10)) # sum of squares 285 >>> xvec = [10, 20, 30] >>> yvec = [7, 5, 3] >>> sum(x*y for x,y in zip(xvec, yvec)) # dot product 260 >>> unique_words = set(word for line in page for word in line.split()) >>> valedictorian = max((student.gpa, student.name) for student in graduates) >>> data = 'golf' >>> list(data[i] for i in range(len(data)-1, -1, -1)) ['f', 'l', 'o', 'g'] Footnotes [1] Except for one thing. Module objects have a secret read-only attribute called __dict__ which returns the dictionary used to implement the moduleâs namespace; the name __dict__ is an attribute but not a global name. Obviously, using this violates the abstraction of namespace implementation, and should be restricted to things like post-mortem debuggers.",
    "content_length": 1986
  },
  {
    "id": "errors_chunk_0",
    "source_file": "errors",
    "chunk_index": 0,
    "content": "8. Errors and ExceptionsÂ¶ Until now error messages havenât been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions. 8.1. Syntax ErrorsÂ¶ Syntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python: >>> while True print('Hello world') File \"<stdin>\", line 1 while True print('Hello world') ^^^^^ SyntaxError: invalid syntax The parser repeats the offending line and displays little arrows pointing at the place where the error was detected. Note that this is not always the place that needs to be fixed. In the example, the error is detected at the function print(), since a colon (':') is missing just before it. The file name (<stdin> in our example) and line number are printed so you know where to look in case the input came from a file. 8.2. ExceptionsÂ¶ Even if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here: >>> 10 * (1/0) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> 10 * (1/0) ~^~ ZeroDivisionError: division by zero >>> 4 + spam*3 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> 4 + spam*3 ^^^^ NameError: name 'spam' is not defined >>> '2' + 2 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> '2' + 2 ~~~~^~~ TypeError: can only concatenate str (not \"int\") to str The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are ZeroDivisionError, NameError and TypeError. The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords). The rest of the line provides detail based on the type of exception and what caused it. The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input. Built-in Exceptions lists the built-in exceptions and their meanings. 8.3. Handling ExceptionsÂ¶ It is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using Control-C or whatever the operating system supports); note that a user-generated interruption is",
    "content_length": 3023
  },
  {
    "id": "errors_chunk_1",
    "source_file": "errors",
    "chunk_index": 1,
    "content": "It is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using Control-C or whatever the operating system supports); note that a user-generated interruption is signalled by raising the KeyboardInterrupt exception. >>> while True: ... try: ... x = int(input(\"Please enter a number: \")) ... break ... except ValueError: ... print(\"Oops! That was no valid number. Try again...\") ... The try statement works as follows. First, the try clause (the statement(s) between the try and except keywords) is executed. If no exception occurs, the except clause is skipped and execution of the try statement is finished. If an exception occurs during execution of the try clause, the rest of the clause is skipped. Then, if its type matches the exception named after the except keyword, the except clause is executed, and then execution continues after the try/except block. If an exception occurs which does not match the exception named in the except clause, it is passed on to outer try statements; if no handler is found, it is an unhandled exception and execution stops with an error message. A try statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same try statement. An except clause may name multiple exceptions as a parenthesized tuple, for example: ... except (RuntimeError, TypeError, NameError): ... pass A class in an except clause matches exceptions which are instances of the class itself or one of its derived classes (but not the other way around â an except clause listing a derived class does not match instances of its base classes). For example, the following code will print B, C, D in that order: class B(Exception): pass class C(B): pass class D(C): pass for cls in [B, C, D]: try: raise cls() except D: print(\"D\") except C: print(\"C\") except B: print(\"B\") Note that if the except clauses were reversed (with except B first), it would have printed B, B, B â the first matching except clause is triggered. When an exception occurs, it may have associated values, also known as the exceptionâs arguments. The presence and types of the arguments depend on the exception type. The except clause may specify a variable after the exception name. The variable is bound to the exception instance which typically has an args attribute that stores the arguments. For convenience, builtin exception types define __str__() to print all the arguments without explicitly accessing .args. >>> try: ... raise Exception('spam', 'eggs') ... except Exception as inst: ... print(type(inst)) # the exception type ... print(inst.args) # arguments stored in .args ... print(inst) # __str__ allows args to be printed directly, ... # but may be overridden in exception subclasses ... x, y = inst.args # unpack args ...",
    "content_length": 3052
  },
  {
    "id": "errors_chunk_2",
    "source_file": "errors",
    "chunk_index": 2,
    "content": "... raise Exception('spam', 'eggs') ... except Exception as inst: ... print(type(inst)) # the exception type ... print(inst.args) # arguments stored in .args ... print(inst) # __str__ allows args to be printed directly, ... # but may be overridden in exception subclasses ... x, y = inst.args # unpack args ... print('x =', x) ... print('y =', y) ... <class 'Exception'> ('spam', 'eggs') ('spam', 'eggs') x = spam y = eggs The exceptionâs __str__() output is printed as the last part (âdetailâ) of the message for unhandled exceptions. BaseException is the common base class of all exceptions. One of its subclasses, Exception, is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of Exception are not typically handled, because they are used to indicate that the program should terminate. They include SystemExit which is raised by sys.exit() and KeyboardInterrupt which is raised when a user wishes to interrupt the program. Exception can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on. The most common pattern for handling Exception is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well): import sys try: f = open('myfile.txt') s = f.readline() i = int(s.strip()) except OSError as err: print(\"OS error:\", err) except ValueError: print(\"Could not convert data to an integer.\") except Exception as err: print(f\"Unexpected {err=}, {type(err)=}\") raise The try â¦ except statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example: for arg in sys.argv[1:]: try: f = open(arg, 'r') except OSError: print('cannot open', arg) else: print(arg, 'has', len(f.readlines()), 'lines') f.close() The use of the else clause is better than adding additional code to the try clause because it avoids accidentally catching an exception that wasnât raised by the code being protected by the try â¦ except statement. Exception handlers do not handle only exceptions that occur immediately in the try clause, but also those that occur inside functions that are called (even indirectly) in the try clause. For example: >>> def this_fails(): ... x = 1/0 ... >>> try: ... this_fails() ... except ZeroDivisionError as err: ... print('Handling run-time error:', err) ... Handling run-time error: division by zero 8.4. Raising ExceptionsÂ¶ The raise statement allows the programmer to force a specified exception to occur. For example: >>> raise NameError('HiThere') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> raise NameError('HiThere') NameError: HiThere The sole argument to raise indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from BaseException, such as Exception or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor",
    "content_length": 3179
  },
  {
    "id": "errors_chunk_3",
    "source_file": "errors",
    "chunk_index": 3,
    "content": "sole argument to raise indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from BaseException, such as Exception or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor with no arguments: raise ValueError # shorthand for 'raise ValueError()' If you need to determine whether an exception was raised but donât intend to handle it, a simpler form of the raise statement allows you to re-raise the exception: >>> try: ... raise NameError('HiThere') ... except NameError: ... print('An exception flew by!') ... raise ... An exception flew by! Traceback (most recent call last): File \"<stdin>\", line 2, in <module> raise NameError('HiThere') NameError: HiThere 8.5. Exception ChainingÂ¶ If an unhandled exception occurs inside an except section, it will have the exception being handled attached to it and included in the error message: >>> try: ... open(\"database.sqlite\") ... except OSError: ... raise RuntimeError(\"unable to handle error\") ... Traceback (most recent call last): File \"<stdin>\", line 2, in <module> open(\"database.sqlite\") ~~~~^^^^^^^^^^^^^^^^^^^ FileNotFoundError: [Errno 2] No such file or directory: 'database.sqlite' During handling of the above exception, another exception occurred: Traceback (most recent call last): File \"<stdin>\", line 4, in <module> raise RuntimeError(\"unable to handle error\") RuntimeError: unable to handle error To indicate that an exception is a direct consequence of another, the raise statement allows an optional from clause: # exc must be exception instance or None. raise RuntimeError from exc This can be useful when you are transforming exceptions. For example: >>> def func(): ... raise ConnectionError ... >>> try: ... func() ... except ConnectionError as exc: ... raise RuntimeError('Failed to open database') from exc ... Traceback (most recent call last): File \"<stdin>\", line 2, in <module> func() ~~~~^^ File \"<stdin>\", line 2, in func ConnectionError The above exception was the direct cause of the following exception: Traceback (most recent call last): File \"<stdin>\", line 4, in <module> raise RuntimeError('Failed to open database') from exc RuntimeError: Failed to open database It also allows disabling automatic exception chaining using the from None idiom: >>> try: ... open('database.sqlite') ... except OSError: ... raise RuntimeError from None ... Traceback (most recent call last): File \"<stdin>\", line 4, in <module> raise RuntimeError from None RuntimeError For more information about chaining mechanics, see Built-in Exceptions. 8.6. User-defined ExceptionsÂ¶ Programs may name their own exceptions by creating a new exception class (see Classes for more about Python classes). Exceptions should typically be derived from the Exception class, either directly or indirectly. Exception classes can be defined which do anything any other class can do, but are usually kept simple, often only offering a number of attributes that allow information about the error to be extracted by handlers for the exception. Most exceptions are defined with names that end in âErrorâ, similar to the naming of the standard exceptions. Many standard modules define their own exceptions to report errors that may occur in functions they define. 8.7. Defining",
    "content_length": 3357
  },
  {
    "id": "errors_chunk_4",
    "source_file": "errors",
    "chunk_index": 4,
    "content": "allow information about the error to be extracted by handlers for the exception. Most exceptions are defined with names that end in âErrorâ, similar to the naming of the standard exceptions. Many standard modules define their own exceptions to report errors that may occur in functions they define. 8.7. Defining Clean-up ActionsÂ¶ The try statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. For example: >>> try: ... raise KeyboardInterrupt ... finally: ... print('Goodbye, world!') ... Goodbye, world! Traceback (most recent call last): File \"<stdin>\", line 2, in <module> raise KeyboardInterrupt KeyboardInterrupt If a finally clause is present, the finally clause will execute as the last task before the try statement completes. The finally clause runs whether or not the try statement produces an exception. The following points discuss more complex cases when an exception occurs: If an exception occurs during execution of the try clause, the exception may be handled by an except clause. If the exception is not handled by an except clause, the exception is re-raised after the finally clause has been executed. An exception could occur during execution of an except or else clause. Again, the exception is re-raised after the finally clause has been executed. If the finally clause executes a break, continue or return statement, exceptions are not re-raised. If the try statement reaches a break, continue or return statement, the finally clause will execute just prior to the break, continue or return statementâs execution. If a finally clause includes a return statement, the returned value will be the one from the finally clauseâs return statement, not the value from the try clauseâs return statement. For example: >>> def bool_return(): ... try: ... return True ... finally: ... return False ... >>> bool_return() False A more complicated example: >>> def divide(x, y): ... try: ... result = x / y ... except ZeroDivisionError: ... print(\"division by zero!\") ... else: ... print(\"result is\", result) ... finally: ... print(\"executing finally clause\") ... >>> divide(2, 1) result is 2.0 executing finally clause >>> divide(2, 0) division by zero! executing finally clause >>> divide(\"2\", \"1\") executing finally clause Traceback (most recent call last): File \"<stdin>\", line 1, in <module> divide(\"2\", \"1\") ~~~~~~^^^^^^^^^^ File \"<stdin>\", line 3, in divide result = x / y ~~^~~ TypeError: unsupported operand type(s) for /: 'str' and 'str' As you can see, the finally clause is executed in any event. The TypeError raised by dividing two strings is not handled by the except clause and therefore re-raised after the finally clause has been executed. In real world applications, the finally clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful. 8.8. Predefined Clean-up ActionsÂ¶ Some objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries",
    "content_length": 3205
  },
  {
    "id": "errors_chunk_5",
    "source_file": "errors",
    "chunk_index": 5,
    "content": "regardless of whether the use of the resource was successful. 8.8. Predefined Clean-up ActionsÂ¶ Some objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen. for line in open(\"myfile.txt\"): print(line, end=\"\") The problem with this code is that it leaves the file open for an indeterminate amount of time after this part of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The with statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly. with open(\"myfile.txt\") as f: for line in f: print(line, end=\"\") After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their documentation. 8.9. Raising and Handling Multiple Unrelated ExceptionsÂ¶ There are situations where it is necessary to report several exceptions that have occurred. This is often the case in concurrency frameworks, when several tasks may have failed in parallel, but there are also other use cases where it is desirable to continue execution and collect multiple errors rather than raise the first exception. The builtin ExceptionGroup wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception. >>> def f(): ... excs = [OSError('error 1'), SystemError('error 2')] ... raise ExceptionGroup('there were problems', excs) ... >>> f() + Exception Group Traceback (most recent call last): | File \"<stdin>\", line 1, in <module> | f() | ~^^ | File \"<stdin>\", line 3, in f | raise ExceptionGroup('there were problems', excs) | ExceptionGroup: there were problems (2 sub-exceptions) +-+---------------- 1 ---------------- | OSError: error 1 +---------------- 2 ---------------- | SystemError: error 2 +------------------------------------ >>> try: ... f() ... except Exception as e: ... print(f'caught {type(e)}: e') ... caught <class 'ExceptionGroup'>: e >>> By using except* instead of except, we can selectively handle only the exceptions in the group that match a certain type. In the following example, which shows a nested exception group, each except* clause extracts from the group exceptions of a certain type while letting all other exceptions propagate to other clauses and eventually to be reraised. >>> def f(): ... raise ExceptionGroup( ... \"group1\", ... [ ... OSError(1), ... SystemError(2), ... ExceptionGroup( ... \"group2\", ... [ ... OSError(3), ... RecursionError(4) ... ] ... ) ... ] ... ) ... >>> try: ... f() ... except* OSError as e: ... print(\"There were OSErrors\") ... except* SystemError as e: ... print(\"There were SystemErrors\") ... There were OSErrors There were SystemErrors + Exception Group Traceback (most recent call last): | File \"<stdin>\", line 2, in <module> | f() | ~^^ |",
    "content_length": 3153
  },
  {
    "id": "errors_chunk_6",
    "source_file": "errors",
    "chunk_index": 6,
    "content": "... >>> try: ... f() ... except* OSError as e: ... print(\"There were OSErrors\") ... except* SystemError as e: ... print(\"There were SystemErrors\") ... There were OSErrors There were SystemErrors + Exception Group Traceback (most recent call last): | File \"<stdin>\", line 2, in <module> | f() | ~^^ | File \"<stdin>\", line 2, in f | raise ExceptionGroup( | ...<12 lines>... | ) | ExceptionGroup: group1 (1 sub-exception) +-+---------------- 1 ---------------- | ExceptionGroup: group2 (1 sub-exception) +-+---------------- 1 ---------------- | RecursionError: 4 +------------------------------------ >>> Note that the exceptions nested in an exception group must be instances, not types. This is because in practice the exceptions would typically be ones that have already been raised and caught by the program, along the following pattern: >>> excs = [] ... for test in tests: ... try: ... test.run() ... except Exception as e: ... excs.append(e) ... >>> if excs: ... raise ExceptionGroup(\"Test Failures\", excs) ... 8.10. Enriching Exceptions with NotesÂ¶ When an exception is created in order to be raised, it is usually initialized with information that describes the error that has occurred. There are cases where it is useful to add information after the exception was caught. For this purpose, exceptions have a method add_note(note) that accepts a string and adds it to the exceptionâs notes list. The standard traceback rendering includes all notes, in the order they were added, after the exception. >>> try: ... raise TypeError('bad type') ... except Exception as e: ... e.add_note('Add some information') ... e.add_note('Add some more information') ... raise ... Traceback (most recent call last): File \"<stdin>\", line 2, in <module> raise TypeError('bad type') TypeError: bad type Add some information Add some more information >>> For example, when collecting exceptions into an exception group, we may want to add context information for the individual errors. In the following each exception in the group has a note indicating when this error has occurred. >>> def f(): ... raise OSError('operation failed') ... >>> excs = [] >>> for i in range(3): ... try: ... f() ... except Exception as e: ... e.add_note(f'Happened in Iteration {i+1}') ... excs.append(e) ... >>> raise ExceptionGroup('We have some problems', excs) + Exception Group Traceback (most recent call last): | File \"<stdin>\", line 1, in <module> | raise ExceptionGroup('We have some problems', excs) | ExceptionGroup: We have some problems (3 sub-exceptions) +-+---------------- 1 ---------------- | Traceback (most recent call last): | File \"<stdin>\", line 3, in <module> | f() | ~^^ | File \"<stdin>\", line 2, in f | raise OSError('operation failed') | OSError: operation failed | Happened in Iteration 1 +---------------- 2 ---------------- | Traceback (most recent call last): | File \"<stdin>\", line 3, in <module> | f() | ~^^ | File \"<stdin>\", line 2, in f | raise OSError('operation failed') | OSError: operation failed | Happened in Iteration 2 +---------------- 3 ---------------- | Traceback (most recent call last): | File \"<stdin>\", line 3, in <module> | f() | ~^^ | File \"<stdin>\", line 2, in f | raise OSError('operation failed')",
    "content_length": 3220
  },
  {
    "id": "errors_chunk_7",
    "source_file": "errors",
    "chunk_index": 7,
    "content": "File \"<stdin>\", line 2, in f | raise OSError('operation failed') | OSError: operation failed | Happened in Iteration 2 +---------------- 3 ---------------- | Traceback (most recent call last): | File \"<stdin>\", line 3, in <module> | f() | ~^^ | File \"<stdin>\", line 2, in f | raise OSError('operation failed') | OSError: operation failed | Happened in Iteration 3 +------------------------------------ >>>",
    "content_length": 405
  },
  {
    "id": "stdtypes_chunk_0",
    "source_file": "stdtypes",
    "chunk_index": 0,
    "content": "Built-in TypesÂ¶ The following sections describe the standard types that are built into the interpreter. The principal built-in types are numerics, sequences, mappings, classes, instances and exceptions. Some collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and donât return a specific item, never return the collection instance itself but None. Some operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the repr() function or the slightly different str() function). The latter function is implicitly used when an object is written by the print() function. Truth Value TestingÂ¶ Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below. By default, an object is considered true unless its class defines either a __bool__() method that returns False or a __len__() method that returns zero, when called with the object. [1] Here are most of the built-in objects considered false: constants defined to be false: None and False zero of any numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1) empty sequences and collections: '', (), [], {}, set(), range(0) Operations and built-in functions that have a Boolean result always return 0 or False for false and 1 or True for true, unless otherwise stated. (Important exception: the Boolean operations or and and always return one of their operands.) Boolean Operations â and, or, notÂ¶ These are the Boolean operations, ordered by ascending priority: Operation Result Notes x or y if x is true, then x, else y (1) x and y if x is false, then x, else y (2) not x if x is false, then True, else False (3) Notes: This is a short-circuit operator, so it only evaluates the second argument if the first one is false. This is a short-circuit operator, so it only evaluates the second argument if the first one is true. not has a lower priority than non-Boolean operators, so not a == b is interpreted as not (a == b), and a == not b is a syntax error. ComparisonsÂ¶ There are eight comparison operations in Python. They all have the same priority (which is higher than that of the Boolean operations). Comparisons can be chained arbitrarily; for example, x < y <= z is equivalent to x < y and y <= z, except that y is evaluated only once (but in both cases z is not evaluated at all when x < y is found to be false). This table summarizes the comparison operations: Operation Meaning < strictly less than <= less than or equal > strictly greater than >= greater than or equal == equal != not equal is object identity is not negated object identity Objects of different types, except different numeric types, never compare equal. The == operator is always defined but for some object types (for example, class objects) is",
    "content_length": 2903
  },
  {
    "id": "stdtypes_chunk_1",
    "source_file": "stdtypes",
    "chunk_index": 1,
    "content": "equal > strictly greater than >= greater than or equal == equal != not equal is object identity is not negated object identity Objects of different types, except different numeric types, never compare equal. The == operator is always defined but for some object types (for example, class objects) is equivalent to is. The <, <=, > and >= operators are only defined where they make sense; for example, they raise a TypeError exception when one of the arguments is a complex number. Non-identical instances of a class normally compare as non-equal unless the class defines the __eq__() method. Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods __lt__(), __le__(), __gt__(), and __ge__() (in general, __lt__() and __eq__() are sufficient, if you want the conventional meanings of the comparison operators). The behavior of the is and is not operators cannot be customized; also they can be applied to any two objects and never raise an exception. Two more operations with the same syntactic priority, in and not in, are supported by types that are iterable or implement the __contains__() method. Numeric Types â int, float, complexÂ¶ There are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in sys.float_info. Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use z.real and z.imag. (The standard library includes the additional numeric types fractions.Fraction, for rationals, and decimal.Decimal, for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending 'j' or 'J' to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the ânarrowerâ type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. [2] The constructors int(), float(), and complex() can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): Operation Result Notes Full documentation x + y sum of x and y x - y difference of x and",
    "content_length": 3180
  },
  {
    "id": "stdtypes_chunk_2",
    "source_file": "stdtypes",
    "chunk_index": 2,
    "content": "float(), and complex() can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): Operation Result Notes Full documentation x + y sum of x and y x - y difference of x and y x * y product of x and y x / y quotient of x and y x // y floored quotient of x and y (1)(2) x % y remainder of x / y (2) -x x negated +x x unchanged abs(x) absolute value or magnitude of x abs() int(x) x converted to integer (3)(6) int() float(x) x converted to floating point (4)(6) float() complex(re, im) a complex number with real part re, imaginary part im. im defaults to zero. (6) complex() c.conjugate() conjugate of the complex number c divmod(x, y) the pair (x // y, x % y) (2) divmod() pow(x, y) x to the power y (5) pow() x ** y x to the power y (5) Notes: Also referred to as integer division. For operands of type int, the result has type int. For operands of type float, the result has type float. In general, the result is a whole integer, though the resultâs type is not necessarily int. The result is always rounded towards minus infinity: 1//2 is 0, (-1)//2 is -1, 1//(-2) is -1, and (-1)//(-2) is 0. Not for complex numbers. Instead convert to floats using abs() if appropriate. Conversion from float to int truncates, discarding the fractional part. See functions math.floor() and math.ceil() for alternative conversions. float also accepts the strings ânanâ and âinfâ with an optional prefix â+â or â-â for Not a Number (NaN) and positive or negative infinity. Python defines pow(0, 0) and 0 ** 0 to be 1, as is common for programming languages. The numeric literals accepted include the digits 0 to 9 or any Unicode equivalent (code points with the Nd property). See the Unicode Standard for a complete list of code points with the Nd property. All numbers.Real types (int and float) also include the following operations: Operation Result math.trunc(x) x truncated to Integral round(x[, n]) x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. math.floor(x) the greatest Integral <= x math.ceil(x) the least Integral >= x For additional numeric operations see the math and cmath modules. Bitwise Operations on Integer TypesÂ¶ Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in twoâs complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation ~ has the same priority as the other unary numeric operations (+ and -). This table lists the bitwise operations sorted in ascending priority: Operation Result Notes x | y bitwise or of x and y (4) x ^ y bitwise exclusive or of x",
    "content_length": 2841
  },
  {
    "id": "stdtypes_chunk_3",
    "source_file": "stdtypes",
    "chunk_index": 3,
    "content": "the comparisons; the unary operation ~ has the same priority as the other unary numeric operations (+ and -). This table lists the bitwise operations sorted in ascending priority: Operation Result Notes x | y bitwise or of x and y (4) x ^ y bitwise exclusive or of x and y (4) x & y bitwise and of x and y (4) x << n x shifted left by n bits (1)(2) x >> n x shifted right by n bits (1)(3) ~x the bits of x inverted Notes: Negative shift counts are illegal and cause a ValueError to be raised. A left shift by n bits is equivalent to multiplication by pow(2, n). A right shift by n bits is equivalent to floor division by pow(2, n). Performing these calculations with at least one extra sign extension bit in a finite twoâs complement representation (a working bit-width of 1 + max(x.bit_length(), y.bit_length()) or more) is sufficient to get the same result as if there were an infinite number of sign bits. Additional Methods on Integer TypesÂ¶ The int type implements the numbers.Integral abstract base class. In addition, it provides a few more methods: int.bit_length()Â¶ Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: >>> n = -37 >>> bin(n) '-0b100101' >>> n.bit_length() 6 More precisely, if x is nonzero, then x.bit_length() is the unique positive integer k such that 2**(k-1) <= abs(x) < 2**k. Equivalently, when abs(x) is small enough to have a correctly rounded logarithm, then k = 1 + int(log(abs(x), 2)). If x is zero, then x.bit_length() returns 0. Equivalent to: def bit_length(self): s = bin(self) # binary representation: bin(-37) --> '-0b100101' s = s.lstrip('-0b') # remove leading zeros and minus sign return len(s) # len('100101') --> 6 Added in version 3.1. int.bit_count()Â¶ Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: >>> n = 19 >>> bin(n) '0b10011' >>> n.bit_count() 3 >>> (-n).bit_count() 3 Equivalent to: def bit_count(self): return bin(self).count(\"1\") Added in version 3.10. int.to_bytes(length=1, byteorder='big', *, signed=False)Â¶ Return an array of bytes representing an integer. >>> (1024).to_bytes(2, byteorder='big') b'\\x04\\x00' >>> (1024).to_bytes(10, byteorder='big') b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00' >>> (-1024).to_bytes(10, byteorder='big', signed=True) b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00' >>> x = 1000 >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little') b'\\xe8\\x03' The integer is represented using length bytes, and defaults to 1. An OverflowError is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to \"big\". If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. The signed argument determines whether twoâs complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False.",
    "content_length": 3149
  },
  {
    "id": "stdtypes_chunk_4",
    "source_file": "stdtypes",
    "chunk_index": 4,
    "content": "If byteorder is \"little\", the most significant byte is at the end of the byte array. The signed argument determines whether twoâs complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised. The default value for signed is False. The default values can be used to conveniently turn an integer into a single byte object: >>> (65).to_bytes() b'A' However, when using the default arguments, donât try to convert a value greater than 255 or youâll get an OverflowError. Equivalent to: def to_bytes(n, length=1, byteorder='big', signed=False): if byteorder == 'little': order = range(length) elif byteorder == 'big': order = reversed(range(length)) else: raise ValueError(\"byteorder must be either 'little' or 'big'\") return bytes((n >> i*8) & 0xff for i in order) Added in version 3.2. Changed in version 3.11: Added default argument values for length and byteorder. classmethod int.from_bytes(bytes, byteorder='big', *, signed=False)Â¶ Return the integer represented by the given array of bytes. >>> int.from_bytes(b'\\x00\\x10', byteorder='big') 16 >>> int.from_bytes(b'\\x00\\x10', byteorder='little') 4096 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=True) -1024 >>> int.from_bytes(b'\\xfc\\x00', byteorder='big', signed=False) 64512 >>> int.from_bytes([255, 0, 0], byteorder='big') 16711680 The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to \"big\". If byteorder is \"big\", the most significant byte is at the beginning of the byte array. If byteorder is \"little\", the most significant byte is at the end of the byte array. To request the native byte order of the host system, use sys.byteorder as the byte order value. The signed argument indicates whether twoâs complement is used to represent the integer. Equivalent to: def from_bytes(bytes, byteorder='big', signed=False): if byteorder == 'little': little_ordered = list(bytes) elif byteorder == 'big': little_ordered = list(reversed(bytes)) else: raise ValueError(\"byteorder must be either 'little' or 'big'\") n = sum(b << i*8 for i, b in enumerate(little_ordered)) if signed and little_ordered and (little_ordered[-1] & 0x80): n -= 1 << 8*len(little_ordered) return n Added in version 3.2. Changed in version 3.11: Added default argument value for byteorder. int.as_integer_ratio()Â¶ Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and 1 as the denominator. Added in version 3.8. int.is_integer()Â¶ Returns True. Exists for duck type compatibility with float.is_integer(). Added in version 3.12. Additional Methods on FloatÂ¶ The float type implements the numbers.Real abstract base class. float also has the following additional methods. float.as_integer_ratio()Â¶ Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises OverflowError on infinities and a ValueError on NaNs. float.is_integer()Â¶ Return True if the float instance is finite with integral value, and False otherwise: >>> (-2.0).is_integer() True >>> (3.2).is_integer() False Two methods support conversion to and from hexadecimal strings. Since Pythonâs floats are stored internally as binary numbers, converting a float to or from",
    "content_length": 3493
  },
  {
    "id": "stdtypes_chunk_5",
    "source_file": "stdtypes",
    "chunk_index": 5,
    "content": "and a ValueError on NaNs. float.is_integer()Â¶ Return True if the float instance is finite with integral value, and False otherwise: >>> (-2.0).is_integer() True >>> (3.2).is_integer() False Two methods support conversion to and from hexadecimal strings. Since Pythonâs floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. float.hex()Â¶ Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading 0x and a trailing p and exponent. classmethod float.fromhex(s)Â¶ Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that float.hex() is an instance method, while float.fromhex() is a class method. A hexadecimal string takes the form: [sign] ['0x'] integer ['.' fraction] ['p' exponent] where the optional sign may by either + or -, integer and fraction are strings of hexadecimal digits, and exponent is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of float.hex() is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by Câs %a format character or Javaâs Double.toHexString are accepted by float.fromhex(). Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string 0x3.a7p10 represents the floating-point number (3 + 10./16 + 7./16**2) * 2.0**10, or 3740.0: >>> float.fromhex('0x3.a7p10') 3740.0 Applying the reverse conversion to 3740.0 gives a different hexadecimal string representing the same number: >>> float.hex(3740.0) '0x1.d380000000000p+11' Hashing of numeric typesÂ¶ For numbers x and y, possibly of different types, itâs a requirement that hash(x) == hash(y) whenever x == y (see the __hash__() method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including int, float, decimal.Decimal and fractions.Fraction) Pythonâs hash for numeric types is based on a single mathematical function thatâs defined for any rational number, and hence applies to all instances of int and fractions.Fraction, and all finite instances of float and decimal.Decimal. Essentially, this function is given by reduction modulo P for a fixed prime P. The value of P is made available to Python as the modulus attribute of sys.hash_info. CPython implementation detail: Currently, the prime used is P = 2**31 - 1 on machines with 32-bit C longs and P = 2**61 - 1 on machines with 64-bit C longs. Here are the rules in detail: If x = m / n is a nonnegative rational number and n is not",
    "content_length": 3215
  },
  {
    "id": "stdtypes_chunk_6",
    "source_file": "stdtypes",
    "chunk_index": 6,
    "content": "detail: Currently, the prime used is P = 2**31 - 1 on machines with 32-bit C longs and P = 2**61 - 1 on machines with 64-bit C longs. Here are the rules in detail: If x = m / n is a nonnegative rational number and n is not divisible by P, define hash(x) as m * invmod(n, P) % P, where invmod(n, P) gives the inverse of n modulo P. If x = m / n is a nonnegative rational number and n is divisible by P (but m is not) then n has no inverse modulo P and the rule above doesnât apply; in this case define hash(x) to be the constant value sys.hash_info.inf. If x = m / n is a negative rational number define hash(x) as -hash(-x). If the resulting hash is -1, replace it with -2. The particular values sys.hash_info.inf and -sys.hash_info.inf are used as hash values for positive infinity or negative infinity (respectively). For a complex number z, the hash values of the real and imaginary parts are combined by computing hash(z.real) + sys.hash_info.imag * hash(z.imag), reduced modulo 2**sys.hash_info.width so that it lies in range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1)). Again, if the result is -1, itâs replaced with -2. To clarify the above rules, hereâs some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, float, or complex: import sys, math def hash_fraction(m, n): \"\"\"Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). \"\"\" P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m < 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_value def hash_float(x): \"\"\"Compute the hash of a float x.\"\"\" if math.isnan(x): return object.__hash__(x) elif math.isinf(x): return sys.hash_info.inf if x > 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio()) def hash_complex(z): \"\"\"Compute the hash of a complex number z.\"\"\" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value & (M - 1)) - (hash_value & M) if hash_value == -1: hash_value = -2 return hash_value Boolean Type - boolÂ¶ Booleans represent truth values. The bool type has exactly two constant instances: True and False. The built-in function bool() converts any value to a boolean, if the value can be interpreted as a truth value (see section Truth Value Testing above). For logical operations, use the boolean operators and, or and not. When applying the bitwise operators &, |, ^ to two booleans,",
    "content_length": 2900
  },
  {
    "id": "stdtypes_chunk_7",
    "source_file": "stdtypes",
    "chunk_index": 7,
    "content": "and False. The built-in function bool() converts any value to a boolean, if the value can be interpreted as a truth value (see section Truth Value Testing above). For logical operations, use the boolean operators and, or and not. When applying the bitwise operators &, |, ^ to two booleans, they return a bool equivalent to the logical operations âandâ, âorâ, âxorâ. However, the logical operators and, or and != should be preferred over &, | and ^. Deprecated since version 3.12: The use of the bitwise inversion operator ~ is deprecated and will raise an error in Python 3.16. bool is a subclass of int (see Numeric Types â int, float, complex). In many numeric contexts, False and True behave like the integers 0 and 1, respectively. However, relying on this is discouraged; explicitly convert using int() instead. Iterator TypesÂ¶ Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iterable support: container.__iter__()Â¶ Return an iterator object. The object is required to support the iterator protocol described below. If a container supports different types of iteration, additional methods can be provided to specifically request iterators for those iteration types. (An example of an object supporting multiple forms of iteration would be a tree structure which supports both breadth-first and depth-first traversal.) This method corresponds to the tp_iter slot of the type structure for Python objects in the Python/C API. The iterator objects themselves are required to support the following two methods, which together form the iterator protocol: iterator.__iter__()Â¶ Return the iterator object itself. This is required to allow both containers and iterators to be used with the for and in statements. This method corresponds to the tp_iter slot of the type structure for Python objects in the Python/C API. iterator.__next__()Â¶ Return the next item from the iterator. If there are no further items, raise the StopIteration exception. This method corresponds to the tp_iternext slot of the type structure for Python objects in the Python/C API. Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms. The specific types are not important beyond their implementation of the iterator protocol. Once an iteratorâs __next__() method raises StopIteration, it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken. Generator TypesÂ¶ Pythonâs generators provide a convenient way to implement the iterator protocol. If a container objectâs __iter__() method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the __iter__() and __next__() methods. More information about generators can be found in the documentation for the yield expression. Sequence Types â list, tuple, rangeÂ¶ There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing",
    "content_length": 3318
  },
  {
    "id": "stdtypes_chunk_8",
    "source_file": "stdtypes",
    "chunk_index": 8,
    "content": "an iterator object (technically, a generator object) supplying the __iter__() and __next__() methods. More information about generators can be found in the documentation for the yield expression. Sequence Types â list, tuple, rangeÂ¶ There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. Common Sequence OperationsÂ¶ The operations in the following table are supported by most sequence types, both mutable and immutable. The collections.abc.Sequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The in and not in operations have the same priorities as the comparison operations. The + (concatenation) and * (repetition) operations have the same priority as the corresponding numeric operations. [3] Operation Result Notes x in s True if an item of s is equal to x, else False (1) x not in s False if an item of s is equal to x, else True (1) s + t the concatenation of s and t (6)(7) s * n or n * s equivalent to adding s to itself n times (2)(7) s[i] ith item of s, origin 0 (3)(8) s[i:j] slice of s from i to j (3)(4) s[i:j:k] slice of s from i to j with step k (3)(5) len(s) length of s min(s) smallest item of s max(s) largest item of s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an IndexError or a StopIteration is encountered (or when the index drops below zero). Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences (such as str, bytes and bytearray) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of",
    "content_length": 2896
  },
  {
    "id": "stdtypes_chunk_9",
    "source_file": "stdtypes",
    "chunk_index": 9,
    "content": "copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists[0].append(3) >>> lists [[3], [3], [3]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list. You can create a list of different lists this way: >>> lists = [[] for i in range(3)] >>> lists[0].append(3) >>> lists[1].append(5) >>> lists[2].append(7) >>> lists [[3], [5], [7]] Further explanation is available in the FAQ entry How do I create a multidimensional list?. If i or j is negative, the index is relative to the end of sequence s: len(s) + i or len(s) + j is substituted. But note that -0 is still 0. The slice of s from i to j is defined as the sequence of items with index k such that i <= k < j. If i or j is greater than len(s), use len(s). If i is omitted or None, use 0. If j is omitted or None, use len(s). If i is greater than or equal to j, the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k. In other words, the indices are i, i+k, i+2*k, i+3*k and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to len(s) if they are greater. When k is negative, i and j are reduced to len(s) - 1 if they are greater. If i or j are omitted or None, they become âendâ values (which end depends on the sign of k). Note, k cannot be zero. If k is None, it is treated like 1. Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str objects, you can build a list and use str.join() at the end or else write to an io.StringIO instance and retrieve its value when complete if concatenating bytes objects, you can similarly use bytes.join() or io.BytesIO, or you can do in-place concatenation with a bytearray object. bytearray objects are mutable and have an efficient overallocation mechanism if concatenating tuple objects, extend a list instead for other types, investigate the relevant class documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence donât support sequence concatenation or repetition. An IndexError is raised if i is outside the sequence range. Sequence Methods Sequence types also support the following methods: sequence.count(value, /)Â¶ Return the total number of",
    "content_length": 2751
  },
  {
    "id": "stdtypes_chunk_10",
    "source_file": "stdtypes",
    "chunk_index": 10,
    "content": "documentation Some sequence types (such as range) only support item sequences that follow specific patterns, and hence donât support sequence concatenation or repetition. An IndexError is raised if i is outside the sequence range. Sequence Methods Sequence types also support the following methods: sequence.count(value, /)Â¶ Return the total number of occurrences of value in sequence. sequence.index(value[, start[, stop])Â¶ Return the index of the first occurrence of value in sequence. Raises ValueError if value is not found in sequence. The start or stop arguments allow for efficient searching of subsections of the sequence, beginning at start and ending at stop. This is roughly equivalent to start + sequence[start:stop].index(value), only without copying any data. Caution Not all sequence types support passing the start and stop arguments. Immutable Sequence TypesÂ¶ The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the hash() built-in. This support allows immutable sequences, such as tuple instances, to be used as dict keys and stored in set and frozenset instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError. Mutable Sequence TypesÂ¶ The operations in the following table are defined on mutable sequence types. The collections.abc.MutableSequence ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray only accepts integers that meet the value restriction 0 <= x <= 255). Operation Result Notes s[i] = x item i of s is replaced by x del s[i] removes item i of s s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] removes the elements of s[i:j] from the list (same as s[i:j] = []) s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (2) Notes: If k is not equal to 1, t must have the same length as the slice it is replacing. The value n is an integer, or an object implementing __index__(). Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n under Common Sequence Operations. Mutable Sequence Methods Mutable sequence types also support the following methods: sequence.append(value, /)Â¶ Append value to the end of the sequence This is equivalent to writing seq[len(seq):len(seq)] = [value]. sequence.clear()Â¶ Added in version 3.3. Remove all items from sequence. This is equivalent to writing del sequence[:]. sequence.copy()Â¶ Added in version 3.3. Create a shallow copy of sequence. This",
    "content_length": 3051
  },
  {
    "id": "stdtypes_chunk_11",
    "source_file": "stdtypes",
    "chunk_index": 11,
    "content": "the following methods: sequence.append(value, /)Â¶ Append value to the end of the sequence This is equivalent to writing seq[len(seq):len(seq)] = [value]. sequence.clear()Â¶ Added in version 3.3. Remove all items from sequence. This is equivalent to writing del sequence[:]. sequence.copy()Â¶ Added in version 3.3. Create a shallow copy of sequence. This is equivalent to writing sequence[:]. Hint The copy() method is not part of the MutableSequence ABC, but most concrete mutable sequence types provide it. sequence.extend(iterable, /)Â¶ Extend sequence with the contents of iterable. For the most part, this is the same as writing seq[len(seq):len(seq)] = iterable. sequence.insert(index, value, /)Â¶ Insert value into sequence at the given index. This is equivalent to writing sequence[index:index] = [value]. sequence.pop(index=-1, /)Â¶ Retrieve the item at index and also removes it from sequence. By default, the last item in sequence is removed and returned. sequence.remove(value, /)Â¶ Remove the first item from sequence where sequence[i] == value. Raises ValueError if value is not found in sequence. sequence.reverse()Â¶ Reverse the items of sequence in place. This method maintains economy of space when reversing a large sequence. To remind users that it operates by side-effect, it returns None. ListsÂ¶ Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). class list(iterable=(), /)Â¶ Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a], [a, b, c] Using a list comprehension: [x for x in iterable] Using the type constructor: list() or list(iterable) The constructor builds a list whose items are the same and in the same order as iterableâs items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For example, list('abc') returns ['a', 'b', 'c'] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, the constructor creates a new empty list, []. Many other operations also produce lists, including the sorted() built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: sort(*, key=None, reverse=False)Â¶ This method sorts the list in place, using only < comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). sort() accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, key=str.lower). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function.",
    "content_length": 3239
  },
  {
    "id": "stdtypes_chunk_12",
    "source_file": "stdtypes",
    "chunk_index": 12,
    "content": "each item in the list is calculated once and then used for the entire sorting process. The default value of None means that list items are sorted directly without calculating a separate key value. The functools.cmp_to_key() utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use sorted() to explicitly request a new sorted list instance). The sort() method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal â this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises ValueError if it can detect that the list has been mutated during a sort. TuplesÂ¶ Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a set or dict instance). class tuple(iterable=(), /)Â¶ Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Using the tuple() built-in: tuple() or tuple(iterable) The constructor builds a tuple whose items are the same and in the same order as iterableâs items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, tuple('abc') returns ('a', 'b', 'c') and tuple( [1, 2, 3] ) returns (1, 2, 3). If no argument is given, the constructor creates a new empty tuple, (). Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, f(a, b, c) is a function call with three arguments, while f((a, b, c)) is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, collections.namedtuple() may be a more appropriate choice than a simple tuple object. RangesÂ¶ The range type represents an immutable sequence of numbers and is commonly used",
    "content_length": 2963
  },
  {
    "id": "stdtypes_chunk_13",
    "source_file": "stdtypes",
    "chunk_index": 13,
    "content": "argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, collections.namedtuple() may be a more appropriate choice than a simple tuple object. RangesÂ¶ The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. class range(stop, /)Â¶ class range(start, stop, step=1, /) The arguments to the range constructor must be integers (either built-in int or any object that implements the __index__() special method). If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive step, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop. For a negative step, the contents of the range are still determined by the formula r[i] = start + step*i, but the constraints are i >= 0 and r[i] > stop. A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than sys.maxsize are permitted but some features (such as len()) may raise OverflowError. Range examples: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> list(range(0, 30, 5)) [0, 5, 10, 15, 20, 25] >>> list(range(0, 10, 3)) [0, 3, 6, 9] >>> list(range(0, -10, -1)) [0, -1, -2, -3, -4, -5, -6, -7, -8, -9] >>> list(range(0)) [] >>> list(range(1, 0)) [] Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). startÂ¶ The value of the start parameter (or 0 if the parameter was not supplied) stopÂ¶ The value of the stop parameter stepÂ¶ The value of the step parameter (or 1 if the parameter was not supplied) The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). Range objects implement the collections.abc.Sequence ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types â list, tuple, range): >>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r.index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and != compares them as sequences. That is,",
    "content_length": 2872
  },
  {
    "id": "stdtypes_chunk_14",
    "source_file": "stdtypes",
    "chunk_index": 14,
    "content": ">>> r = range(0, 20, 2) >>> r range(0, 20, 2) >>> 11 in r False >>> 10 in r True >>> r.index(10) 5 >>> r[5] 10 >>> r[:5] range(0, 10, 2) >>> r[-1] 18 Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start, stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2).) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test int objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define â==â and â!=â to compare range objects based on the sequence of values they define (instead of comparing based on object identity). Added the start, stop and step attributes. See also The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications. Text Sequence Type â strÂ¶ Textual data in Python is handled with str objects, or strings. Strings are immutable sequences of Unicode code points. String literals are written in a variety of ways: Single quotes: 'allows embedded \"double\" quotes' Double quotes: \"allows embedded 'single' quotes\" Triple quoted: '''Three single quotes''', \"\"\"Three double quotes\"\"\" Triple quoted strings may span multiple lines - all associated whitespace will be included in the string literal. String literals that are part of a single expression and have only whitespace between them will be implicitly converted to a single string literal. That is, (\"spam \" \"eggs\") == \"spam eggs\". See String and Bytes literals for more about the various forms of string literal, including supported escape sequences, and the r (ârawâ) prefix that disables most escape sequence processing. Strings may also be created from other objects using the str constructor. Since there is no separate âcharacterâ type, indexing a string produces strings of length 1. That is, for a non-empty string s, s[0] == s[0:1]. There is also no mutable string type, but str.join() or io.StringIO can be used to efficiently construct strings from multiple fragments. Changed in version 3.3: For backwards compatibility with the Python 2 series, the u prefix is once again permitted on string literals. It has no effect on the meaning of string literals and cannot be combined with the r prefix. class str(*, encoding='utf-8', errors='strict')Â¶ class str(object) class str(object, encoding, errors='strict') class str(object, *, errors) Return a string version of object. If object is not provided, returns the empty string. Otherwise, the behavior of str() depends on whether encoding or errors is given, as follows. If neither encoding nor errors is given, str(object) returns type(object).__str__(object), which is the âinformalâ or nicely printable string representation of object. For string objects, this is the string itself. If object does not have a __str__() method, then str() falls back to returning repr(object). If at least one of encoding or errors",
    "content_length": 3138
  },
  {
    "id": "stdtypes_chunk_15",
    "source_file": "stdtypes",
    "chunk_index": 15,
    "content": "encoding nor errors is given, str(object) returns type(object).__str__(object), which is the âinformalâ or nicely printable string representation of object. For string objects, this is the string itself. If object does not have a __str__() method, then str() falls back to returning repr(object). If at least one of encoding or errors is given, object should be a bytes-like object (e.g. bytes or bytearray). In this case, if object is a bytes (or bytearray) object, then str(bytes, encoding, errors) is equivalent to bytes.decode(encoding, errors). Otherwise, the bytes object underlying the buffer object is obtained before calling bytes.decode(). See Binary Sequence Types â bytes, bytearray, memoryview and Buffer Protocol for information on buffer objects. Passing a bytes object to str() without the encoding or errors arguments falls under the first case of returning the informal string representation (see also the -b command-line option to Python). For example: >>> str(b'Zoot!') \"b'Zoot!'\" For more information on the str class and its methods, see Text Sequence Type â str and the String Methods section below. To output formatted strings, see the f-strings and Format String Syntax sections. In addition, see the Text Processing Services section. String MethodsÂ¶ Strings implement all of the common sequence operations, along with the additional methods described below. Strings also support two styles of string formatting, one providing a large degree of flexibility and customization (see str.format(), Format String Syntax and Custom String Formatting) and the other based on C printf style formatting that handles a narrower range of types and is slightly harder to use correctly, but is often faster for the cases it can handle (printf-style String Formatting). The Text Processing Services section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the re module). str.capitalize()Â¶ Return a copy of the string with its first character capitalized and the rest lowercased. Changed in version 3.8: The first character is now put into titlecase rather than uppercase. This means that characters like digraphs will only have their first letter capitalized, instead of the full character. str.casefold()Â¶ Return a casefolded copy of the string. Casefolded strings may be used for caseless matching. Casefolding is similar to lowercasing but more aggressive because it is intended to remove all case distinctions in a string. For example, the German lowercase letter 'Ã' is equivalent to \"ss\". Since it is already lowercase, lower() would do nothing to 'Ã'; casefold() converts it to \"ss\". The casefolding algorithm is described in section 3.13 âDefault Case Foldingâ of the Unicode Standard. Added in version 3.3. str.center(width, fillchar=' ', /)Â¶ Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). For example: >>> 'Python'.center(10) ' Python ' >>> 'Python'.center(10, '-') '--Python--' >>> 'Python'.center(4) 'Python' str.count(sub[, start[, end]])Â¶ Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start",
    "content_length": 3340
  },
  {
    "id": "stdtypes_chunk_16",
    "source_file": "stdtypes",
    "chunk_index": 16,
    "content": "ASCII space). The original string is returned if width is less than or equal to len(s). For example: >>> 'Python'.center(10) ' Python ' >>> 'Python'.center(10, '-') '--Python--' >>> 'Python'.center(4) 'Python' str.count(sub[, start[, end]])Â¶ Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. If sub is empty, returns the number of empty strings between characters which is the length of the string plus one. For example: >>> 'spam, spam, spam'.count('spam') 3 >>> 'spam, spam, spam'.count('spam', 5) 2 >>> 'spam, spam, spam'.count('spam', 5, 10) 1 >>> 'spam, spam, spam'.count('eggs') 0 >>> 'spam, spam, spam'.count('') 17 str.encode(encoding='utf-8', errors='strict')Â¶ Return the string encoded to bytes. encoding defaults to 'utf-8'; see Standard Encodings for possible values. errors controls how encoding errors are handled. If 'strict' (the default), a UnicodeError exception is raised. Other possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and any other name registered via codecs.register_error(). See Error Handlers for details. For performance reasons, the value of errors is not checked for validity unless an encoding error actually occurs, Python Development Mode is enabled or a debug build is used. For example: >>> encoded_str_to_bytes = 'Python'.encode() >>> type(encoded_str_to_bytes) <class 'bytes'> >>> encoded_str_to_bytes b'Python' Changed in version 3.1: Added support for keyword arguments. Changed in version 3.9: The value of the errors argument is now checked in Python Development Mode and in debug mode. str.endswith(suffix[, start[, end]])Â¶ Return True if the string ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. Using start and end is equivalent to str[start:end].endswith(suffix). For example: >>> 'Python'.endswith('on') True >>> 'a tuple of suffixes'.endswith(('at', 'in')) False >>> 'a tuple of suffixes'.endswith(('at', 'es')) True >>> 'Python is amazing'.endswith('is', 0, 9) True See also startswith() and removesuffix(). str.expandtabs(tabsize=8)Â¶ Return a copy of the string where all tab characters are replaced by one or more spaces, depending on the current column and the given tab size. Tab positions occur every tabsize characters (default is 8, giving tab positions at columns 0, 8, 16 and so on). To expand the string, the current column is set to zero and the string is examined character by character. If the character is a tab (\\t), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the character is a newline (\\n) or return (\\r), it is copied and the current column is reset to zero. Any other character is copied unchanged and the current column is incremented by one regardless of how the character is represented when printed. For example: >>> '01\\t012\\t0123\\t01234'.expandtabs() '01 012 0123 01234' >>> '01\\t012\\t0123\\t01234'.expandtabs(4) '01 012 0123 01234' >>> print('01\\t012\\n0123\\t01234'.expandtabs(4)) 01 012 0123 01234 str.find(sub[, start[, end]])Â¶ Return the lowest index in the string where substring sub is found within the",
    "content_length": 3420
  },
  {
    "id": "stdtypes_chunk_17",
    "source_file": "stdtypes",
    "chunk_index": 17,
    "content": "is incremented by one regardless of how the character is represented when printed. For example: >>> '01\\t012\\t0123\\t01234'.expandtabs() '01 012 0123 01234' >>> '01\\t012\\t0123\\t01234'.expandtabs(4) '01 012 0123 01234' >>> print('01\\t012\\n0123\\t01234'.expandtabs(4)) 01 012 0123 01234 str.find(sub[, start[, end]])Â¶ Return the lowest index in the string where substring sub is found within the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. For example: >>> 'spam, spam, spam'.find('sp') 0 >>> 'spam, spam, spam'.find('sp', 5) 6 See also rfind() and index(). Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> 'Py' in 'Python' True str.format(*args, **kwargs)Â¶ Perform a string formatting operation. The string on which this method is called can contain literal text or replacement fields delimited by braces {}. Each replacement field contains either the numeric index of a positional argument, or the name of a keyword argument. Returns a copy of the string where each replacement field is replaced with the string value of the corresponding argument. >>> \"The sum of 1 + 2 is {0}\".format(1+2) 'The sum of 1 + 2 is 3' See Format String Syntax for a description of the various formatting options that can be specified in format strings. Note When formatting a number (int, float, complex, decimal.Decimal and subclasses) with the n type (ex: '{:n}'.format(1234)), the function temporarily sets the LC_CTYPE locale to the LC_NUMERIC locale to decode decimal_point and thousands_sep fields of localeconv() if they are non-ASCII or longer than 1 byte, and the LC_NUMERIC locale is different than the LC_CTYPE locale. This temporary change affects other threads. Changed in version 3.7: When formatting a number with the n type, the function sets temporarily the LC_CTYPE locale to the LC_NUMERIC locale in some cases. str.format_map(mapping, /)Â¶ Similar to str.format(**mapping), except that mapping is used directly and not copied to a dict. This is useful if for example mapping is a dict subclass: >>> class Default(dict): ... def __missing__(self, key): ... return key ... >>> '{name} was born in {country}'.format_map(Default(name='Guido')) 'Guido was born in country' Added in version 3.2. str.index(sub[, start[, end]])Â¶ Like find(), but raise ValueError when the substring is not found. str.isalnum()Â¶ Return True if all characters in the string are alphanumeric and there is at least one character, False otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric(). str.isalpha()Â¶ Return True if all characters in the string are alphabetic and there is at least one character, False otherwise. Alphabetic characters are those characters defined in the Unicode character database as âLetterâ, i.e., those with general category property being one of âLmâ, âLtâ, âLuâ, âLlâ, or âLoâ. Note that this is different from the Alphabetic property defined in the section 4.10 âLetters, Alphabetic, and Ideographicâ of the Unicode Standard. str.isascii()Â¶ Return True if the string is empty or all characters in the string",
    "content_length": 3300
  },
  {
    "id": "stdtypes_chunk_18",
    "source_file": "stdtypes",
    "chunk_index": 18,
    "content": "those with general category property being one of âLmâ, âLtâ, âLuâ, âLlâ, or âLoâ. Note that this is different from the Alphabetic property defined in the section 4.10 âLetters, Alphabetic, and Ideographicâ of the Unicode Standard. str.isascii()Â¶ Return True if the string is empty or all characters in the string are ASCII, False otherwise. ASCII characters have code points in the range U+0000-U+007F. Added in version 3.7. str.isdecimal()Â¶ Return True if all characters in the string are decimal characters and there is at least one character, False otherwise. Decimal characters are those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT ZERO. Formally a decimal character is a character in the Unicode General Category âNdâ. str.isdigit()Â¶ Return True if all characters in the string are digits and there is at least one character, False otherwise. Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. This covers digits which cannot be used to form numbers in base 10, like the Kharosthi numbers. Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal. str.isidentifier()Â¶ Return True if the string is a valid identifier according to the language definition, section Identifiers and keywords. keyword.iskeyword() can be used to test whether string s is a reserved identifier, such as def and class. Example: >>> from keyword import iskeyword >>> 'hello'.isidentifier(), iskeyword('hello') (True, False) >>> 'def'.isidentifier(), iskeyword('def') (True, True) str.islower()Â¶ Return True if all cased characters [4] in the string are lowercase and there is at least one cased character, False otherwise. str.isnumeric()Â¶ Return True if all characters in the string are numeric characters, and there is at least one character, False otherwise. Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric. str.isprintable()Â¶ Return True if all characters in the string are printable, False if it contains at least one non-printable character. Here âprintableâ means the character is suitable for repr() to use in its output; ânon-printableâ means that repr() on built-in types will hex-escape the character. It has no bearing on the handling of strings written to sys.stdout or sys.stderr. The printable characters are those which in the Unicode character database (see unicodedata) have a general category in group Letter, Mark, Number, Punctuation, or Symbol (L, M, N, P, or S); plus the ASCII space 0x20. Nonprintable characters are those in group Separator or Other (Z or C), except the ASCII space. str.isspace()Â¶ Return True if there are only whitespace characters in the string and there is at least one character, False otherwise. A character is whitespace if in the Unicode character database (see unicodedata), either its general category is Zs (âSeparator, spaceâ), or its bidirectional class is one of WS, B, or S. str.istitle()Â¶ Return True if the string is a titlecased string and there is at least one character, for example",
    "content_length": 3351
  },
  {
    "id": "stdtypes_chunk_19",
    "source_file": "stdtypes",
    "chunk_index": 19,
    "content": "A character is whitespace if in the Unicode character database (see unicodedata), either its general category is Zs (âSeparator, spaceâ), or its bidirectional class is one of WS, B, or S. str.istitle()Â¶ Return True if the string is a titlecased string and there is at least one character, for example uppercase characters may only follow uncased characters and lowercase characters only cased ones. Return False otherwise. str.isupper()Â¶ Return True if all cased characters [4] in the string are uppercase and there is at least one cased character, False otherwise. >>> 'BANANA'.isupper() True >>> 'banana'.isupper() False >>> 'baNana'.isupper() False >>> ' '.isupper() False str.join(iterable, /)Â¶ Return a string which is the concatenation of the strings in iterable. A TypeError will be raised if there are any non-string values in iterable, including bytes objects. The separator between elements is the string providing this method. str.ljust(width, fillchar=' ', /)Â¶ Return the string left justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.lower()Â¶ Return a copy of the string with all the cased characters [4] converted to lowercase. The lowercasing algorithm used is described in section 3.13 âDefault Case Foldingâ of the Unicode Standard. str.lstrip(chars=None, /)Â¶ Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: >>> ' spacious '.lstrip() 'spacious ' >>> 'www.example.com'.lstrip('cmowz.') 'example.com' See str.removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> 'Arthur: three!'.lstrip('Arthur: ') 'ee!' >>> 'Arthur: three!'.removeprefix('Arthur: ') 'three!' static str.maketrans(dict, /)Â¶ static str.maketrans(from, to, remove='', /) This static method returns a translation table usable for str.translate(). If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or None. Character keys will then be converted to ordinals. If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in from will be mapped to the character at the same position in to. If there is a third argument, it must be a string, whose characters will be mapped to None in the result. str.partition(sep, /)Â¶ Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /)Â¶ If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' Added in version 3.9. str.removesuffix(suffix, /)Â¶ If the",
    "content_length": 3342
  },
  {
    "id": "stdtypes_chunk_20",
    "source_file": "stdtypes",
    "chunk_index": 20,
    "content": "separator is not found, return a 3-tuple containing the string itself, followed by two empty strings. str.removeprefix(prefix, /)Â¶ If the string starts with the prefix string, return string[len(prefix):]. Otherwise, return a copy of the original string: >>> 'TestHook'.removeprefix('Test') 'Hook' >>> 'BaseTestCase'.removeprefix('Test') 'BaseTestCase' Added in version 3.9. str.removesuffix(suffix, /)Â¶ If the string ends with the suffix string and that suffix is not empty, return string[:-len(suffix)]. Otherwise, return a copy of the original string: >>> 'MiscTests'.removesuffix('Tests') 'Misc' >>> 'TmpDirMixin'.removesuffix('Tests') 'TmpDirMixin' Added in version 3.9. str.replace(old, new, /, count=-1)Â¶ Return a copy of the string with all occurrences of substring old replaced by new. If count is given, only the first count occurrences are replaced. If count is not specified or -1, then all occurrences are replaced. Changed in version 3.13: count is now supported as a keyword argument. str.rfind(sub[, start[, end]])Â¶ Return the highest index in the string where substring sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. str.rindex(sub[, start[, end]])Â¶ Like rfind() but raises ValueError when the substring sub is not found. str.rjust(width, fillchar=' ', /)Â¶ Return the string right justified in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s). str.rpartition(sep, /)Â¶ Split the string at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty strings, followed by the string itself. str.rsplit(sep=None, maxsplit=-1)Â¶ Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any whitespace string is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. str.rstrip(chars=None, /)Â¶ Return a copy of the string with trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a suffix; rather, all combinations of its values are stripped: >>> ' spacious '.rstrip() ' spacious' >>> 'mississippi'.rstrip('ipz') 'mississ' See str.removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> 'Monty Python'.rstrip(' Python') 'M' >>> 'Monty Python'.removesuffix(' Python') 'Monty' str.split(sep=None, maxsplit=-1)Â¶ Return a list of the words in the string, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed",
    "content_length": 3310
  },
  {
    "id": "stdtypes_chunk_21",
    "source_file": "stdtypes",
    "chunk_index": 21,
    "content": "at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']). The sep argument may consist of multiple characters as a single delimiter (to split with multiple delimiters, use re.split()). Splitting an empty string with a specified separator returns ['']. For example: >>> '1,2,3'.split(',') ['1', '2', '3'] >>> '1,2,3'.split(',', maxsplit=1) ['1', '2,3'] >>> '1,2,,3,'.split(',') ['1', '2', '', '3', ''] >>> '1<>2<>3<4'.split('<>') ['1', '2', '3<4'] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a None separator returns []. For example: >>> '1 2 3'.split() ['1', '2', '3'] >>> '1 2 3'.split(maxsplit=1) ['1', '2 3'] >>> ' 1 2 3 '.split() ['1', '2', '3'] If sep is not specified or is None and maxsplit is 0, only leading runs of consecutive whitespace are considered. For example: >>> \"\".split(None, 0) [] >>> \" \".split(None, 0) [] >>> \" foo \".split(maxsplit=0) ['foo '] str.splitlines(keepends=False)Â¶ Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. This method splits on the following line boundaries. In particular, the boundaries are a superset of universal newlines. Representation Description \\n Line Feed \\r Carriage Return \\r\\n Carriage Return + Line Feed \\v or \\x0b Line Tabulation \\f or \\x0c Form Feed \\x1c File Separator \\x1d Group Separator \\x1e Record Separator \\x85 Next Line (C1 Control Code) \\u2028 Line Separator \\u2029 Paragraph Separator Changed in version 3.2: \\v and \\f added to list of line boundaries. For example: >>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines() ['ab c', '', 'de fg', 'kl'] >>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True) ['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n'] Unlike split() when a delimiter string sep is given, this method returns an empty list for the empty string, and a terminal line break does not result in an extra line: >>> \"\".splitlines() [] >>> \"One line\\n\".splitlines() ['One line'] For comparison, split('\\n') gives: >>> ''.split('\\n') [''] >>> 'Two lines\\n'.split('\\n') ['Two lines', ''] str.startswith(prefix[, start[, end]])Â¶ Return True if string starts with the prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test string beginning at that position. With optional end, stop comparing string at that position. str.strip(chars=None, /)Â¶ Return a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing",
    "content_length": 3186
  },
  {
    "id": "stdtypes_chunk_22",
    "source_file": "stdtypes",
    "chunk_index": 22,
    "content": "that position. With optional end, stop comparing string at that position. str.strip(chars=None, /)Â¶ Return a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> ' spacious '.strip() 'spacious' >>> 'www.example.com'.strip('cmowz.') 'example' The outermost leading and trailing chars argument values are stripped from the string. Characters are removed from the leading end until reaching a string character that is not contained in the set of characters in chars. A similar action takes place on the trailing end. For example: >>> comment_string = '#....... Section 3.2.1 Issue #32 .......' >>> comment_string.strip('.#! ') 'Section 3.2.1 Issue #32' str.swapcase()Â¶ Return a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s. str.title()Â¶ Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase. For example: >>> 'Hello world'.title() 'Hello World' The algorithm uses a simple language-independent definition of a word as groups of consecutive letters. The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result: >>> \"they're bill's friends from the UK\".title() \"They'Re Bill'S Friends From The Uk\" The string.capwords() function does not have this problem, as it splits words on spaces only. Alternatively, a workaround for apostrophes can be constructed using regular expressions: >>> import re >>> def titlecase(s): ... return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\", ... lambda mo: mo.group(0).capitalize(), ... s) ... >>> titlecase(\"they're bill's friends.\") \"They're Bill's Friends.\" str.translate(table, /)Â¶ Return a copy of the string in which each character has been mapped through the given translation table. The table must be an object that implements indexing via __getitem__(), typically a mapping or sequence. When indexed by a Unicode ordinal (an integer), the table object can do any of the following: return a Unicode ordinal or a string, to map the character to one or more other characters; return None, to delete the character from the return string; or raise a LookupError exception, to map the character to itself. You can use str.maketrans() to create a translation map from character-to-character mappings in different formats. See also the codecs module for a more flexible approach to custom character mappings. str.upper()Â¶ Return a copy of the string with all the cased characters [4] converted to uppercase. Note that s.upper().isupper() might be False if s contains uncased characters or if the Unicode category of the resulting character(s) is not âLuâ (Letter, uppercase), but e.g. âLtâ (Letter, titlecase). The uppercasing algorithm used is described in section 3.13 âDefault Case Foldingâ of the Unicode Standard. str.zfill(width, /)Â¶ Return a copy of the string left filled with ASCII '0' digits to make a string of length width. A",
    "content_length": 3327
  },
  {
    "id": "stdtypes_chunk_23",
    "source_file": "stdtypes",
    "chunk_index": 23,
    "content": "resulting character(s) is not âLuâ (Letter, uppercase), but e.g. âLtâ (Letter, titlecase). The uppercasing algorithm used is described in section 3.13 âDefault Case Foldingâ of the Unicode Standard. str.zfill(width, /)Â¶ Return a copy of the string left filled with ASCII '0' digits to make a string of length width. A leading sign prefix ('+'/'-') is handled by inserting the padding after the sign character rather than before. The original string is returned if width is less than or equal to len(s). For example: >>> \"42\".zfill(5) '00042' >>> \"-42\".zfill(5) '-0042' Formatted String Literals (f-strings)Â¶ Added in version 3.6. Changed in version 3.7: The await and async for can be used in expressions within f-strings. Changed in version 3.8: Added the debugging operator (=) Changed in version 3.12: Many restrictions on expressions within f-strings have been removed. Notably, nested strings, comments, and backslashes are now permitted. An f-string (formally a formatted string literal) is a string literal that is prefixed with f or F. This type of string literal allows embedding arbitrary Python expressions within replacement fields, which are delimited by curly brackets ({}). These expressions are evaluated at runtime, similarly to str.format(), and are converted into regular str objects. For example: >>> who = 'nobody' >>> nationality = 'Spanish' >>> f'{who.title()} expects the {nationality} Inquisition!' 'Nobody expects the Spanish Inquisition!' It is also possible to use a multi line f-string: >>> f'''This is a string ... on two lines''' 'This is a string\\non two lines' A single opening curly bracket, '{', marks a replacement field that can contain any Python expression: >>> nationality = 'Spanish' >>> f'The {nationality} Inquisition!' 'The Spanish Inquisition!' To include a literal { or }, use a double bracket: >>> x = 42 >>> f'{{x}} is {x}' '{x} is 42' Functions can also be used, and format specifiers: >>> from math import sqrt >>> f'â2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}' 'â2 â 1.41421' Any non-string expression is converted using str(), by default: >>> from fractions import Fraction >>> f'{Fraction(1, 3)}' '1/3' To use an explicit conversion, use the ! (exclamation mark) operator, followed by any of the valid formats, which are: Conversion Meaning !a ascii() !r repr() !s str() For example: >>> from fractions import Fraction >>> f'{Fraction(1, 3)!s}' '1/3' >>> f'{Fraction(1, 3)!r}' 'Fraction(1, 3)' >>> question = 'Â¿DÃ³nde estÃ¡ el Presidente?' >>> print(f'{question!a}') '\\xbfD\\xf3nde est\\xe1 el Presidente?' While debugging it may be helpful to see both the expression and its value, by using the equals sign (=) after the expression. This preserves spaces within the brackets, and can be used with a converter. By default, the debugging operator uses the repr() (!r) conversion. For example: >>> from fractions import Fraction >>> calculation = Fraction(1, 3) >>> f'{calculation=}' 'calculation=Fraction(1, 3)' >>> f'{calculation = }' 'calculation = Fraction(1, 3)' >>> f'{calculation = !s}' 'calculation = 1/3' Once the output has been evaluated, it can be formatted using a format specifier following a colon (':'). After the expression has been evaluated, and possibly converted to a string, the __format__() method",
    "content_length": 3283
  },
  {
    "id": "stdtypes_chunk_24",
    "source_file": "stdtypes",
    "chunk_index": 24,
    "content": "'calculation=Fraction(1, 3)' >>> f'{calculation = }' 'calculation = Fraction(1, 3)' >>> f'{calculation = !s}' 'calculation = 1/3' Once the output has been evaluated, it can be formatted using a format specifier following a colon (':'). After the expression has been evaluated, and possibly converted to a string, the __format__() method of the result is called with the format specifier, or the empty string if no format specifier is given. The formatted result is then used as the final value for the replacement field. For example: >>> from fractions import Fraction >>> f'{Fraction(1, 7):.6f}' '0.142857' >>> f'{Fraction(1, 7):_^+10}' '___+1/7___' printf-style String FormattingÂ¶ Note The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). Using the newer formatted string literals, the str.format() interface, or template strings may help avoid these errors. Each of these alternatives provides their own trade-offs and benefits of simplicity, flexibility, and/or extensibility. String objects have one unique built-in operation: the % operator (modulo). This is also known as the string formatting or interpolation operator. Given format % values (where format is a string), % conversion specifications in format are replaced with zero or more elements of values. The effect is similar to using the sprintf() function in the C language. For example: >>> print('%s has %d quote types.' % ('Python', 2)) Python has 2 quote types. If format requires a single argument, values may be a single non-tuple object. [5] Otherwise, values must be a tuple with exactly the number of items specified by the format string, or a single mapping object (for example, a dictionary). A conversion specifier contains two or more characters and has the following components, which must occur in this order: The '%' character, which marks the start of the specifier. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)). Conversion flags (optional), which affect the result of some conversion types. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next element of the tuple in values, and the object to convert comes after the minimum field width and optional precision. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an asterisk), the actual precision is read from the next element of the tuple in values, and the value to convert comes after the precision. Length modifier (optional). Conversion type. When the right argument is a dictionary (or other mapping type), then the formats in the string must include a parenthesised mapping key into that dictionary inserted immediately after the '%' character. The mapping key selects the value to be formatted from the mapping. For example: >>> print('%(language)s has %(number)03d quote types.' % ... {'language': \"Python\", \"number\": 2}) Python has 002 quote types. In this case no * specifiers may occur in a format (since they require a sequential parameter list). The conversion flag characters are: Flag Meaning '#'",
    "content_length": 3217
  },
  {
    "id": "stdtypes_chunk_25",
    "source_file": "stdtypes",
    "chunk_index": 25,
    "content": "be formatted from the mapping. For example: >>> print('%(language)s has %(number)03d quote types.' % ... {'language': \"Python\", \"number\": 2}) Python has 002 quote types. In this case no * specifiers may occur in a format (since they require a sequential parameter list). The conversion flag characters are: Flag Meaning '#' The value conversion will use the âalternate formâ (where defined below). '0' The conversion will be zero padded for numeric values. '-' The converted value is left adjusted (overrides the '0' conversion if both are given). ' ' (a space) A blank should be left before a positive number (or empty string) produced by a signed conversion. '+' A sign character ('+' or '-') will precede the conversion (overrides a âspaceâ flag). A length modifier (h, l, or L) may be present, but is ignored as it is not necessary for Python â so e.g. %ld is identical to %d. The conversion types are: Conversion Meaning Notes 'd' Signed integer decimal. 'i' Signed integer decimal. 'o' Signed octal value. (1) 'u' Obsolete type â it is identical to 'd'. (6) 'x' Signed hexadecimal (lowercase). (2) 'X' Signed hexadecimal (uppercase). (2) 'e' Floating-point exponential format (lowercase). (3) 'E' Floating-point exponential format (uppercase). (3) 'f' Floating-point decimal format. (3) 'F' Floating-point decimal format. (3) 'g' Floating-point format. Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. (4) 'G' Floating-point format. Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. (4) 'c' Single character (accepts integer or single character string). 'r' String (converts any Python object using repr()). (5) 's' String (converts any Python object using str()). (5) 'a' String (converts any Python object using ascii()). (5) '%' No argument is converted, results in a '%' character in the result. Notes: The alternate form causes a leading octal specifier ('0o') to be inserted before the first digit. The alternate form causes a leading '0x' or '0X' (depending on whether the 'x' or 'X' format was used) to be inserted before the first digit. The alternate form causes the result to always contain a decimal point, even if no digits follow it. The precision determines the number of digits after the decimal point and defaults to 6. The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be. The precision determines the number of significant digits before and after the decimal point and defaults to 6. If precision is N, the output is truncated to N characters. See PEP 237. Since Python strings have an explicit length, %s conversions do not assume that '\\0' is the end of the string. Changed in version 3.1: %f conversions for numbers whose absolute value is over 1e50 are no longer replaced by %g conversions. Binary Sequence Types â bytes, bytearray, memoryviewÂ¶ The core built-in types for manipulating binary data are bytes and bytearray. They are supported by",
    "content_length": 3103
  },
  {
    "id": "stdtypes_chunk_26",
    "source_file": "stdtypes",
    "chunk_index": 26,
    "content": "is the end of the string. Changed in version 3.1: %f conversions for numbers whose absolute value is over 1e50 are no longer replaced by %g conversions. Binary Sequence Types â bytes, bytearray, memoryviewÂ¶ The core built-in types for manipulating binary data are bytes and bytearray. They are supported by memoryview which uses the buffer protocol to access the memory of other binary objects without needing to make a copy. The array module supports efficient storage of basic data types like 32-bit integers and IEEE754 double-precision floating values. Bytes ObjectsÂ¶ Bytes objects are immutable sequences of single bytes. Since many major binary protocols are based on the ASCII text encoding, bytes objects offer several methods that are only valid when working with ASCII compatible data and are closely related to string objects in a variety of other ways. class bytes(source=b'')Â¶ class bytes(source, encoding, errors='strict') Firstly, the syntax for bytes literals is largely the same as that for string literals, except that a b prefix is added: Single quotes: b'still allows embedded \"double\" quotes' Double quotes: b\"still allows embedded 'single' quotes\" Triple quoted: b'''3 single quotes''', b\"\"\"3 double quotes\"\"\" Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence. As with string literals, bytes literals may also use a r prefix to disable processing of escape sequences. See String and Bytes literals for more about the various forms of bytes literal, including supported escape sequences. While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that 0 <= x < 256 (attempts to violate this restriction will trigger ValueError). This is done deliberately to emphasise that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption). In addition to the literal forms, bytes objects can be created in a number of other ways: A zero-filled bytes object of a specified length: bytes(10) From an iterable of integers: bytes(range(20)) Copying existing binary data via the buffer protocol: bytes(obj) Also see the bytes built-in. Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal numbers are a commonly used format for describing binary data. Accordingly, the bytes type has an additional class method to read data in that format: classmethod fromhex(string, /)Â¶ This bytes class method returns a bytes object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored. >>> bytes.fromhex('2Ef0 F1f2 ') b'.\\xf0\\xf1\\xf2' Changed in version 3.7: bytes.fromhex() now skips all ASCII whitespace in the string, not just spaces. A reverse conversion function exists to transform a bytes object into its hexadecimal representation. hex(*, bytes_per_sep=1)Â¶ hex(sep,",
    "content_length": 3312
  },
  {
    "id": "stdtypes_chunk_27",
    "source_file": "stdtypes",
    "chunk_index": 27,
    "content": "must contain two hexadecimal digits per byte, with ASCII whitespace being ignored. >>> bytes.fromhex('2Ef0 F1f2 ') b'.\\xf0\\xf1\\xf2' Changed in version 3.7: bytes.fromhex() now skips all ASCII whitespace in the string, not just spaces. A reverse conversion function exists to transform a bytes object into its hexadecimal representation. hex(*, bytes_per_sep=1)Â¶ hex(sep, bytes_per_sep=1) Return a string object containing two hexadecimal digits for each byte in the instance. >>> b'\\xf0\\xf1\\xf2'.hex() 'f0f1f2' If you want to make the hex string easier to read, you can specify a single character separator sep parameter to include in the output. By default, this separator will be included between each byte. A second optional bytes_per_sep parameter controls the spacing. Positive values calculate the separator position from the right, negative values from the left. >>> value = b'\\xf0\\xf1\\xf2' >>> value.hex('-') 'f0-f1-f2' >>> value.hex('_', 2) 'f0_f1f2' >>> b'UUDDLRLRAB'.hex(' ', -4) '55554444 4c524c52 4142' Added in version 3.5. Changed in version 3.8: bytes.hex() now supports optional sep and bytes_per_sep parameters to insert separators between bytes in the hex output. Since bytes objects are sequences of integers (akin to a tuple), for a bytes object b, b[0] will be an integer, while b[0:1] will be a bytes object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1) The representation of bytes objects uses the literal format (b'...') since it is often more useful than e.g. bytes([46, 46, 46]). You can always convert a bytes object into a list of integers using list(b). Bytearray ObjectsÂ¶ bytearray objects are a mutable counterpart to bytes objects. class bytearray(source=b'')Â¶ class bytearray(source, encoding, errors='strict') There is no dedicated literal syntax for bytearray objects, instead they are always created by calling the constructor: Creating an empty instance: bytearray() Creating a zero-filled instance with a given length: bytearray(10) From an iterable of integers: bytearray(range(20)) Copying existing binary data via the buffer protocol: bytearray(b'Hi!') As bytearray objects are mutable, they support the mutable sequence operations in addition to the common bytes and bytearray operations described in Bytes and Bytearray Operations. Also see the bytearray built-in. Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal numbers are a commonly used format for describing binary data. Accordingly, the bytearray type has an additional class method to read data in that format: classmethod fromhex(string, /)Â¶ This bytearray class method returns bytearray object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored. >>> bytearray.fromhex('2Ef0 F1f2 ') bytearray(b'.\\xf0\\xf1\\xf2') Changed in version 3.7: bytearray.fromhex() now skips all ASCII whitespace in the string, not just spaces. A reverse conversion function exists to transform a bytearray object into its hexadecimal representation. hex(*, bytes_per_sep=1)Â¶ hex(sep, bytes_per_sep=1) Return a string object containing two hexadecimal digits for each byte in the instance. >>> bytearray(b'\\xf0\\xf1\\xf2').hex() 'f0f1f2' Added in version 3.5. Changed in version 3.8: Similar to bytes.hex(), bytearray.hex() now supports optional sep and bytes_per_sep parameters to insert separators between bytes in the hex output. Since bytearray objects are sequences",
    "content_length": 3524
  },
  {
    "id": "stdtypes_chunk_28",
    "source_file": "stdtypes",
    "chunk_index": 28,
    "content": "Return a string object containing two hexadecimal digits for each byte in the instance. >>> bytearray(b'\\xf0\\xf1\\xf2').hex() 'f0f1f2' Added in version 3.5. Changed in version 3.8: Similar to bytes.hex(), bytearray.hex() now supports optional sep and bytes_per_sep parameters to insert separators between bytes in the hex output. Since bytearray objects are sequences of integers (akin to a list), for a bytearray object b, b[0] will be an integer, while b[0:1] will be a bytearray object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1) The representation of bytearray objects uses the bytes literal format (bytearray(b'...')) since it is often more useful than e.g. bytearray([46, 46, 46]). You can always convert a bytearray object into a list of integers using list(b). Bytes and Bytearray OperationsÂ¶ Both bytes and bytearray objects support the common sequence operations. They interoperate not just with operands of the same type, but with any bytes-like object. Due to this flexibility, they can be freely mixed in operations without causing errors. However, the return type of the result may depend on the order of operands. Note The methods on bytes and bytearray objects donât accept strings as their arguments, just as the methods on strings donât accept bytes as their arguments. For example, you have to write: a = \"abc\" b = a.replace(\"a\", \"f\") and: a = b\"abc\" b = a.replace(b\"a\", b\"f\") Some bytes and bytearray operations assume the use of ASCII compatible binary formats, and hence should be avoided when working with arbitrary binary data. These restrictions are covered below. Note Using these ASCII based operations to manipulate binary data that is not stored in an ASCII based format may lead to data corruption. The following methods on bytes and bytearray objects can be used with arbitrary binary data. bytes.count(sub[, start[, end]])Â¶ bytearray.count(sub[, start[, end]])Â¶ Return the number of non-overlapping occurrences of subsequence sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. If sub is empty, returns the number of empty slices between characters which is the length of the bytes object plus one. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. bytes.removeprefix(prefix, /)Â¶ bytearray.removeprefix(prefix, /)Â¶ If the binary data starts with the prefix string, return bytes[len(prefix):]. Otherwise, return a copy of the original binary data: >>> b'TestHook'.removeprefix(b'Test') b'Hook' >>> b'BaseTestCase'.removeprefix(b'Test') b'BaseTestCase' The prefix may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Added in version 3.9. bytes.removesuffix(suffix, /)Â¶ bytearray.removesuffix(suffix, /)Â¶ If the binary data ends with the suffix string and that suffix is not empty, return bytes[:-len(suffix)]. Otherwise, return a copy of the original binary data: >>> b'MiscTests'.removesuffix(b'Tests') b'Misc' >>> b'TmpDirMixin'.removesuffix(b'Tests') b'TmpDirMixin' The suffix may be any bytes-like object. Note",
    "content_length": 3321
  },
  {
    "id": "stdtypes_chunk_29",
    "source_file": "stdtypes",
    "chunk_index": 29,
    "content": "were made. Added in version 3.9. bytes.removesuffix(suffix, /)Â¶ bytearray.removesuffix(suffix, /)Â¶ If the binary data ends with the suffix string and that suffix is not empty, return bytes[:-len(suffix)]. Otherwise, return a copy of the original binary data: >>> b'MiscTests'.removesuffix(b'Tests') b'Misc' >>> b'TmpDirMixin'.removesuffix(b'Tests') b'TmpDirMixin' The suffix may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. Added in version 3.9. bytes.decode(encoding='utf-8', errors='strict')Â¶ bytearray.decode(encoding='utf-8', errors='strict')Â¶ Return the bytes decoded to a str. encoding defaults to 'utf-8'; see Standard Encodings for possible values. errors controls how decoding errors are handled. If 'strict' (the default), a UnicodeError exception is raised. Other possible values are 'ignore', 'replace', and any other name registered via codecs.register_error(). See Error Handlers for details. For performance reasons, the value of errors is not checked for validity unless a decoding error actually occurs, Python Development Mode is enabled or a debug build is used. Note Passing the encoding argument to str allows decoding any bytes-like object directly, without needing to make a temporary bytes or bytearray object. Changed in version 3.1: Added support for keyword arguments. Changed in version 3.9: The value of the errors argument is now checked in Python Development Mode and in debug mode. bytes.endswith(suffix[, start[, end]])Â¶ bytearray.endswith(suffix[, start[, end]])Â¶ Return True if the binary data ends with the specified suffix, otherwise return False. suffix can also be a tuple of suffixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. The suffix(es) to search for may be any bytes-like object. bytes.find(sub[, start[, end]])Â¶ bytearray.find(sub[, start[, end]])Â¶ Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the in operator: >>> b'Py' in b'Python' True Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. bytes.index(sub[, start[, end]])Â¶ bytearray.index(sub[, start[, end]])Â¶ Like find(), but raise ValueError when the subsequence is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. bytes.join(iterable, /)Â¶ bytearray.join(iterable, /)Â¶ Return a bytes or bytearray object which is the concatenation of the binary data sequences in iterable. A TypeError will be raised if there are any values in iterable that are not bytes-like objects, including str objects. The separator between elements is the contents of the bytes or bytearray object providing this method. static",
    "content_length": 3295
  },
  {
    "id": "stdtypes_chunk_30",
    "source_file": "stdtypes",
    "chunk_index": 30,
    "content": "bytearray object which is the concatenation of the binary data sequences in iterable. A TypeError will be raised if there are any values in iterable that are not bytes-like objects, including str objects. The separator between elements is the contents of the bytes or bytearray object providing this method. static bytes.maketrans(from, to, /)Â¶ static bytearray.maketrans(from, to, /)Â¶ This static method returns a translation table usable for bytes.translate() that will map each character in from into the character at the same position in to; from and to must both be bytes-like objects and have the same length. Added in version 3.1. bytes.partition(sep, /)Â¶ bytearray.partition(sep, /)Â¶ Split the sequence at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself or its bytearray copy, and the part after the separator. If the separator is not found, return a 3-tuple containing a copy of the original sequence, followed by two empty bytes or bytearray objects. The separator to search for may be any bytes-like object. bytes.replace(old, new, count=-1, /)Â¶ bytearray.replace(old, new, count=-1, /)Â¶ Return a copy of the sequence with all occurrences of subsequence old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. The subsequence to search for and its replacement may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.rfind(sub[, start[, end]])Â¶ bytearray.rfind(sub[, start[, end]])Â¶ Return the highest index in the sequence where the subsequence sub is found, such that sub is contained within s[start:end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. bytes.rindex(sub[, start[, end]])Â¶ bytearray.rindex(sub[, start[, end]])Â¶ Like rfind() but raises ValueError when the subsequence sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence. bytes.rpartition(sep, /)Â¶ bytearray.rpartition(sep, /)Â¶ Split the sequence at the last occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself or its bytearray copy, and the part after the separator. If the separator is not found, return a 3-tuple containing two empty bytes or bytearray objects, followed by a copy of the original sequence. The separator to search for may be any bytes-like object. bytes.startswith(prefix[, start[, end]])Â¶ bytearray.startswith(prefix[, start[, end]])Â¶ Return True if the binary data starts with the specified prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. The prefix(es) to search for may be",
    "content_length": 3191
  },
  {
    "id": "stdtypes_chunk_31",
    "source_file": "stdtypes",
    "chunk_index": 31,
    "content": "start[, end]])Â¶ Return True if the binary data starts with the specified prefix, otherwise return False. prefix can also be a tuple of prefixes to look for. With optional start, test beginning at that position. With optional end, stop comparing at that position. The prefix(es) to search for may be any bytes-like object. bytes.translate(table, /, delete=b'')Â¶ bytearray.translate(table, /, delete=b'')Â¶ Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument delete are removed, and the remaining bytes have been mapped through the given translation table, which must be a bytes object of length 256. You can use the bytes.maketrans() method to create a translation table. Set the table argument to None for translations that only delete characters: >>> b'read this short text'.translate(None, b'aeiou') b'rd ths shrt txt' Changed in version 3.6: delete is now supported as a keyword argument. The following methods on bytes and bytearray objects have default behaviours that assume the use of ASCII compatible binary formats, but can still be used with arbitrary binary data by passing appropriate arguments. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.center(width, fillbyte=b' ', /)Â¶ bytearray.center(width, fillbyte=b' ', /)Â¶ Return a copy of the object centered in a sequence of length width. Padding is done using the specified fillbyte (default is an ASCII space). For bytes objects, the original sequence is returned if width is less than or equal to len(s). Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.ljust(width, fillbyte=b' ', /)Â¶ bytearray.ljust(width, fillbyte=b' ', /)Â¶ Return a copy of the object left justified in a sequence of length width. Padding is done using the specified fillbyte (default is an ASCII space). For bytes objects, the original sequence is returned if width is less than or equal to len(s). Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.lstrip(bytes=None, /)Â¶ bytearray.lstrip(bytes=None, /)Â¶ Return a copy of the sequence with specified leading bytes removed. The bytes argument is a binary sequence specifying the set of byte values to be removed. If omitted or None, the bytes argument defaults to removing ASCII whitespace. The bytes argument is not a prefix; rather, all combinations of its values are stripped: >>> b' spacious '.lstrip() b'spacious ' >>> b'www.example.com'.lstrip(b'cmowz.') b'example.com' The binary sequence of byte values to remove may be any bytes-like object. See removeprefix() for a method that will remove a single prefix string rather than all of a set of characters. For example: >>> b'Arthur: three!'.lstrip(b'Arthur: ') b'ee!' >>> b'Arthur: three!'.removeprefix(b'Arthur: ') b'three!' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.rjust(width, fillbyte=b' ', /)Â¶ bytearray.rjust(width, fillbyte=b' ', /)Â¶ Return a copy of the object",
    "content_length": 3214
  },
  {
    "id": "stdtypes_chunk_32",
    "source_file": "stdtypes",
    "chunk_index": 32,
    "content": "example: >>> b'Arthur: three!'.lstrip(b'Arthur: ') b'ee!' >>> b'Arthur: three!'.removeprefix(b'Arthur: ') b'three!' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.rjust(width, fillbyte=b' ', /)Â¶ bytearray.rjust(width, fillbyte=b' ', /)Â¶ Return a copy of the object right justified in a sequence of length width. Padding is done using the specified fillbyte (default is an ASCII space). For bytes objects, the original sequence is returned if width is less than or equal to len(s). Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.rsplit(sep=None, maxsplit=-1)Â¶ bytearray.rsplit(sep=None, maxsplit=-1)Â¶ Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given, at most maxsplit splits are done, the rightmost ones. If sep is not specified or None, any subsequence consisting solely of ASCII whitespace is a separator. Except for splitting from the right, rsplit() behaves like split() which is described in detail below. bytes.rstrip(bytes=None, /)Â¶ bytearray.rstrip(bytes=None, /)Â¶ Return a copy of the sequence with specified trailing bytes removed. The bytes argument is a binary sequence specifying the set of byte values to be removed. If omitted or None, the bytes argument defaults to removing ASCII whitespace. The bytes argument is not a suffix; rather, all combinations of its values are stripped: >>> b' spacious '.rstrip() b' spacious' >>> b'mississippi'.rstrip(b'ipz') b'mississ' The binary sequence of byte values to remove may be any bytes-like object. See removesuffix() for a method that will remove a single suffix string rather than all of a set of characters. For example: >>> b'Monty Python'.rstrip(b' Python') b'M' >>> b'Monty Python'.removesuffix(b' Python') b'Monty' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.split(sep=None, maxsplit=-1)Â¶ bytearray.split(sep=None, maxsplit=-1)Â¶ Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1, then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2']). The sep argument may consist of a multibyte sequence as a single delimiter. Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. The sep argument may be any bytes-like object. For example: >>> b'1,2,3'.split(b',') [b'1', b'2', b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] >>> b'1<>2<>3<4'.split(b'<>') [b'1', b'2', b'3<4'] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty",
    "content_length": 3327
  },
  {
    "id": "stdtypes_chunk_33",
    "source_file": "stdtypes",
    "chunk_index": 33,
    "content": "b'3'] >>> b'1,2,3'.split(b',', maxsplit=1) [b'1', b'2,3'] >>> b'1,2,,3,'.split(b',') [b'1', b'2', b'', b'3', b''] >>> b'1<>2<>3<4'.split(b'<>') [b'1', b'2', b'3<4'] If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns []. For example: >>> b'1 2 3'.split() [b'1', b'2', b'3'] >>> b'1 2 3'.split(maxsplit=1) [b'1', b'2 3'] >>> b' 1 2 3 '.split() [b'1', b'2', b'3'] bytes.strip(bytes=None, /)Â¶ bytearray.strip(bytes=None, /)Â¶ Return a copy of the sequence with specified leading and trailing bytes removed. The bytes argument is a binary sequence specifying the set of byte values to be removed. If omitted or None, the bytes argument defaults to removing ASCII whitespace. The bytes argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b' spacious '.strip() b'spacious' >>> b'www.example.com'.strip(b'cmowz.') b'example' The binary sequence of byte values to remove may be any bytes-like object. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.capitalize()Â¶ bytearray.capitalize()Â¶ Return a copy of the sequence with each byte interpreted as an ASCII character, and the first byte capitalized and the rest lowercased. Non-ASCII byte values are passed through unchanged. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.expandtabs(tabsize=8)Â¶ bytearray.expandtabs(tabsize=8)Â¶ Return a copy of the sequence where all ASCII tab characters are replaced by one or more ASCII spaces, depending on the current column and the given tab size. Tab positions occur every tabsize bytes (default is 8, giving tab positions at columns 0, 8, 16 and so on). To expand the sequence, the current column is set to zero and the sequence is examined byte by byte. If the byte is an ASCII tab character (b'\\t'), one or more space characters are inserted in the result until the current column is equal to the next tab position. (The tab character itself is not copied.) If the current byte is an ASCII newline (b'\\n') or carriage return (b'\\r'), it is copied and the current column is reset to zero. Any other byte value is copied unchanged and the current column is incremented by one regardless of how the byte value is represented when printed: >>> b'01\\t012\\t0123\\t01234'.expandtabs() b'01 012 0123 01234' >>> b'01\\t012\\t0123\\t01234'.expandtabs(4) b'01 012 0123 01234' Note The bytearray version of this method does not operate in place - it",
    "content_length": 3165
  },
  {
    "id": "stdtypes_chunk_34",
    "source_file": "stdtypes",
    "chunk_index": 34,
    "content": "other byte value is copied unchanged and the current column is incremented by one regardless of how the byte value is represented when printed: >>> b'01\\t012\\t0123\\t01234'.expandtabs() b'01 012 0123 01234' >>> b'01\\t012\\t0123\\t01234'.expandtabs(4) b'01 012 0123 01234' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.isalnum()Â¶ bytearray.isalnum()Â¶ Return True if all bytes in the sequence are alphabetical ASCII characters or ASCII decimal digits and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'. ASCII decimal digits are those byte values in the sequence b'0123456789'. For example: >>> b'ABCabc1'.isalnum() True >>> b'ABC abc1'.isalnum() False bytes.isalpha()Â¶ bytearray.isalpha()Â¶ Return True if all bytes in the sequence are alphabetic ASCII characters and the sequence is not empty, False otherwise. Alphabetic ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'. For example: >>> b'ABCabc'.isalpha() True >>> b'ABCabc1'.isalpha() False bytes.isascii()Â¶ bytearray.isascii()Â¶ Return True if the sequence is empty or all bytes in the sequence are ASCII, False otherwise. ASCII bytes are in the range 0-0x7F. Added in version 3.7. bytes.isdigit()Â¶ bytearray.isdigit()Â¶ Return True if all bytes in the sequence are ASCII decimal digits and the sequence is not empty, False otherwise. ASCII decimal digits are those byte values in the sequence b'0123456789'. For example: >>> b'1234'.isdigit() True >>> b'1.23'.isdigit() False bytes.islower()Â¶ bytearray.islower()Â¶ Return True if there is at least one lowercase ASCII character in the sequence and no uppercase ASCII characters, False otherwise. For example: >>> b'hello world'.islower() True >>> b'Hello world'.islower() False Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. bytes.isspace()Â¶ bytearray.isspace()Â¶ Return True if all bytes in the sequence are ASCII whitespace and the sequence is not empty, False otherwise. ASCII whitespace characters are those byte values in the sequence b' \\t\\n\\r\\x0b\\f' (space, tab, newline, carriage return, vertical tab, form feed). bytes.istitle()Â¶ bytearray.istitle()Â¶ Return True if the sequence is ASCII titlecase and the sequence is not empty, False otherwise. See bytes.title() for more details on the definition of âtitlecaseâ. For example: >>> b'Hello World'.istitle() True >>> b'Hello world'.istitle() False bytes.isupper()Â¶ bytearray.isupper()Â¶ Return True if there is at least one uppercase alphabetic ASCII character in the sequence and no lowercase ASCII characters, False otherwise. For example: >>> b'HELLO WORLD'.isupper() True >>> b'Hello world'.isupper() False Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. bytes.lower()Â¶ bytearray.lower()Â¶ Return a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart. For example: >>> b'Hello World'.lower() b'hello world' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.splitlines(keepends=False)Â¶ bytearray.splitlines(keepends=False)Â¶ Return a list",
    "content_length": 3825
  },
  {
    "id": "stdtypes_chunk_35",
    "source_file": "stdtypes",
    "chunk_index": 35,
    "content": "characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.splitlines(keepends=False)Â¶ bytearray.splitlines(keepends=False)Â¶ Return a list of the lines in the binary sequence, breaking at ASCII line boundaries. This method uses the universal newlines approach to splitting lines. Line breaks are not included in the resulting list unless keepends is given and true. For example: >>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines() [b'ab c', b'', b'de fg', b'kl'] >>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True) [b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n'] Unlike split() when a delimiter string sep is given, this method returns an empty list for the empty string, and a terminal line break does not result in an extra line: >>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n') ([b''], [b'Two lines', b'']) >>> b\"\".splitlines(), b\"One line\\n\".splitlines() ([], [b'One line']) bytes.swapcase()Â¶ bytearray.swapcase()Â¶ Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa. For example: >>> b'Hello World'.swapcase() b'hELLO wORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Unlike str.swapcase(), it is always the case that bin.swapcase().swapcase() == bin for the binary versions. Case conversions are symmetrical in ASCII, even though that is not generally true for arbitrary Unicode code points. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.title()Â¶ bytearray.title()Â¶ Return a titlecased version of the binary sequence where words start with an uppercase ASCII character and the remaining characters are lowercase. Uncased byte values are left unmodified. For example: >>> b'Hello world'.title() b'Hello World' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. All other byte values are uncased. The algorithm uses a simple language-independent definition of a word as groups of consecutive letters. The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result: >>> b\"they're bill's friends from the UK\".title() b\"They'Re Bill'S Friends From The Uk\" A workaround for apostrophes can be constructed using regular expressions: >>> import re >>> def titlecase(s): ... return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\", ... lambda mo: mo.group(0)[0:1].upper() + ... mo.group(0)[1:].lower(), ... s) ... >>> titlecase(b\"they're bill's friends.\") b\"They're Bill's Friends.\" Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.upper()Â¶ bytearray.upper()Â¶ Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart. For example: >>> b'Hello World'.upper() b'HELLO WORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Note The bytearray version of this method does",
    "content_length": 3669
  },
  {
    "id": "stdtypes_chunk_36",
    "source_file": "stdtypes",
    "chunk_index": 36,
    "content": "sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart. For example: >>> b'Hello World'.upper() b'HELLO WORLD' Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz'. Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.zfill(width, /)Â¶ bytearray.zfill(width, /)Â¶ Return a copy of the sequence left filled with ASCII b'0' digits to make a sequence of length width. A leading sign prefix (b'+'/ b'-') is handled by inserting the padding after the sign character rather than before. For bytes objects, the original sequence is returned if width is less than or equal to len(seq). For example: >>> b\"42\".zfill(5) b'00042' >>> b\"-42\".zfill(5) b'-0042' Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. printf-style Bytes FormattingÂ¶ Note The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). If the value being printed may be a tuple or dictionary, wrap it in a tuple. Bytes objects (bytes/bytearray) have one unique built-in operation: the % operator (modulo). This is also known as the bytes formatting or interpolation operator. Given format % values (where format is a bytes object), % conversion specifications in format are replaced with zero or more elements of values. The effect is similar to using the sprintf() in the C language. If format requires a single argument, values may be a single non-tuple object. [5] Otherwise, values must be a tuple with exactly the number of items specified by the format bytes object, or a single mapping object (for example, a dictionary). A conversion specifier contains two or more characters and has the following components, which must occur in this order: The '%' character, which marks the start of the specifier. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)). Conversion flags (optional), which affect the result of some conversion types. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next element of the tuple in values, and the object to convert comes after the minimum field width and optional precision. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an asterisk), the actual precision is read from the next element of the tuple in values, and the value to convert comes after the precision. Length modifier (optional). Conversion type. When the right argument is a dictionary (or other mapping type), then the formats in the bytes object must include a parenthesised mapping key into that dictionary inserted immediately after the '%' character. The mapping key selects the value to be formatted from the mapping. For example: >>> print(b'%(language)s has %(number)03d quote types.' % ... {b'language': b\"Python\", b\"number\":",
    "content_length": 3208
  },
  {
    "id": "stdtypes_chunk_37",
    "source_file": "stdtypes",
    "chunk_index": 37,
    "content": "other mapping type), then the formats in the bytes object must include a parenthesised mapping key into that dictionary inserted immediately after the '%' character. The mapping key selects the value to be formatted from the mapping. For example: >>> print(b'%(language)s has %(number)03d quote types.' % ... {b'language': b\"Python\", b\"number\": 2}) b'Python has 002 quote types.' In this case no * specifiers may occur in a format (since they require a sequential parameter list). The conversion flag characters are: Flag Meaning '#' The value conversion will use the âalternate formâ (where defined below). '0' The conversion will be zero padded for numeric values. '-' The converted value is left adjusted (overrides the '0' conversion if both are given). ' ' (a space) A blank should be left before a positive number (or empty string) produced by a signed conversion. '+' A sign character ('+' or '-') will precede the conversion (overrides a âspaceâ flag). A length modifier (h, l, or L) may be present, but is ignored as it is not necessary for Python â so e.g. %ld is identical to %d. The conversion types are: Conversion Meaning Notes 'd' Signed integer decimal. 'i' Signed integer decimal. 'o' Signed octal value. (1) 'u' Obsolete type â it is identical to 'd'. (8) 'x' Signed hexadecimal (lowercase). (2) 'X' Signed hexadecimal (uppercase). (2) 'e' Floating-point exponential format (lowercase). (3) 'E' Floating-point exponential format (uppercase). (3) 'f' Floating-point decimal format. (3) 'F' Floating-point decimal format. (3) 'g' Floating-point format. Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. (4) 'G' Floating-point format. Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. (4) 'c' Single byte (accepts integer or single byte objects). 'b' Bytes (any object that follows the buffer protocol or has __bytes__()). (5) 's' 's' is an alias for 'b' and should only be used for Python2/3 code bases. (6) 'a' Bytes (converts any Python object using repr(obj).encode('ascii', 'backslashreplace')). (5) 'r' 'r' is an alias for 'a' and should only be used for Python2/3 code bases. (7) '%' No argument is converted, results in a '%' character in the result. Notes: The alternate form causes a leading octal specifier ('0o') to be inserted before the first digit. The alternate form causes a leading '0x' or '0X' (depending on whether the 'x' or 'X' format was used) to be inserted before the first digit. The alternate form causes the result to always contain a decimal point, even if no digits follow it. The precision determines the number of digits after the decimal point and defaults to 6. The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be. The precision determines the number of significant digits before and after the decimal point and defaults to 6. If precision is N, the output is truncated to N characters. b'%s' is deprecated, but will",
    "content_length": 3092
  },
  {
    "id": "stdtypes_chunk_38",
    "source_file": "stdtypes",
    "chunk_index": 38,
    "content": "always contain a decimal point, and trailing zeroes are not removed as they would otherwise be. The precision determines the number of significant digits before and after the decimal point and defaults to 6. If precision is N, the output is truncated to N characters. b'%s' is deprecated, but will not be removed during the 3.x series. b'%r' is deprecated, but will not be removed during the 3.x series. See PEP 237. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. See also PEP 461 - Adding % formatting to bytes and bytearray Added in version 3.5. Memory ViewsÂ¶ memoryview objects allow Python code to access the internal data of an object that supports the buffer protocol without copying. class memoryview(object)Â¶ Create a memoryview that references object. object must support the buffer protocol. Built-in objects that support the buffer protocol include bytes and bytearray. A memoryview has the notion of an element, which is the atomic memory unit handled by the originating object. For many simple types such as bytes and bytearray, an element is a single byte, but other types such as array.array may have bigger elements. len(view) is equal to the length of tolist, which is the nested list representation of the view. If view.ndim = 1, this is equal to the number of elements in the view. Changed in version 3.12: If view.ndim == 0, len(view) now raises TypeError instead of returning 1. The itemsize attribute will give you the number of bytes in a single element. A memoryview supports slicing and indexing to expose its data. One-dimensional slicing will result in a subview: >>> v = memoryview(b'abcefg') >>> v[1] 98 >>> v[-1] 103 >>> v[1:4] <memory at 0x7f3ddc9f4350> >>> bytes(v[1:4]) b'bce' If format is one of the native format specifiers from the struct module, indexing with an integer or a tuple of integers is also supported and returns a single element with the correct type. One-dimensional memoryviews can be indexed with an integer or a one-integer tuple. Multi-dimensional memoryviews can be indexed with tuples of exactly ndim integers where ndim is the number of dimensions. Zero-dimensional memoryviews can be indexed with the empty tuple. Here is an example with a non-byte format: >>> import array >>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444]) >>> m = memoryview(a) >>> m[0] -11111111 >>> m[-1] 44444444 >>> m[::2].tolist() [-11111111, -33333333] If the underlying object is writable, the memoryview supports one-dimensional slice assignment. Resizing is not allowed: >>> data = bytearray(b'abcefg') >>> v = memoryview(data) >>> v.readonly False >>> v[0] = ord(b'z') >>> data bytearray(b'zbcefg') >>> v[1:4] = b'123' >>> data bytearray(b'z123fg') >>> v[2:3] = b'spam' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: memoryview assignment: lvalue and rvalue have different structures >>> v[2:6] = b'spam' >>> data bytearray(b'z1spam') One-dimensional memoryviews of hashable (read-only) types with formats âBâ, âbâ or âcâ are also hashable. The hash is defined as hash(m)",
    "content_length": 3162
  },
  {
    "id": "stdtypes_chunk_39",
    "source_file": "stdtypes",
    "chunk_index": 39,
    "content": "= b'spam' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: memoryview assignment: lvalue and rvalue have different structures >>> v[2:6] = b'spam' >>> data bytearray(b'z1spam') One-dimensional memoryviews of hashable (read-only) types with formats âBâ, âbâ or âcâ are also hashable. The hash is defined as hash(m) == hash(m.tobytes()): >>> v = memoryview(b'abcefg') >>> hash(v) == hash(b'abcefg') True >>> hash(v[2:4]) == hash(b'ce') True >>> hash(v[::-2]) == hash(b'abcefg'[::-2]) True Changed in version 3.3: One-dimensional memoryviews can now be sliced. One-dimensional memoryviews with formats âBâ, âbâ or âcâ are now hashable. Changed in version 3.4: memoryview is now registered automatically with collections.abc.Sequence Changed in version 3.5: memoryviews can now be indexed with tuple of integers. memoryview has several methods: __eq__(exporter)Â¶ A memoryview and a PEP 3118 exporter are equal if their shapes are equivalent and if all corresponding values are equal when the operandsâ respective format codes are interpreted using struct syntax. For the subset of struct format strings currently supported by tolist(), v and w are equal if v.tolist() == w.tolist(): >>> import array >>> a = array.array('I', [1, 2, 3, 4, 5]) >>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0]) >>> c = array.array('b', [5, 3, 1]) >>> x = memoryview(a) >>> y = memoryview(b) >>> x == a == y == b True >>> x.tolist() == a.tolist() == y.tolist() == b.tolist() True >>> z = y[::-2] >>> z == c True >>> z.tolist() == c.tolist() True If either format string is not supported by the struct module, then the objects will always compare as unequal (even if the format strings and buffer contents are identical): >>> from ctypes import BigEndianStructure, c_long >>> class BEPoint(BigEndianStructure): ... _fields_ = [(\"x\", c_long), (\"y\", c_long)] ... >>> point = BEPoint(100, 200) >>> a = memoryview(point) >>> b = memoryview(point) >>> a == point False >>> a == b False Note that, as with floating-point numbers, v is w does not imply v == w for memoryview objects. Changed in version 3.3: Previous versions compared the raw memory disregarding the item format and the logical array structure. tobytes(order='C')Â¶ Return the data in the buffer as a bytestring. This is equivalent to calling the bytes constructor on the memoryview. >>> m = memoryview(b\"abc\") >>> m.tobytes() b'abc' >>> bytes(m) b'abc' For non-contiguous arrays the result is equal to the flattened list representation with all elements converted to bytes. tobytes() supports all format strings, including those that are not in struct module syntax. Added in version 3.8: order can be {âCâ, âFâ, âAâ}. When order is âCâ or âFâ, the data of the original array is converted to C or Fortran order. For contiguous views, âAâ returns an exact copy of the physical memory. In particular, in-memory Fortran order is preserved. For non-contiguous views, the data is converted to C first. order=None is the same as order=âCâ. hex(*, bytes_per_sep=1)Â¶ hex(sep, bytes_per_sep=1) Return a string object containing two hexadecimal digits for each byte in the buffer. >>> m = memoryview(b\"abc\") >>> m.hex() '616263' Added",
    "content_length": 3252
  },
  {
    "id": "stdtypes_chunk_40",
    "source_file": "stdtypes",
    "chunk_index": 40,
    "content": "memory. In particular, in-memory Fortran order is preserved. For non-contiguous views, the data is converted to C first. order=None is the same as order=âCâ. hex(*, bytes_per_sep=1)Â¶ hex(sep, bytes_per_sep=1) Return a string object containing two hexadecimal digits for each byte in the buffer. >>> m = memoryview(b\"abc\") >>> m.hex() '616263' Added in version 3.5. Changed in version 3.8: Similar to bytes.hex(), memoryview.hex() now supports optional sep and bytes_per_sep parameters to insert separators between bytes in the hex output. tolist()Â¶ Return the data in the buffer as a list of elements. >>> memoryview(b'abc').tolist() [97, 98, 99] >>> import array >>> a = array.array('d', [1.1, 2.2, 3.3]) >>> m = memoryview(a) >>> m.tolist() [1.1, 2.2, 3.3] Changed in version 3.3: tolist() now supports all single character native formats in struct module syntax as well as multi-dimensional representations. toreadonly()Â¶ Return a readonly version of the memoryview object. The original memoryview object is unchanged. >>> m = memoryview(bytearray(b'abc')) >>> mm = m.toreadonly() >>> mm.tolist() [97, 98, 99] >>> mm[0] = 42 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: cannot modify read-only memory >>> m[0] = 43 >>> mm.tolist() [43, 98, 99] Added in version 3.8. release()Â¶ Release the underlying buffer exposed by the memoryview object. Many objects take special actions when a view is held on them (for example, a bytearray would temporarily forbid resizing); therefore, calling release() is handy to remove these restrictions (and free any dangling resources) as soon as possible. After this method has been called, any further operation on the view raises a ValueError (except release() itself which can be called multiple times): >>> m = memoryview(b'abc') >>> m.release() >>> m[0] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: operation forbidden on released memoryview object The context management protocol can be used for a similar effect, using the with statement: >>> with memoryview(b'abc') as m: ... m[0] ... 97 >>> m[0] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: operation forbidden on released memoryview object Added in version 3.2. cast(format, /)Â¶ cast(format, shape, /) Cast a memoryview to a new format or shape. shape defaults to [byte_length//new_itemsize], which means that the result view will be one-dimensional. The return value is a new memoryview, but the buffer itself is not copied. Supported casts are 1D -> C-contiguous and C-contiguous -> 1D. The destination format is restricted to a single element native format in struct syntax. One of the formats must be a byte format (âBâ, âbâ or âcâ). The byte length of the result must be the same as the original length. Note that all byte lengths may depend on the operating system. Cast 1D/long to 1D/unsigned bytes: >>> import array >>> a = array.array('l', [1,2,3]) >>> x = memoryview(a) >>> x.format 'l' >>> x.itemsize 8 >>> len(x) 3 >>> x.nbytes 24 >>> y = x.cast('B') >>> y.format 'B' >>> y.itemsize 1 >>> len(y) 24 >>> y.nbytes 24 Cast 1D/unsigned bytes to 1D/char: >>> b = bytearray(b'zyz') >>> x",
    "content_length": 3221
  },
  {
    "id": "stdtypes_chunk_41",
    "source_file": "stdtypes",
    "chunk_index": 41,
    "content": "import array >>> a = array.array('l', [1,2,3]) >>> x = memoryview(a) >>> x.format 'l' >>> x.itemsize 8 >>> len(x) 3 >>> x.nbytes 24 >>> y = x.cast('B') >>> y.format 'B' >>> y.itemsize 1 >>> len(y) 24 >>> y.nbytes 24 Cast 1D/unsigned bytes to 1D/char: >>> b = bytearray(b'zyz') >>> x = memoryview(b) >>> x[0] = b'a' Traceback (most recent call last): ... TypeError: memoryview: invalid type for format 'B' >>> y = x.cast('c') >>> y[0] = b'a' >>> b bytearray(b'ayz') Cast 1D/bytes to 3D/ints to 1D/signed char: >>> import struct >>> buf = struct.pack(\"i\"*12, *list(range(12))) >>> x = memoryview(buf) >>> y = x.cast('i', shape=[2,2,3]) >>> y.tolist() [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]] >>> y.format 'i' >>> y.itemsize 4 >>> len(y) 2 >>> y.nbytes 48 >>> z = y.cast('b') >>> z.format 'b' >>> z.itemsize 1 >>> len(z) 48 >>> z.nbytes 48 Cast 1D/unsigned long to 2D/unsigned long: >>> buf = struct.pack(\"L\"*6, *list(range(6))) >>> x = memoryview(buf) >>> y = x.cast('L', shape=[2,3]) >>> len(y) 2 >>> y.nbytes 48 >>> y.tolist() [[0, 1, 2], [3, 4, 5]] Added in version 3.3. Changed in version 3.5: The source format is no longer restricted when casting to a byte view. There are also several readonly attributes available: objÂ¶ The underlying object of the memoryview: >>> b = bytearray(b'xyz') >>> m = memoryview(b) >>> m.obj is b True Added in version 3.3. nbytesÂ¶ nbytes == product(shape) * itemsize == len(m.tobytes()). This is the amount of space in bytes that the array would use in a contiguous representation. It is not necessarily equal to len(m): >>> import array >>> a = array.array('i', [1,2,3,4,5]) >>> m = memoryview(a) >>> len(m) 5 >>> m.nbytes 20 >>> y = m[::2] >>> len(y) 3 >>> y.nbytes 12 >>> len(y.tobytes()) 12 Multi-dimensional arrays: >>> import struct >>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)]) >>> x = memoryview(buf) >>> y = x.cast('d', shape=[3,4]) >>> y.tolist() [[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]] >>> len(y) 3 >>> y.nbytes 96 Added in version 3.3. readonlyÂ¶ A bool indicating whether the memory is read only. formatÂ¶ A string containing the format (in struct module style) for each element in the view. A memoryview can be created from exporters with arbitrary format strings, but some methods (e.g. tolist()) are restricted to native single element formats. Changed in version 3.3: format 'B' is now handled according to the struct module syntax. This means that memoryview(b'abc')[0] == b'abc'[0] == 97. itemsizeÂ¶ The size in bytes of each element of the memoryview: >>> import array, struct >>> m = memoryview(array.array('H', [32000, 32001, 32002])) >>> m.itemsize 2 >>> m[0] 32000 >>> struct.calcsize('H') == m.itemsize True ndimÂ¶ An integer indicating how many dimensions of a multi-dimensional array the memory represents. shapeÂ¶ A tuple of integers the length of ndim giving the shape of the memory as an N-dimensional array. Changed in version 3.3: An empty tuple instead of None when ndim = 0. stridesÂ¶ A tuple of integers the",
    "content_length": 3033
  },
  {
    "id": "stdtypes_chunk_42",
    "source_file": "stdtypes",
    "chunk_index": 42,
    "content": "indicating how many dimensions of a multi-dimensional array the memory represents. shapeÂ¶ A tuple of integers the length of ndim giving the shape of the memory as an N-dimensional array. Changed in version 3.3: An empty tuple instead of None when ndim = 0. stridesÂ¶ A tuple of integers the length of ndim giving the size in bytes to access each element for each dimension of the array. Changed in version 3.3: An empty tuple instead of None when ndim = 0. suboffsetsÂ¶ Used internally for PIL-style arrays. The value is informational only. c_contiguousÂ¶ A bool indicating whether the memory is C-contiguous. Added in version 3.3. f_contiguousÂ¶ A bool indicating whether the memory is Fortran contiguous. Added in version 3.3. contiguousÂ¶ A bool indicating whether the memory is contiguous. Added in version 3.3. Set Types â set, frozensetÂ¶ A set object is an unordered collection of distinct hashable objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference. (For other containers see the built-in dict, list, and tuple classes, and the collections module.) Like other collections, sets support x in set, len(set), and for x in set. Being an unordered collection, sets do not record element position or order of insertion. Accordingly, sets do not support indexing, slicing, or other sequence-like behavior. There are currently two built-in set types, set and frozenset. The set type is mutable â the contents can be changed using methods like add() and remove(). Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The frozenset type is immutable and hashable â its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set. Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: {'jack', 'sjoerd'}, in addition to the set constructor. The constructors for both classes work the same: class set(iterable=(), /)Â¶ class frozenset(iterable=(), /)Â¶ Return a new set or frozenset object whose elements are taken from iterable. The elements of a set must be hashable. To represent sets of sets, the inner sets must be frozenset objects. If iterable is not specified, a new empty set is returned. Sets can be created by several means: Use a comma-separated list of elements within braces: {'jack', 'sjoerd'} Use a set comprehension: {c for c in 'abracadabra' if c not in 'abc'} Use the type constructor: set(), set('foobar'), set(['a', 'b', 'foo']) Instances of set and frozenset provide the following operations: len(s) Return the number of elements in set s (cardinality of s). x in s Test x for membership in s. x not in s Test x for non-membership in s. isdisjoint(other, /)Â¶ Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty",
    "content_length": 3049
  },
  {
    "id": "stdtypes_chunk_43",
    "source_file": "stdtypes",
    "chunk_index": 43,
    "content": "set s (cardinality of s). x in s Test x for membership in s. x not in s Test x for non-membership in s. isdisjoint(other, /)Â¶ Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set. issubset(other, /)Â¶ set <= other Test whether every element in the set is in other. set < other Test whether the set is a proper subset of other, that is, set <= other and set != other. issuperset(other, /)Â¶ set >= other Test whether every element in other is in the set. set > other Test whether the set is a proper superset of other, that is, set >= other and set != other. union(*others)Â¶ set | other | ... Return a new set with elements from the set and all others. intersection(*others)Â¶ set & other & ... Return a new set with elements common to the set and all others. difference(*others)Â¶ set - other - ... Return a new set with elements in the set that are not in the others. symmetric_difference(other, /)Â¶ set ^ other Return a new set with elements in either the set or other but not both. copy()Â¶ Return a shallow copy of the set. Note, the non-operator versions of union(), intersection(), difference(), symmetric_difference(), issubset(), and issuperset() methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like set('abc') & 'cbs' in favor of the more readable set('abc').intersection('cbs'). Both set and frozenset support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal). Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]). The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so all of the following return False: a<b, a==b, or a>b. Since sets only define partial ordering (subset relationships), the output of the list.sort() method is undefined for lists of sets. Set elements, like dictionary keys, must be hashable. Binary operations that mix set instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others)Â¶ set |= other | ... Update the set, adding elements from all",
    "content_length": 2900
  },
  {
    "id": "stdtypes_chunk_44",
    "source_file": "stdtypes",
    "chunk_index": 44,
    "content": "instances with frozenset return the type of the first operand. For example: frozenset('ab') | set('bc') returns an instance of frozenset. The following table lists operations available for set that do not apply to immutable instances of frozenset: update(*others)Â¶ set |= other | ... Update the set, adding elements from all others. intersection_update(*others)Â¶ set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(*others)Â¶ set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other, /)Â¶ set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem, /)Â¶ Add element elem to the set. remove(elem, /)Â¶ Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem, /)Â¶ Remove element elem from the set if it is present. pop()Â¶ Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear()Â¶ Remove all elements from the set. Note, the non-operator versions of the update(), intersection_update(), difference_update(), and symmetric_difference_update() methods will accept any iterable as an argument. Note, the elem argument to the __contains__(), remove(), and discard() methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from elem. Mapping Types â dictÂ¶ A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionaryâs keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Values that compare equal (such as 1, 1.0, and True) can be used interchangeably to index the same dictionary entry. class dict(**kwargs)Â¶ class dict(mapping, /, **kwargs) class dict(iterable, /, **kwargs) Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments. Dictionaries can be created by several means: Use a comma-separated list of key: value pairs within braces: {'jack': 4098, 'sjoerd': 4127} or {4098: 'jack', 4127: 'sjoerd'} Use a dict comprehension: {}, {x: x ** 2 for x in range(10)} Use the type constructor: dict(), dict([('foo', 100), ('bar', 200)]), dict(foo=100, bar=200) If no positional argument is given, an empty dictionary is created. If a positional argument is given and it defines a keys() method, a dictionary is created by calling __getitem__() on the argument with each returned key from the method. Otherwise, the positional argument must be an iterable object. Each item in the iterable must itself be an iterable with exactly two elements. The first element of each item becomes a key in the new dictionary, and the second element the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary. If keyword arguments are given, the",
    "content_length": 3214
  },
  {
    "id": "stdtypes_chunk_45",
    "source_file": "stdtypes",
    "chunk_index": 45,
    "content": "exactly two elements. The first element of each item becomes a key in the new dictionary, and the second element the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary. If keyword arguments are given, the keyword arguments and their values are added to the dictionary created from the positional argument. If a key being added is already present, the value from the keyword argument replaces the value from the positional argument. Providing keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used. Dictionaries compare equal if and only if they have the same (key, value) pairs (regardless of ordering). Order comparisons (â<â, â<=â, â>=â, â>â) raise TypeError. To illustrate dictionary creation and equality, the following examples all return a dictionary equal to {\"one\": 1, \"two\": 2, \"three\": 3}: >>> a = dict(one=1, two=2, three=3) >>> b = {'one': 1, 'two': 2, 'three': 3} >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3])) >>> d = dict([('two', 2), ('one', 1), ('three', 3)]) >>> e = dict({'three': 3, 'one': 1, 'two': 2}) >>> f = dict({'one': 1, 'three': 3}, two=2) >>> a == b == c == d == e == f True Providing keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used. Dictionaries preserve insertion order. Note that updating a key does not affect the order. Keys added after deletion are inserted at the end. >>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(d) ['one', 'two', 'three', 'four'] >>> list(d.values()) [1, 2, 3, 4] >>> d[\"one\"] = 42 >>> d {'one': 42, 'two': 2, 'three': 3, 'four': 4} >>> del d[\"two\"] >>> d[\"two\"] = None >>> d {'one': 42, 'three': 3, 'four': 4, 'two': None} Changed in version 3.7: Dictionary order is guaranteed to be insertion order. This behavior was an implementation detail of CPython from 3.6. These are the operations that dictionaries support (and therefore, custom mapping types should support too): list(d) Return a list of all the keys used in the dictionary d. len(d) Return the number of items in the dictionary d. d[key] Return the item of d with key key. Raises a KeyError if key is not in the map. If a subclass of dict defines a method __missing__() and key is not present, the d[key] operation calls that method with the key key as argument. The d[key] operation then returns or raises whatever is returned or raised by the __missing__(key) call. No other operations or methods invoke __missing__(). If __missing__() is not defined, KeyError is raised. __missing__() must be a method; it cannot be an instance variable: >>> class Counter(dict): ... def __missing__(self, key): ... return 0 ... >>> c = Counter() >>> c['red'] 0 >>> c['red'] += 1 >>>",
    "content_length": 2927
  },
  {
    "id": "stdtypes_chunk_46",
    "source_file": "stdtypes",
    "chunk_index": 46,
    "content": "call. No other operations or methods invoke __missing__(). If __missing__() is not defined, KeyError is raised. __missing__() must be a method; it cannot be an instance variable: >>> class Counter(dict): ... def __missing__(self, key): ... return 0 ... >>> c = Counter() >>> c['red'] 0 >>> c['red'] += 1 >>> c['red'] 1 The example above shows part of the implementation of collections.Counter. A different __missing__ method is used by collections.defaultdict. d[key] = value Set d[key] to value. del d[key] Remove d[key] from d. Raises a KeyError if key is not in the map. key in d Return True if d has a key key, else False. key not in d Equivalent to not key in d. iter(d) Return an iterator over the keys of the dictionary. This is a shortcut for iter(d.keys()). clear()Â¶ Remove all items from the dictionary. copy()Â¶ Return a shallow copy of the dictionary. classmethod fromkeys(iterable, value=None, /)Â¶ Create a new dictionary with keys from iterable and values set to value. fromkeys() is a class method that returns a new dictionary. value defaults to None. All of the values refer to just a single instance, so it generally doesnât make sense for value to be a mutable object such as an empty list. To get distinct values, use a dict comprehension instead. get(key, default=None, /)Â¶ Return the value for key if key is in the dictionary, else default. If default is not given, it defaults to None, so that this method never raises a KeyError. items()Â¶ Return a new view of the dictionaryâs items ((key, value) pairs). See the documentation of view objects. keys()Â¶ Return a new view of the dictionaryâs keys. See the documentation of view objects. pop(key, /)Â¶ pop(key, default, /) If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a KeyError is raised. popitem()Â¶ Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order. popitem() is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling popitem() raises a KeyError. Changed in version 3.7: LIFO order is now guaranteed. In prior versions, popitem() would return an arbitrary key/value pair. reversed(d) Return a reverse iterator over the keys of the dictionary. This is a shortcut for reversed(d.keys()). Added in version 3.8. setdefault(key, default=None, /)Â¶ If key is in the dictionary, return its value. If not, insert key with a value of default and return default. default defaults to None. update(**kwargs)Â¶ update(mapping, /, **kwargs) update(iterable, /, **kwargs) Update the dictionary with the key/value pairs from mapping or iterable and kwargs, overwriting existing keys. Return None. update() accepts either another object with a keys() method (in which case __getitem__() is called with every key returned from the method) or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those",
    "content_length": 3065
  },
  {
    "id": "stdtypes_chunk_47",
    "source_file": "stdtypes",
    "chunk_index": 47,
    "content": "Return None. update() accepts either another object with a keys() method (in which case __getitem__() is called with every key returned from the method) or an iterable of key/value pairs (as tuples or other iterables of length two). If keyword arguments are specified, the dictionary is then updated with those key/value pairs: d.update(red=1, blue=2). values()Â¶ Return a new view of the dictionaryâs values. See the documentation of view objects. An equality comparison between one dict.values() view and another will always return False. This also applies when comparing dict.values() to itself: >>> d = {'a': 1} >>> d.values() == d.values() False d | other Create a new dictionary with the merged keys and values of d and other, which must both be dictionaries. The values of other take priority when d and other share keys. Added in version 3.9. d |= other Update the dictionary d with keys and values from other, which may be either a mapping or an iterable of key/value pairs. The values of other take priority when d and other share keys. Added in version 3.9. Dictionaries and dictionary views are reversible. >>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4} >>> d {'one': 1, 'two': 2, 'three': 3, 'four': 4} >>> list(reversed(d)) ['four', 'three', 'two', 'one'] >>> list(reversed(d.values())) [4, 3, 2, 1] >>> list(reversed(d.items())) [('four', 4), ('three', 3), ('two', 2), ('one', 1)] Changed in version 3.8: Dictionaries are now reversible. See also types.MappingProxyType can be used to create a read-only view of a dict. Dictionary view objectsÂ¶ The objects returned by dict.keys(), dict.values() and dict.items() are view objects. They provide a dynamic view on the dictionaryâs entries, which means that when the dictionary changes, the view reflects these changes. Dictionary views can be iterated over to yield their respective data, and support membership tests: len(dictview) Return the number of entries in the dictionary. iter(dictview) Return an iterator over the keys, values or items (represented as tuples of (key, value)) in the dictionary. Keys and values are iterated over in insertion order. This allows the creation of (value, key) pairs using zip(): pairs = zip(d.values(), d.keys()). Another way to create the same list is pairs = [(v, k) for (k, v) in d.items()]. Iterating views while adding or deleting entries in the dictionary may raise a RuntimeError or fail to iterate over all entries. Changed in version 3.7: Dictionary order is guaranteed to be insertion order. x in dictview Return True if x is in the underlying dictionaryâs keys, values or items (in the latter case, x should be a (key, value) tuple). reversed(dictview) Return a reverse iterator over the keys, values or items of the dictionary. The view will be iterated in reverse order of the insertion. Changed in version 3.8: Dictionary views are now reversible. dictview.mapping Return a types.MappingProxyType that wraps the original dictionary to which the view refers. Added in version 3.10. Keys views are set-like since their entries are unique and hashable. Items views also have set-like operations since the (key,",
    "content_length": 3136
  },
  {
    "id": "stdtypes_chunk_48",
    "source_file": "stdtypes",
    "chunk_index": 48,
    "content": "of the insertion. Changed in version 3.8: Dictionary views are now reversible. dictview.mapping Return a types.MappingProxyType that wraps the original dictionary to which the view refers. Added in version 3.10. Keys views are set-like since their entries are unique and hashable. Items views also have set-like operations since the (key, value) pairs are unique and the keys are hashable. If all values in an items view are hashable as well, then the items view can interoperate with other sets. (Values views are not treated as set-like since the entries are generally not unique.) For set-like views, all of the operations defined for the abstract base class collections.abc.Set are available (for example, ==, <, or ^). While using set operators, set-like views accept any iterable as the other operand, unlike sets which only accept sets as the input. An example of dictionary view usage: >>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500} >>> keys = dishes.keys() >>> values = dishes.values() >>> # iteration >>> n = 0 >>> for val in values: ... n += val ... >>> print(n) 504 >>> # keys and values are iterated over in the same order (insertion order) >>> list(keys) ['eggs', 'sausage', 'bacon', 'spam'] >>> list(values) [2, 1, 1, 500] >>> # view objects are dynamic and reflect dict changes >>> del dishes['eggs'] >>> del dishes['sausage'] >>> list(keys) ['bacon', 'spam'] >>> # set operations >>> keys & {'eggs', 'bacon', 'salad'} {'bacon'} >>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'} True >>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'} True >>> # get back a read-only proxy for the original dictionary >>> values.mapping mappingproxy({'bacon': 1, 'spam': 500}) >>> values.mapping['spam'] 500 Context Manager TypesÂ¶ Pythonâs with statement supports the concept of a runtime context defined by a context manager. This is implemented using a pair of methods that allow user-defined classes to define a runtime context that is entered before the statement body is executed and exited when the statement ends: contextmanager.__enter__()Â¶ Enter the runtime context and return either this object or another object related to the runtime context. The value returned by this method is bound to the identifier in the as clause of with statements using this context manager. An example of a context manager that returns itself is a file object. File objects return themselves from __enter__() to allow open() to be used as the context expression in a with statement. An example of a context manager that returns a related object is the one returned by decimal.localcontext(). These managers set the active decimal context to a copy of the original decimal context and then return the copy. This allows changes to be made to the current decimal context in the body of the with statement without affecting code outside the with statement. contextmanager.__exit__(exc_type, exc_val, exc_tb)Â¶ Exit the runtime context and return a Boolean flag indicating if any exception that occurred should be suppressed. If an exception occurred while executing the body of the with statement, the",
    "content_length": 3147
  },
  {
    "id": "stdtypes_chunk_49",
    "source_file": "stdtypes",
    "chunk_index": 49,
    "content": "decimal context in the body of the with statement without affecting code outside the with statement. contextmanager.__exit__(exc_type, exc_val, exc_tb)Â¶ Exit the runtime context and return a Boolean flag indicating if any exception that occurred should be suppressed. If an exception occurred while executing the body of the with statement, the arguments contain the exception type, value and traceback information. Otherwise, all three arguments are None. Returning a true value from this method will cause the with statement to suppress the exception and continue execution with the statement immediately following the with statement. Otherwise the exception continues propagating after this method has finished executing. Exceptions that occur during execution of this method will replace any exception that occurred in the body of the with statement. The exception passed in should never be reraised explicitly - instead, this method should return a false value to indicate that the method completed successfully and does not want to suppress the raised exception. This allows context management code to easily detect whether or not an __exit__() method has actually failed. Python defines several context managers to support easy thread synchronisation, prompt closure of files or other objects, and simpler manipulation of the active decimal arithmetic context. The specific types are not treated specially beyond their implementation of the context management protocol. See the contextlib module for some examples. Pythonâs generators and the contextlib.contextmanager decorator provide a convenient way to implement these protocols. If a generator function is decorated with the contextlib.contextmanager decorator, it will return a context manager implementing the necessary __enter__() and __exit__() methods, rather than the iterator produced by an undecorated generator function. Note that there is no specific slot for any of these methods in the type structure for Python objects in the Python/C API. Extension types wanting to define these methods must provide them as a normal Python accessible method. Compared to the overhead of setting up the runtime context, the overhead of a single class dictionary lookup is negligible. Type Annotation Types â Generic Alias, UnionÂ¶ The core built-in types for type annotations are Generic Alias and Union. Generic Alias TypeÂ¶ GenericAlias objects are generally created by subscripting a class. They are most often used with container classes, such as list or dict. For example, list[int] is a GenericAlias object created by subscripting the list class with the argument int. GenericAlias objects are intended primarily for use with type annotations. Note It is generally only possible to subscript a class if the class implements the special method __class_getitem__(). A GenericAlias object acts as a proxy for a generic type, implementing parameterized generics. For a container class, the argument(s) supplied to a subscription of the class may indicate the type(s) of the elements an object contains. For example, set[bytes] can be used in type annotations to signify a set in which all the elements are of type bytes. For a class which defines __class_getitem__() but is not a container, the argument(s) supplied to a subscription of the class will often indicate",
    "content_length": 3332
  },
  {
    "id": "stdtypes_chunk_50",
    "source_file": "stdtypes",
    "chunk_index": 50,
    "content": "the elements an object contains. For example, set[bytes] can be used in type annotations to signify a set in which all the elements are of type bytes. For a class which defines __class_getitem__() but is not a container, the argument(s) supplied to a subscription of the class will often indicate the return type(s) of one or more methods defined on an object. For example, regular expressions can be used on both the str data type and the bytes data type: If x = re.search('foo', 'foo'), x will be a re.Match object where the return values of x.group(0) and x[0] will both be of type str. We can represent this kind of object in type annotations with the GenericAlias re.Match[str]. If y = re.search(b'bar', b'bar'), (note the b for bytes), y will also be an instance of re.Match, but the return values of y.group(0) and y[0] will both be of type bytes. In type annotations, we would represent this variety of re.Match objects with re.Match[bytes]. GenericAlias objects are instances of the class types.GenericAlias, which can also be used to create GenericAlias objects directly. T[X, Y, ...] Creates a GenericAlias representing a type T parameterized by types X, Y, and more depending on the T used. For example, a function expecting a list containing float elements: def average(values: list[float]) -> float: return sum(values) / len(values) Another example for mapping objects, using a dict, which is a generic type expecting two type parameters representing the key type and the value type. In this example, the function expects a dict with keys of type str and values of type int: def send_post_request(url: str, body: dict[str, int]) -> None: ... The builtin functions isinstance() and issubclass() do not accept GenericAlias types for their second argument: >>> isinstance([1, 2], list[str]) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: isinstance() argument 2 cannot be a parameterized generic The Python runtime does not enforce type annotations. This extends to generic types and their type parameters. When creating a container object from a GenericAlias, the elements in the container are not checked against their type. For example, the following code is discouraged, but will run without errors: >>> t = list[str] >>> t([1, 2, 3]) [1, 2, 3] Furthermore, parameterized generics erase type parameters during object creation: >>> t = list[str] >>> type(t) <class 'types.GenericAlias'> >>> l = t() >>> type(l) <class 'list'> Calling repr() or str() on a generic shows the parameterized type: >>> repr(list[int]) 'list[int]' >>> str(list[int]) 'list[int]' The __getitem__() method of generic containers will raise an exception to disallow mistakes like dict[str][str]: >>> dict[str][str] Traceback (most recent call last): ... TypeError: dict[str] is not a generic class However, such expressions are valid when type variables are used. The index must have as many elements as there are type variable items in the GenericAlias objectâs __args__. >>> from typing import TypeVar >>> Y = TypeVar('Y') >>> dict[str, Y][int] dict[str, int] Standard Generic ClassesÂ¶ The following standard library classes support parameterized generics. This list",
    "content_length": 3193
  },
  {
    "id": "stdtypes_chunk_51",
    "source_file": "stdtypes",
    "chunk_index": 51,
    "content": "when type variables are used. The index must have as many elements as there are type variable items in the GenericAlias objectâs __args__. >>> from typing import TypeVar >>> Y = TypeVar('Y') >>> dict[str, Y][int] dict[str, int] Standard Generic ClassesÂ¶ The following standard library classes support parameterized generics. This list is non-exhaustive. tuple list dict set frozenset type asyncio.Future asyncio.Task collections.deque collections.defaultdict collections.OrderedDict collections.Counter collections.ChainMap collections.abc.Awaitable collections.abc.Coroutine collections.abc.AsyncIterable collections.abc.AsyncIterator collections.abc.AsyncGenerator collections.abc.Iterable collections.abc.Iterator collections.abc.Generator collections.abc.Reversible collections.abc.Container collections.abc.Collection collections.abc.Callable collections.abc.Set collections.abc.MutableSet collections.abc.Mapping collections.abc.MutableMapping collections.abc.Sequence collections.abc.MutableSequence collections.abc.ByteString collections.abc.MappingView collections.abc.KeysView collections.abc.ItemsView collections.abc.ValuesView contextlib.AbstractContextManager contextlib.AbstractAsyncContextManager dataclasses.Field functools.cached_property functools.partialmethod os.PathLike queue.LifoQueue queue.Queue queue.PriorityQueue queue.SimpleQueue re.Pattern re.Match shelve.BsdDbShelf shelve.DbfilenameShelf shelve.Shelf types.MappingProxyType weakref.WeakKeyDictionary weakref.WeakMethod weakref.WeakSet weakref.WeakValueDictionary Special Attributes of GenericAlias objectsÂ¶ All parameterized generics implement special read-only attributes. genericalias.__origin__Â¶ This attribute points at the non-parameterized generic class: >>> list[int].__origin__ <class 'list'> genericalias.__args__Â¶ This attribute is a tuple (possibly of length 1) of generic types passed to the original __class_getitem__() of the generic class: >>> dict[str, list[int]].__args__ (<class 'str'>, list[int]) genericalias.__parameters__Â¶ This attribute is a lazily computed tuple (possibly empty) of unique type variables found in __args__: >>> from typing import TypeVar >>> T = TypeVar('T') >>> list[T].__parameters__ (~T,) Note A GenericAlias object with typing.ParamSpec parameters may not have correct __parameters__ after substitution because typing.ParamSpec is intended primarily for static type checking. genericalias.__unpacked__Â¶ A boolean that is true if the alias has been unpacked using the * operator (see TypeVarTuple). Added in version 3.11. See also PEP 484 - Type HintsIntroducing Pythonâs framework for type annotations. PEP 585 - Type Hinting Generics In Standard CollectionsIntroducing the ability to natively parameterize standard-library classes, provided they implement the special class method __class_getitem__(). Generics, user-defined generics and typing.GenericDocumentation on how to implement generic classes that can be parameterized at runtime and understood by static type-checkers. Added in version 3.9. Union TypeÂ¶ A union object holds the value of the | (bitwise or) operation on multiple type objects. These types are intended primarily for type annotations. The union type expression enables cleaner type hinting syntax compared to typing.Union. X | Y | ... Defines a union object which holds types X, Y, and so forth. X | Y means either X or Y. It is equivalent to typing.Union[X, Y]. For example, the following function expects an argument of type int or float: def square(number: int | float) -> int | float: return number ** 2 Note The | operand cannot be used at runtime to define unions where one or more members is a forward reference. For example, int | \"Foo\", where \"Foo\" is a reference to a class not yet defined, will fail at runtime. For unions which include forward references, present the whole expression as a string, e.g. \"int | Foo\". union_object == other Union objects can be tested for equality with other union objects. Details: Unions of unions are flattened: (int | str) | float == int | str | float Redundant types are removed: int | str | int == int | str When comparing unions, the order is",
    "content_length": 4155
  },
  {
    "id": "stdtypes_chunk_52",
    "source_file": "stdtypes",
    "chunk_index": 52,
    "content": "union_object == other Union objects can be tested for equality with other union objects. Details: Unions of unions are flattened: (int | str) | float == int | str | float Redundant types are removed: int | str | int == int | str When comparing unions, the order is ignored: int | str == str | int It is compatible with typing.Union: int | str == typing.Union[int, str] Optional types can be spelled as a union with None: str | None == typing.Optional[str] isinstance(obj, union_object) issubclass(obj, union_object) Calls to isinstance() and issubclass() are also supported with a union object: >>> isinstance(\"\", int | str) True However, parameterized generics in union objects cannot be checked: >>> isinstance(1, int | list[int]) # short-circuit evaluation True >>> isinstance([1], int | list[int]) Traceback (most recent call last): ... TypeError: isinstance() argument 2 cannot be a parameterized generic The user-exposed type for the union object can be accessed from types.UnionType and used for isinstance() checks. An object cannot be instantiated from the type: >>> import types >>> isinstance(int | str, types.UnionType) True >>> types.UnionType() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: cannot create 'types.UnionType' instances Note The __or__() method for type objects was added to support the syntax X | Y. If a metaclass implements __or__(), the Union may override it: >>> class M(type): ... def __or__(self, other): ... return \"Hello\" ... >>> class C(metaclass=M): ... pass ... >>> C | int 'Hello' >>> int | C int | C See also PEP 604 â PEP proposing the X | Y syntax and the Union type. Added in version 3.10. Other Built-in TypesÂ¶ The interpreter supports several other kinds of objects. Most of these support only one or two operations. ModulesÂ¶ The only special operation on a module is attribute access: m.name, where m is a module and name accesses a name defined in mâs symbol table. Module attributes can be assigned to. (Note that the import statement is not, strictly speaking, an operation on a module object; import foo does not require a module object named foo to exist, rather it requires an (external) definition for a module named foo somewhere.) A special attribute of every module is __dict__. This is the dictionary containing the moduleâs symbol table. Modifying this dictionary will actually change the moduleâs symbol table, but direct assignment to the __dict__ attribute is not possible (you can write m.__dict__['a'] = 1, which defines m.a to be 1, but you canât write m.__dict__ = {}). Modifying __dict__ directly is not recommended. Modules built into the interpreter are written like this: <module 'sys' (built-in)>. If loaded from a file, they are written as <module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>. Classes and Class InstancesÂ¶ See Objects, values and types and Class definitions for these. FunctionsÂ¶ Function objects are created by function definitions. The only operation on a function object is to call it: func(argument-list). There are really two flavors of function objects: built-in functions and user-defined functions. Both support the",
    "content_length": 3162
  },
  {
    "id": "stdtypes_chunk_53",
    "source_file": "stdtypes",
    "chunk_index": 53,
    "content": "Classes and Class InstancesÂ¶ See Objects, values and types and Class definitions for these. FunctionsÂ¶ Function objects are created by function definitions. The only operation on a function object is to call it: func(argument-list). There are really two flavors of function objects: built-in functions and user-defined functions. Both support the same operation (to call the function), but the implementation is different, hence the different object types. See Function definitions for more information. MethodsÂ¶ Methods are functions that are called using the attribute notation. There are two flavors: built-in methods (such as append() on lists) and class instance method. Built-in methods are described with the types that support them. If you access a method (a function defined in a class namespace) through an instance, you get a special object: a bound method (also called instance method) object. When called, it will add the self argument to the argument list. Bound methods have two special read-only attributes: m.__self__ is the object on which the method operates, and m.__func__ is the function implementing the method. Calling m(arg-1, arg-2, ..., arg-n) is completely equivalent to calling m.__func__(m.__self__, arg-1, arg-2, ..., arg-n). Like function objects, bound method objects support getting arbitrary attributes. However, since method attributes are actually stored on the underlying function object (method.__func__), setting method attributes on bound methods is disallowed. Attempting to set an attribute on a method results in an AttributeError being raised. In order to set a method attribute, you need to explicitly set it on the underlying function object: >>> class C: ... def method(self): ... pass ... >>> c = C() >>> c.method.whoami = 'my name is method' # can't set on the method Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AttributeError: 'method' object has no attribute 'whoami' >>> c.method.__func__.whoami = 'my name is method' >>> c.method.whoami 'my name is method' See Instance methods for more information. Code ObjectsÂ¶ Code objects are used by the implementation to represent âpseudo-compiledâ executable Python code such as a function body. They differ from function objects because they donât contain a reference to their global execution environment. Code objects are returned by the built-in compile() function and can be extracted from function objects through their __code__ attribute. See also the code module. Accessing __code__ raises an auditing event object.__getattr__ with arguments obj and \"__code__\". A code object can be executed or evaluated by passing it (instead of a source string) to the exec() or eval() built-in functions. See The standard type hierarchy for more information. Type ObjectsÂ¶ Type objects represent the various object types. An objectâs type is accessed by the built-in function type(). There are no special operations on types. The standard module types defines names for all standard built-in types. Types are written like this: <class 'int'>. The Null ObjectÂ¶ This object is returned by functions that donât explicitly return a value. It supports no special operations. There is exactly one null object, named None (a built-in name). type(None)() produces the same singleton. It is written",
    "content_length": 3322
  },
  {
    "id": "stdtypes_chunk_54",
    "source_file": "stdtypes",
    "chunk_index": 54,
    "content": "all standard built-in types. Types are written like this: <class 'int'>. The Null ObjectÂ¶ This object is returned by functions that donât explicitly return a value. It supports no special operations. There is exactly one null object, named None (a built-in name). type(None)() produces the same singleton. It is written as None. The Ellipsis ObjectÂ¶ This object is commonly used used to indicate that something is omitted. It supports no special operations. There is exactly one ellipsis object, named Ellipsis (a built-in name). type(Ellipsis)() produces the Ellipsis singleton. It is written as Ellipsis or .... In typical use, ... as the Ellipsis object appears in a few different places, for instance: In type annotations, such as callable arguments or tuple elements. As the body of a function instead of a pass statement. In third-party libraries, such as Numpyâs slicing and striding. Python also uses three dots in ways that are not Ellipsis objects, for instance: Doctestâs ELLIPSIS, as a pattern for missing content. The default Python prompt of the interactive shell when partial input is incomplete. Lastly, the Python documentation often uses three dots in conventional English usage to mean omitted content, even in code examples that also use them as the Ellipsis. The NotImplemented ObjectÂ¶ This object is returned from comparisons and binary operations when they are asked to operate on types they donât support. See Comparisons for more information. There is exactly one NotImplemented object. type(NotImplemented)() produces the singleton instance. It is written as NotImplemented. Internal ObjectsÂ¶ See The standard type hierarchy for this information. It describes stack frame objects, traceback objects, and slice objects. Special AttributesÂ¶ The implementation adds a few special read-only attributes to several object types, where they are relevant. Some of these are not reported by the dir() built-in function. definition.__name__Â¶ The name of the class, function, method, descriptor, or generator instance. definition.__qualname__Â¶ The qualified name of the class, function, method, descriptor, or generator instance. Added in version 3.3. definition.__module__Â¶ The name of the module in which a class or function was defined. definition.__doc__Â¶ The documentation string of a class or function, or None if undefined. definition.__type_params__Â¶ The type parameters of generic classes, functions, and type aliases. For classes and functions that are not generic, this will be an empty tuple. Added in version 3.12. Integer string conversion length limitationÂ¶ CPython has a global limit for converting between int and str to mitigate denial of service attacks. This limit only applies to decimal or other non-power-of-two number bases. Hexadecimal, octal, and binary conversions are unlimited. The limit can be configured. The int type in CPython is an arbitrary length number stored in binary form (commonly known as a âbignumâ). There exists no algorithm that can convert a string to a binary integer or a binary integer to a string in linear time, unless the base is a power of 2. Even the best known algorithms for base 10 have sub-quadratic complexity. Converting a large value such as int('1' * 500_000) can take over a",
    "content_length": 3276
  },
  {
    "id": "stdtypes_chunk_55",
    "source_file": "stdtypes",
    "chunk_index": 55,
    "content": "can convert a string to a binary integer or a binary integer to a string in linear time, unless the base is a power of 2. Even the best known algorithms for base 10 have sub-quadratic complexity. Converting a large value such as int('1' * 500_000) can take over a second on a fast CPU. Limiting conversion size offers a practical way to avoid CVE 2020-10735. The limit is applied to the number of digit characters in the input or output string when a non-linear conversion algorithm would be involved. Underscores and the sign are not counted towards the limit. When an operation would exceed the limit, a ValueError is raised: >>> import sys >>> sys.set_int_max_str_digits(4300) # Illustrative, this is the default. >>> _ = int('2' * 5432) Traceback (most recent call last): ... ValueError: Exceeds the limit (4300 digits) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit >>> i = int('2' * 4300) >>> len(str(i)) 4300 >>> i_squared = i*i >>> len(str(i_squared)) Traceback (most recent call last): ... ValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit >>> len(hex(i_squared)) 7144 >>> assert int(hex(i_squared), base=16) == i*i # Hexadecimal is unlimited. The default limit is 4300 digits as provided in sys.int_info.default_max_str_digits. The lowest limit that can be configured is 640 digits as provided in sys.int_info.str_digits_check_threshold. Verification: >>> import sys >>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info >>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info >>> msg = int('578966293710682886880994035146873798396722250538762761564' ... '9252925514383915483333812743580549779436104706260696366600' ... '571186405732').to_bytes(53, 'big') ... Added in version 3.11. Affected APIsÂ¶ The limitation only applies to potentially slow conversions between int and str or bytes: int(string) with default base 10. int(string, base) for all bases that are not a power of 2. str(integer). repr(integer). any other string conversion to base 10, for example f\"{integer}\", \"{}\".format(integer), or b\"%d\" % integer. The limitations do not apply to functions with a linear algorithm: int(string, base) with base 2, 4, 8, 16, or 32. int.from_bytes() and int.to_bytes(). hex(), oct(), bin(). Format Specification Mini-Language for hex, octal, and binary numbers. str to float. str to decimal.Decimal. Configuring the limitÂ¶ Before Python starts up you can use an environment variable or an interpreter command line flag to configure the limit: PYTHONINTMAXSTRDIGITS, e.g. PYTHONINTMAXSTRDIGITS=640 python3 to set the limit to 640 or PYTHONINTMAXSTRDIGITS=0 python3 to disable the limitation. -X int_max_str_digits, e.g. python3 -X int_max_str_digits=640 sys.flags.int_max_str_digits contains the value of PYTHONINTMAXSTRDIGITS or -X int_max_str_digits. If both the env var and the -X option are set, the -X option takes precedence. A value of -1 indicates that both were unset, thus a value of sys.int_info.default_max_str_digits was used during initialization. From code, you can inspect the current limit and set a new one using these sys APIs: sys.get_int_max_str_digits() and sys.set_int_max_str_digits() are a getter and setter for the interpreter-wide limit. Subinterpreters have their own limit. Information about the default and minimum can be found in sys.int_info: sys.int_info.default_max_str_digits is the compiled-in default limit. sys.int_info.str_digits_check_threshold is the lowest accepted value for the limit (other",
    "content_length": 3618
  },
  {
    "id": "stdtypes_chunk_56",
    "source_file": "stdtypes",
    "chunk_index": 56,
    "content": "new one using these sys APIs: sys.get_int_max_str_digits() and sys.set_int_max_str_digits() are a getter and setter for the interpreter-wide limit. Subinterpreters have their own limit. Information about the default and minimum can be found in sys.int_info: sys.int_info.default_max_str_digits is the compiled-in default limit. sys.int_info.str_digits_check_threshold is the lowest accepted value for the limit (other than 0 which disables it). Added in version 3.11. Caution Setting a low limit can lead to problems. While rare, code exists that contains integer constants in decimal in their source that exceed the minimum threshold. A consequence of setting the limit is that Python source code containing decimal integer literals longer than the limit will encounter an error during parsing, usually at startup time or import time or even at installation time - anytime an up to date .pyc does not already exist for the code. A workaround for source that contains such large constants is to convert them to 0x hexadecimal form as it has no limit. Test your application thoroughly if you use a low limit. Ensure your tests run with the limit set early via the environment or flag so that it applies during startup and even during any installation step that may invoke Python to precompile .py sources to .pyc files. Recommended configurationÂ¶ The default sys.int_info.default_max_str_digits is expected to be reasonable for most applications. If your application requires a different limit, set it from your main entry point using Python version agnostic code as these APIs were added in security patch releases in versions before 3.12. Example: >>> import sys >>> if hasattr(sys, \"set_int_max_str_digits\"): ... upper_bound = 68000 ... lower_bound = 4004 ... current_limit = sys.get_int_max_str_digits() ... if current_limit == 0 or current_limit > upper_bound: ... sys.set_int_max_str_digits(upper_bound) ... elif current_limit < lower_bound: ... sys.set_int_max_str_digits(lower_bound) If you need to disable it entirely, set it to 0. Footnotes [1] Additional information on these special methods may be found in the Python Reference Manual (Basic customization). [2] As a consequence, the list [1, 2] is considered equal to [1.0, 2.0], and similarly for tuples. [3] They must have since the parser canât tell the type of the operands. [4] (1,2,3,4) Cased characters are those with general category property being one of âLuâ (Letter, uppercase), âLlâ (Letter, lowercase), or âLtâ (Letter, titlecase). [5] (1,2) To format only a tuple you should therefore provide a singleton tuple whose only element is the tuple to be formatted.",
    "content_length": 2650
  },
  {
    "id": "datetime_chunk_0",
    "source_file": "datetime",
    "chunk_index": 0,
    "content": "datetime â Basic date and time typesÂ¶ Source code: Lib/datetime.py The datetime module supplies classes for manipulating dates and times. While date and time arithmetic is supported, the focus of the implementation is on efficient attribute extraction for output formatting and manipulation. Tip Skip to the format codes. See also Module calendarGeneral calendar related functions. Module timeTime access and conversions. Module zoneinfoConcrete time zones representing the IANA time zone database. Package dateutilThird-party library with expanded time zone and parsing support. Package DateTypeThird-party library that introduces distinct static types to e.g. allow static type checkers to differentiate between naive and aware datetimes. Aware and Naive ObjectsÂ¶ Date and time objects may be categorized as âawareâ or ânaiveâ depending on whether or not they include time zone information. With sufficient knowledge of applicable algorithmic and political time adjustments, such as time zone and daylight saving time information, an aware object can locate itself relative to other aware objects. An aware object represents a specific moment in time that is not open to interpretation. [1] A naive object does not contain enough information to unambiguously locate itself relative to other date/time objects. Whether a naive object represents Coordinated Universal Time (UTC), local time, or time in some other time zone is purely up to the program, just like it is up to the program whether a particular number represents metres, miles, or mass. Naive objects are easy to understand and to work with, at the cost of ignoring some aspects of reality. For applications requiring aware objects, datetime and time objects have an optional time zone information attribute, tzinfo, that can be set to an instance of a subclass of the abstract tzinfo class. These tzinfo objects capture information about the offset from UTC time, the time zone name, and whether daylight saving time is in effect. Only one concrete tzinfo class, the timezone class, is supplied by the datetime module. The timezone class can represent simple time zones with fixed offsets from UTC, such as UTC itself or North American EST and EDT time zones. Supporting time zones at deeper levels of detail is up to the application. The rules for time adjustment across the world are more political than rational, change frequently, and there is no standard suitable for every application aside from UTC. ConstantsÂ¶ The datetime module exports the following constants: datetime.MINYEARÂ¶ The smallest year number allowed in a date or datetime object. MINYEAR is 1. datetime.MAXYEARÂ¶ The largest year number allowed in a date or datetime object. MAXYEAR is 9999. datetime.UTCÂ¶ Alias for the UTC time zone singleton datetime.timezone.utc. Added in version 3.11. Available TypesÂ¶ class datetime.date An idealized naive date, assuming the current Gregorian calendar always was, and always will be, in effect. Attributes: year, month, and day. class datetime.time An idealized time, independent of any particular day, assuming that every day has exactly 24*60*60 seconds. (There is no notion of âleap secondsâ here.) Attributes: hour, minute, second, microsecond, and tzinfo. class datetime.datetime A combination of a date",
    "content_length": 3304
  },
  {
    "id": "datetime_chunk_1",
    "source_file": "datetime",
    "chunk_index": 1,
    "content": "always will be, in effect. Attributes: year, month, and day. class datetime.time An idealized time, independent of any particular day, assuming that every day has exactly 24*60*60 seconds. (There is no notion of âleap secondsâ here.) Attributes: hour, minute, second, microsecond, and tzinfo. class datetime.datetime A combination of a date and a time. Attributes: year, month, day, hour, minute, second, microsecond, and tzinfo. class datetime.timedelta A duration expressing the difference between two datetime or date instances to microsecond resolution. class datetime.tzinfo An abstract base class for time zone information objects. These are used by the datetime and time classes to provide a customizable notion of time adjustment (for example, to account for time zone and/or daylight saving time). class datetime.timezone A class that implements the tzinfo abstract base class as a fixed offset from the UTC. Added in version 3.2. Objects of these types are immutable. Subclass relationships: object timedelta tzinfo timezone time date datetime Common PropertiesÂ¶ The date, datetime, time, and timezone types share these common features: Objects of these types are immutable. Objects of these types are hashable, meaning that they can be used as dictionary keys. Objects of these types support efficient pickling via the pickle module. Determining if an Object is Aware or NaiveÂ¶ Objects of the date type are always naive. An object of type time or datetime may be aware or naive. A datetime object d is aware if both of the following hold: d.tzinfo is not None d.tzinfo.utcoffset(d) does not return None Otherwise, d is naive. A time object t is aware if both of the following hold: t.tzinfo is not None t.tzinfo.utcoffset(None) does not return None. Otherwise, t is naive. The distinction between aware and naive doesnât apply to timedelta objects. timedelta ObjectsÂ¶ A timedelta object represents a duration, the difference between two datetime or date instances. class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)Â¶ All arguments are optional and default to 0. Arguments may be integers or floats, and may be positive or negative. Only days, seconds and microseconds are stored internally. Arguments are converted to those units: A millisecond is converted to 1000 microseconds. A minute is converted to 60 seconds. An hour is converted to 3600 seconds. A week is converted to 7 days. and days, seconds and microseconds are then normalized so that the representation is unique, with 0 <= microseconds < 1000000 0 <= seconds < 3600*24 (the number of seconds in one day) -999999999 <= days <= 999999999 The following example illustrates how any arguments besides days, seconds and microseconds are âmergedâ and normalized into those three resulting attributes: >>> from datetime import timedelta >>> delta = timedelta( ... days=50, ... seconds=27, ... microseconds=10, ... milliseconds=29000, ... minutes=5, ... hours=8, ... weeks=2 ... ) >>> # Only days, seconds, and microseconds remain >>> delta datetime.timedelta(days=64, seconds=29156, microseconds=10) If any argument is a float and there are fractional microseconds, the fractional microseconds left over from all arguments are combined and their sum is rounded to the nearest",
    "content_length": 3312
  },
  {
    "id": "datetime_chunk_2",
    "source_file": "datetime",
    "chunk_index": 2,
    "content": "... minutes=5, ... hours=8, ... weeks=2 ... ) >>> # Only days, seconds, and microseconds remain >>> delta datetime.timedelta(days=64, seconds=29156, microseconds=10) If any argument is a float and there are fractional microseconds, the fractional microseconds left over from all arguments are combined and their sum is rounded to the nearest microsecond using round-half-to-even tiebreaker. If no argument is a float, the conversion and normalization processes are exact (no information is lost). If the normalized value of days lies outside the indicated range, OverflowError is raised. Note that normalization of negative values may be surprising at first. For example: >>> from datetime import timedelta >>> d = timedelta(microseconds=-1) >>> (d.days, d.seconds, d.microseconds) (-1, 86399, 999999) Since the string representation of timedelta objects can be confusing, use the following recipe to produce a more readable format: >>> def pretty_timedelta(td): ... if td.days >= 0: ... return str(td) ... return f'-({-td!s})' ... >>> d = timedelta(hours=-1) >>> str(d) # not human-friendly '-1 day, 23:00:00' >>> pretty_timedelta(d) '-(1:00:00)' Class attributes: timedelta.minÂ¶ The most negative timedelta object, timedelta(-999999999). timedelta.maxÂ¶ The most positive timedelta object, timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999). timedelta.resolutionÂ¶ The smallest possible difference between non-equal timedelta objects, timedelta(microseconds=1). Note that, because of normalization, timedelta.max is greater than -timedelta.min. -timedelta.max is not representable as a timedelta object. Instance attributes (read-only): timedelta.daysÂ¶ Between -999,999,999 and 999,999,999 inclusive. timedelta.secondsÂ¶ Between 0 and 86,399 inclusive. Caution It is a somewhat common bug for code to unintentionally use this attribute when it is actually intended to get a total_seconds() value instead: >>> from datetime import timedelta >>> duration = timedelta(seconds=11235813) >>> duration.days, duration.seconds (130, 3813) >>> duration.total_seconds() 11235813.0 timedelta.microsecondsÂ¶ Between 0 and 999,999 inclusive. Supported operations: Operation Result t1 = t2 + t3 Sum of t2 and t3. Afterwards t1 - t2 == t3 and t1 - t3 == t2 are true. (1) t1 = t2 - t3 Difference of t2 and t3. Afterwards t1 == t2 - t3 and t2 == t1 + t3 are true. (1)(6) t1 = t2 * i or t1 = i * t2 Delta multiplied by an integer. Afterwards t1 // i == t2 is true, provided i != 0. In general, t1 * i == t1 * (i-1) + t1 is true. (1) t1 = t2 * f or t1 = f * t2 Delta multiplied by a float. The result is rounded to the nearest multiple of timedelta.resolution using round-half-to-even. f = t2 / t3 Division (3) of overall duration t2 by interval unit t3. Returns a float object. t1 = t2 / f or t1 = t2 / i Delta divided by a float or an int. The result is rounded to the nearest multiple of timedelta.resolution using round-half-to-even. t1 = t2 // i or t1 = t2 // t3 The floor is computed and the remainder (if any) is thrown away. In the second case, an integer is returned. (3) t1 = t2 % t3 The remainder is computed as a timedelta object. (3) q, r = divmod(t1, t2)",
    "content_length": 3183
  },
  {
    "id": "datetime_chunk_3",
    "source_file": "datetime",
    "chunk_index": 3,
    "content": "= t2 // i or t1 = t2 // t3 The floor is computed and the remainder (if any) is thrown away. In the second case, an integer is returned. (3) t1 = t2 % t3 The remainder is computed as a timedelta object. (3) q, r = divmod(t1, t2) Computes the quotient and the remainder: q = t1 // t2 (3) and r = t1 % t2. q is an integer and r is a timedelta object. +t1 Returns a timedelta object with the same value. (2) -t1 Equivalent to timedelta(-t1.days, -t1.seconds, -t1.microseconds), and to t1 * -1. (1)(4) abs(t) Equivalent to +t when t.days >= 0, and to -t when t.days < 0. (2) str(t) Returns a string in the form [D day[s], ][H]H:MM:SS[.UUUUUU], where D is negative for negative t. (5) repr(t) Returns a string representation of the timedelta object as a constructor call with canonical attribute values. Notes: This is exact but may overflow. This is exact and cannot overflow. Division by zero raises ZeroDivisionError. -timedelta.max is not representable as a timedelta object. String representations of timedelta objects are normalized similarly to their internal representation. This leads to somewhat unusual results for negative timedeltas. For example: >>> timedelta(hours=-5) datetime.timedelta(days=-1, seconds=68400) >>> print(_) -1 day, 19:00:00 The expression t2 - t3 will always be equal to the expression t2 + (-t3) except when t3 is equal to timedelta.max; in that case the former will produce a result while the latter will overflow. In addition to the operations listed above, timedelta objects support certain additions and subtractions with date and datetime objects (see below). Changed in version 3.2: Floor division and true division of a timedelta object by another timedelta object are now supported, as are remainder operations and the divmod() function. True division and multiplication of a timedelta object by a float object are now supported. timedelta objects support equality and order comparisons. In Boolean contexts, a timedelta object is considered to be true if and only if it isnât equal to timedelta(0). Instance methods: timedelta.total_seconds()Â¶ Return the total number of seconds contained in the duration. Equivalent to td / timedelta(seconds=1). For interval units other than seconds, use the division form directly (e.g. td / timedelta(microseconds=1)). Note that for very large time intervals (greater than 270 years on most platforms) this method will lose microsecond accuracy. Added in version 3.2. Examples of usage: timedeltaÂ¶ An additional example of normalization: >>> # Components of another_year add up to exactly 365 days >>> from datetime import timedelta >>> year = timedelta(days=365) >>> another_year = timedelta(weeks=40, days=84, hours=23, ... minutes=50, seconds=600) >>> year == another_year True >>> year.total_seconds() 31536000.0 Examples of timedelta arithmetic: >>> from datetime import timedelta >>> year = timedelta(days=365) >>> ten_years = 10 * year >>> ten_years datetime.timedelta(days=3650) >>> ten_years.days // 365 10 >>> nine_years = ten_years - year >>> nine_years datetime.timedelta(days=3285) >>> three_years = nine_years // 3 >>> three_years, three_years.days // 365 (datetime.timedelta(days=1095), 3) date ObjectsÂ¶ A date object represents a date (year, month and day)",
    "content_length": 3251
  },
  {
    "id": "datetime_chunk_4",
    "source_file": "datetime",
    "chunk_index": 4,
    "content": "= timedelta(days=365) >>> ten_years = 10 * year >>> ten_years datetime.timedelta(days=3650) >>> ten_years.days // 365 10 >>> nine_years = ten_years - year >>> nine_years datetime.timedelta(days=3285) >>> three_years = nine_years // 3 >>> three_years, three_years.days // 365 (datetime.timedelta(days=1095), 3) date ObjectsÂ¶ A date object represents a date (year, month and day) in an idealized calendar, the current Gregorian calendar indefinitely extended in both directions. January 1 of year 1 is called day number 1, January 2 of year 1 is called day number 2, and so on. [2] class datetime.date(year, month, day)Â¶ All arguments are required. Arguments must be integers, in the following ranges: MINYEAR <= year <= MAXYEAR 1 <= month <= 12 1 <= day <= number of days in the given month and year If an argument outside those ranges is given, ValueError is raised. Other constructors, all class methods: classmethod date.today()Â¶ Return the current local date. This is equivalent to date.fromtimestamp(time.time()). classmethod date.fromtimestamp(timestamp)Â¶ Return the local date corresponding to the POSIX timestamp, such as is returned by time.time(). This may raise OverflowError, if the timestamp is out of the range of values supported by the platform C localtime() function, and OSError on localtime() failure. Itâs common for this to be restricted to years from 1970 through 2038. Note that on non-POSIX systems that include leap seconds in their notion of a timestamp, leap seconds are ignored by fromtimestamp(). Changed in version 3.3: Raise OverflowError instead of ValueError if the timestamp is out of the range of values supported by the platform C localtime() function. Raise OSError instead of ValueError on localtime() failure. classmethod date.fromordinal(ordinal)Â¶ Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 <= ordinal <= date.max.toordinal(). For any date d, date.fromordinal(d.toordinal()) == d. classmethod date.fromisoformat(date_string)Â¶ Return a date corresponding to a date_string given in any valid ISO 8601 format, with the following exceptions: Reduced precision dates are not currently supported (YYYY-MM, YYYY). Extended date representations are not currently supported (Â±YYYYYY-MM-DD). Ordinal dates are not currently supported (YYYY-OOO). Examples: >>> from datetime import date >>> date.fromisoformat('2019-12-04') datetime.date(2019, 12, 4) >>> date.fromisoformat('20191204') datetime.date(2019, 12, 4) >>> date.fromisoformat('2021-W01-1') datetime.date(2021, 1, 4) Added in version 3.7. Changed in version 3.11: Previously, this method only supported the format YYYY-MM-DD. classmethod date.fromisocalendar(year, week, day)Â¶ Return a date corresponding to the ISO calendar date specified by year, week and day. This is the inverse of the function date.isocalendar(). Added in version 3.8. Class attributes: date.minÂ¶ The earliest representable date, date(MINYEAR, 1, 1). date.maxÂ¶ The latest representable date, date(MAXYEAR, 12, 31). date.resolutionÂ¶ The smallest possible difference between non-equal date objects, timedelta(days=1). Instance attributes (read-only): date.yearÂ¶ Between MINYEAR and MAXYEAR inclusive. date.monthÂ¶ Between 1 and 12 inclusive. date.dayÂ¶ Between 1 and the number of days in the given month of the given year. Supported operations: Operation Result date2 = date1 + timedelta date2 will be timedelta.days days after date1. (1) date2 = date1 - timedelta Computes date2 such that date2 +",
    "content_length": 3563
  },
  {
    "id": "datetime_chunk_5",
    "source_file": "datetime",
    "chunk_index": 5,
    "content": "date.monthÂ¶ Between 1 and 12 inclusive. date.dayÂ¶ Between 1 and the number of days in the given month of the given year. Supported operations: Operation Result date2 = date1 + timedelta date2 will be timedelta.days days after date1. (1) date2 = date1 - timedelta Computes date2 such that date2 + timedelta == date1. (2) timedelta = date1 - date2 (3) date1 == date2 date1 != date2 Equality comparison. (4) date1 < date2 date1 > date2 date1 <= date2 date1 >= date2 Order comparison. (5) Notes: date2 is moved forward in time if timedelta.days > 0, or backward if timedelta.days < 0. Afterward date2 - date1 == timedelta.days. timedelta.seconds and timedelta.microseconds are ignored. OverflowError is raised if date2.year would be smaller than MINYEAR or larger than MAXYEAR. timedelta.seconds and timedelta.microseconds are ignored. This is exact, and cannot overflow. timedelta.seconds and timedelta.microseconds are 0, and date2 + timedelta == date1 after. date objects are equal if they represent the same date. date objects that are not also datetime instances are never equal to datetime objects, even if they represent the same date. date1 is considered less than date2 when date1 precedes date2 in time. In other words, date1 < date2 if and only if date1.toordinal() < date2.toordinal(). Order comparison between a date object that is not also a datetime instance and a datetime object raises TypeError. Changed in version 3.13: Comparison between datetime object and an instance of the date subclass that is not a datetime subclass no longer converts the latter to date, ignoring the time part and the time zone. The default behavior can be changed by overriding the special comparison methods in subclasses. In Boolean contexts, all date objects are considered to be true. Instance methods: date.replace(year=self.year, month=self.month, day=self.day)Â¶ Return a new date object with the same values, but with specified parameters updated. Example: >>> from datetime import date >>> d = date(2002, 12, 31) >>> d.replace(day=26) datetime.date(2002, 12, 26) The generic function copy.replace() also supports date objects. date.timetuple()Â¶ Return a time.struct_time such as returned by time.localtime(). The hours, minutes and seconds are 0, and the DST flag is -1. d.timetuple() is equivalent to: time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1)) where yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within the current year starting with 1 for January 1st. date.toordinal()Â¶ Return the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1. For any date object d, date.fromordinal(d.toordinal()) == d. date.weekday()Â¶ Return the day of the week as an integer, where Monday is 0 and Sunday is 6. For example, date(2002, 12, 4).weekday() == 2, a Wednesday. See also isoweekday(). date.isoweekday()Â¶ Return the day of the week as an integer, where Monday is 1 and Sunday is 7. For example, date(2002, 12, 4).isoweekday() == 3, a Wednesday. See also weekday(), isocalendar(). date.isocalendar()Â¶ Return a named tuple object with three components: year, week and weekday. The ISO calendar is a widely used variant of the Gregorian calendar.",
    "content_length": 3230
  },
  {
    "id": "datetime_chunk_6",
    "source_file": "datetime",
    "chunk_index": 6,
    "content": "week as an integer, where Monday is 1 and Sunday is 7. For example, date(2002, 12, 4).isoweekday() == 3, a Wednesday. See also weekday(), isocalendar(). date.isocalendar()Â¶ Return a named tuple object with three components: year, week and weekday. The ISO calendar is a widely used variant of the Gregorian calendar. [3] The ISO year consists of 52 or 53 full weeks, and where a week starts on a Monday and ends on a Sunday. The first week of an ISO year is the first (Gregorian) calendar week of a year containing a Thursday. This is called week number 1, and the ISO year of that Thursday is the same as its Gregorian year. For example, 2004 begins on a Thursday, so the first week of ISO year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004: >>> from datetime import date >>> date(2003, 12, 29).isocalendar() datetime.IsoCalendarDate(year=2004, week=1, weekday=1) >>> date(2004, 1, 4).isocalendar() datetime.IsoCalendarDate(year=2004, week=1, weekday=7) Changed in version 3.9: Result changed from a tuple to a named tuple. date.isoformat()Â¶ Return a string representing the date in ISO 8601 format, YYYY-MM-DD: >>> from datetime import date >>> date(2002, 12, 4).isoformat() '2002-12-04' date.__str__()Â¶ For a date d, str(d) is equivalent to d.isoformat(). date.ctime()Â¶ Return a string representing the date: >>> from datetime import date >>> date(2002, 12, 4).ctime() 'Wed Dec 4 00:00:00 2002' d.ctime() is equivalent to: time.ctime(time.mktime(d.timetuple())) on platforms where the native C ctime() function (which time.ctime() invokes, but which date.ctime() does not invoke) conforms to the C standard. date.strftime(format)Â¶ Return a string representing the date, controlled by an explicit format string. Format codes referring to hours, minutes or seconds will see 0 values. See also strftime() and strptime() Behavior and date.isoformat(). date.__format__(format)Â¶ Same as date.strftime(). This makes it possible to specify a format string for a date object in formatted string literals and when using str.format(). See also strftime() and strptime() Behavior and date.isoformat(). Examples of Usage: dateÂ¶ Example of counting days to an event: >>> import time >>> from datetime import date >>> today = date.today() >>> today datetime.date(2007, 12, 5) >>> today == date.fromtimestamp(time.time()) True >>> my_birthday = date(today.year, 6, 24) >>> if my_birthday < today: ... my_birthday = my_birthday.replace(year=today.year + 1) ... >>> my_birthday datetime.date(2008, 6, 24) >>> time_to_birthday = abs(my_birthday - today) >>> time_to_birthday.days 202 More examples of working with date: >>> from datetime import date >>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001 >>> d datetime.date(2002, 3, 11) >>> # Methods related to formatting string output >>> d.isoformat() '2002-03-11' >>> d.strftime(\"%d/%m/%y\") '11/03/02' >>> d.strftime(\"%A %d. %B %Y\") 'Monday 11. March 2002' >>> d.ctime() 'Mon Mar 11 00:00:00 2002' >>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, \"day\", \"month\") 'The day is 11, the month is March.' >>> # Methods for to extracting 'components' under different calendars >>> t = d.timetuple() >>> for i in t: ... print(i) 2002 # year 3 # month 11 # day 0 0 0 0 # weekday (0 = Monday) 70",
    "content_length": 3267
  },
  {
    "id": "datetime_chunk_7",
    "source_file": "datetime",
    "chunk_index": 7,
    "content": "\"day\", \"month\") 'The day is 11, the month is March.' >>> # Methods for to extracting 'components' under different calendars >>> t = d.timetuple() >>> for i in t: ... print(i) 2002 # year 3 # month 11 # day 0 0 0 0 # weekday (0 = Monday) 70 # 70th day in the year -1 >>> ic = d.isocalendar() >>> for i in ic: ... print(i) 2002 # ISO year 11 # ISO week number 1 # ISO day number ( 1 = Monday ) >>> # A date object is immutable; all operations produce a new object >>> d.replace(year=2005) datetime.date(2005, 3, 11) datetime ObjectsÂ¶ A datetime object is a single object containing all the information from a date object and a time object. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day. Constructor: class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)Â¶ The year, month and day arguments are required. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments must be integers in the following ranges: MINYEAR <= year <= MAXYEAR, 1 <= month <= 12, 1 <= day <= number of days in the given month and year, 0 <= hour < 24, 0 <= minute < 60, 0 <= second < 60, 0 <= microsecond < 1000000, fold in [0, 1]. If an argument outside those ranges is given, ValueError is raised. Changed in version 3.6: Added the fold parameter. Other constructors, all class methods: classmethod datetime.today()Â¶ Return the current local date and time, with tzinfo None. Equivalent to: datetime.fromtimestamp(time.time()) See also now(), fromtimestamp(). This method is functionally equivalent to now(), but without a tz parameter. classmethod datetime.now(tz=None)Â¶ Return the current local date and time. If optional argument tz is None or not specified, this is like today(), but, if possible, supplies more precision than can be gotten from going through a time.time() timestamp (for example, this may be possible on platforms supplying the C gettimeofday() function). If tz is not None, it must be an instance of a tzinfo subclass, and the current date and time are converted to tzâs time zone. This function is preferred over today() and utcnow(). Note Subsequent calls to datetime.now() may return the same instant depending on the precision of the underlying clock. classmethod datetime.utcnow()Â¶ Return the current UTC date and time, with tzinfo None. This is like now(), but returns the current UTC date and time, as a naive datetime object. An aware current UTC datetime can be obtained by calling datetime.now(timezone.utc). See also now(). Warning Because naive datetime objects are treated by many datetime methods as local times, it is preferred to use aware datetimes to represent times in UTC. As such, the recommended way to create an object representing the current time in UTC is by calling datetime.now(timezone.utc). Deprecated since version 3.12: Use datetime.now() with UTC instead. classmethod datetime.fromtimestamp(timestamp, tz=None)Â¶",
    "content_length": 3056
  },
  {
    "id": "datetime_chunk_8",
    "source_file": "datetime",
    "chunk_index": 8,
    "content": "by many datetime methods as local times, it is preferred to use aware datetimes to represent times in UTC. As such, the recommended way to create an object representing the current time in UTC is by calling datetime.now(timezone.utc). Deprecated since version 3.12: Use datetime.now() with UTC instead. classmethod datetime.fromtimestamp(timestamp, tz=None)Â¶ Return the local date and time corresponding to the POSIX timestamp, such as is returned by time.time(). If optional argument tz is None or not specified, the timestamp is converted to the platformâs local date and time, and the returned datetime object is naive. If tz is not None, it must be an instance of a tzinfo subclass, and the timestamp is converted to tzâs time zone. fromtimestamp() may raise OverflowError, if the timestamp is out of the range of values supported by the platform C localtime() or gmtime() functions, and OSError on localtime() or gmtime() failure. Itâs common for this to be restricted to years in 1970 through 2038. Note that on non-POSIX systems that include leap seconds in their notion of a timestamp, leap seconds are ignored by fromtimestamp(), and then itâs possible to have two timestamps differing by a second that yield identical datetime objects. This method is preferred over utcfromtimestamp(). Changed in version 3.3: Raise OverflowError instead of ValueError if the timestamp is out of the range of values supported by the platform C localtime() or gmtime() functions. Raise OSError instead of ValueError on localtime() or gmtime() failure. Changed in version 3.6: fromtimestamp() may return instances with fold set to 1. classmethod datetime.utcfromtimestamp(timestamp)Â¶ Return the UTC datetime corresponding to the POSIX timestamp, with tzinfo None. (The resulting object is naive.) This may raise OverflowError, if the timestamp is out of the range of values supported by the platform C gmtime() function, and OSError on gmtime() failure. Itâs common for this to be restricted to years in 1970 through 2038. To get an aware datetime object, call fromtimestamp(): datetime.fromtimestamp(timestamp, timezone.utc) On the POSIX compliant platforms, it is equivalent to the following expression: datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp) except the latter formula always supports the full years range: between MINYEAR and MAXYEAR inclusive. Warning Because naive datetime objects are treated by many datetime methods as local times, it is preferred to use aware datetimes to represent times in UTC. As such, the recommended way to create an object representing a specific timestamp in UTC is by calling datetime.fromtimestamp(timestamp, tz=timezone.utc). Changed in version 3.3: Raise OverflowError instead of ValueError if the timestamp is out of the range of values supported by the platform C gmtime() function. Raise OSError instead of ValueError on gmtime() failure. Deprecated since version 3.12: Use datetime.fromtimestamp() with UTC instead. classmethod datetime.fromordinal(ordinal)Â¶ Return the datetime corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 <= ordinal <= datetime.max.toordinal(). The hour, minute, second and microsecond of the result are all 0, and tzinfo is None. classmethod datetime.combine(date, time, tzinfo=time.tzinfo)Â¶ Return a new datetime object whose",
    "content_length": 3402
  },
  {
    "id": "datetime_chunk_9",
    "source_file": "datetime",
    "chunk_index": 9,
    "content": "corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1. ValueError is raised unless 1 <= ordinal <= datetime.max.toordinal(). The hour, minute, second and microsecond of the result are all 0, and tzinfo is None. classmethod datetime.combine(date, time, tzinfo=time.tzinfo)Â¶ Return a new datetime object whose date components are equal to the given date objectâs, and whose time components are equal to the given time objectâs. If the tzinfo argument is provided, its value is used to set the tzinfo attribute of the result, otherwise the tzinfo attribute of the time argument is used. If the date argument is a datetime object, its time components and tzinfo attributes are ignored. For any datetime object d, d == datetime.combine(d.date(), d.time(), d.tzinfo). Changed in version 3.6: Added the tzinfo argument. classmethod datetime.fromisoformat(date_string)Â¶ Return a datetime corresponding to a date_string in any valid ISO 8601 format, with the following exceptions: Time zone offsets may have fractional seconds. The T separator may be replaced by any single unicode character. Fractional hours and minutes are not supported. Reduced precision dates are not currently supported (YYYY-MM, YYYY). Extended date representations are not currently supported (Â±YYYYYY-MM-DD). Ordinal dates are not currently supported (YYYY-OOO). Examples: >>> from datetime import datetime >>> datetime.fromisoformat('2011-11-04') datetime.datetime(2011, 11, 4, 0, 0) >>> datetime.fromisoformat('20111104') datetime.datetime(2011, 11, 4, 0, 0) >>> datetime.fromisoformat('2011-11-04T00:05:23') datetime.datetime(2011, 11, 4, 0, 5, 23) >>> datetime.fromisoformat('2011-11-04T00:05:23Z') datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc) >>> datetime.fromisoformat('20111104T000523') datetime.datetime(2011, 11, 4, 0, 5, 23) >>> datetime.fromisoformat('2011-W01-2T00:05:23.283') datetime.datetime(2011, 1, 4, 0, 5, 23, 283000) >>> datetime.fromisoformat('2011-11-04 00:05:23.283') datetime.datetime(2011, 11, 4, 0, 5, 23, 283000) >>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00') datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone.utc) >>> datetime.fromisoformat('2011-11-04T00:05:23+04:00') datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400))) Added in version 3.7. Changed in version 3.11: Previously, this method only supported formats that could be emitted by date.isoformat() or datetime.isoformat(). classmethod datetime.fromisocalendar(year, week, day)Â¶ Return a datetime corresponding to the ISO calendar date specified by year, week and day. The non-date components of the datetime are populated with their normal default values. This is the inverse of the function datetime.isocalendar(). Added in version 3.8. classmethod datetime.strptime(date_string, format)Â¶ Return a datetime corresponding to date_string, parsed according to format. If format does not contain microseconds or time zone information, this is equivalent to: datetime(*(time.strptime(date_string, format)[0:6])) ValueError is raised if the date_string and format canât be parsed by time.strptime() or if it returns a value which isnât a time tuple. See also strftime() and strptime() Behavior and datetime.fromisoformat(). Changed in version 3.13: If format specifies a day of month without a year a DeprecationWarning is now emitted. This is to avoid a quadrennial leap year bug in code seeking to parse only a month and day as the default year used in absence of one in the format is not a leap year. Such format values may raise an error as of Python 3.15. The workaround is to always include a year in your format. If parsing date_string values that do not have a year, explicitly add",
    "content_length": 3801
  },
  {
    "id": "datetime_chunk_10",
    "source_file": "datetime",
    "chunk_index": 10,
    "content": "the default year used in absence of one in the format is not a leap year. Such format values may raise an error as of Python 3.15. The workaround is to always include a year in your format. If parsing date_string values that do not have a year, explicitly add a year that is a leap year before parsing: >>> from datetime import datetime >>> date_string = \"02/29\" >>> when = datetime.strptime(f\"{date_string};1984\", \"%m/%d;%Y\") # Avoids leap year bug. >>> when.strftime(\"%B %d\") 'February 29' Class attributes: datetime.minÂ¶ The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None). datetime.maxÂ¶ The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None). datetime.resolutionÂ¶ The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1). Instance attributes (read-only): datetime.yearÂ¶ Between MINYEAR and MAXYEAR inclusive. datetime.monthÂ¶ Between 1 and 12 inclusive. datetime.dayÂ¶ Between 1 and the number of days in the given month of the given year. datetime.hourÂ¶ In range(24). datetime.minuteÂ¶ In range(60). datetime.secondÂ¶ In range(60). datetime.microsecondÂ¶ In range(1000000). datetime.tzinfoÂ¶ The object passed as the tzinfo argument to the datetime constructor, or None if none was passed. datetime.foldÂ¶ In [0, 1]. Used to disambiguate wall times during a repeated interval. (A repeated interval occurs when clocks are rolled back at the end of daylight saving time or when the UTC offset for the current zone is decreased for political reasons.) The values 0 and 1 represent, respectively, the earlier and later of the two moments with the same wall time representation. Added in version 3.6. Supported operations: Operation Result datetime2 = datetime1 + timedelta (1) datetime2 = datetime1 - timedelta (2) timedelta = datetime1 - datetime2 (3) datetime1 == datetime2 datetime1 != datetime2 Equality comparison. (4) datetime1 < datetime2 datetime1 > datetime2 datetime1 <= datetime2 datetime1 >= datetime2 Order comparison. (5) datetime2 is a duration of timedelta removed from datetime1, moving forward in time if timedelta.days > 0, or backward if timedelta.days < 0. The result has the same tzinfo attribute as the input datetime, and datetime2 - datetime1 == timedelta after. OverflowError is raised if datetime2.year would be smaller than MINYEAR or larger than MAXYEAR. Note that no time zone adjustments are done even if the input is an aware object. Computes the datetime2 such that datetime2 + timedelta == datetime1. As for addition, the result has the same tzinfo attribute as the input datetime, and no time zone adjustments are done even if the input is aware. Subtraction of a datetime from a datetime is defined only if both operands are naive, or if both are aware. If one is aware and the other is naive, TypeError is raised. If both are naive, or both are aware and have the same tzinfo attribute, the tzinfo attributes are ignored, and the result is a timedelta object t such that datetime2 + t == datetime1. No time zone adjustments are done in this case. If both are aware and have different tzinfo attributes, a-b acts as if a and b were first converted to naive UTC datetimes. The result",
    "content_length": 3223
  },
  {
    "id": "datetime_chunk_11",
    "source_file": "datetime",
    "chunk_index": 11,
    "content": "ignored, and the result is a timedelta object t such that datetime2 + t == datetime1. No time zone adjustments are done in this case. If both are aware and have different tzinfo attributes, a-b acts as if a and b were first converted to naive UTC datetimes. The result is (a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None) - b.utcoffset()) except that the implementation never overflows. datetime objects are equal if they represent the same date and time, taking into account the time zone. Naive and aware datetime objects are never equal. If both comparands are aware, and have the same tzinfo attribute, the tzinfo and fold attributes are ignored and the base datetimes are compared. If both comparands are aware and have different tzinfo attributes, the comparison acts as comparands were first converted to UTC datetimes except that the implementation never overflows. datetime instances in a repeated interval are never equal to datetime instances in other time zone. datetime1 is considered less than datetime2 when datetime1 precedes datetime2 in time, taking into account the time zone. Order comparison between naive and aware datetime objects raises TypeError. If both comparands are aware, and have the same tzinfo attribute, the tzinfo and fold attributes are ignored and the base datetimes are compared. If both comparands are aware and have different tzinfo attributes, the comparison acts as comparands were first converted to UTC datetimes except that the implementation never overflows. Changed in version 3.3: Equality comparisons between aware and naive datetime instances donât raise TypeError. Changed in version 3.13: Comparison between datetime object and an instance of the date subclass that is not a datetime subclass no longer converts the latter to date, ignoring the time part and the time zone. The default behavior can be changed by overriding the special comparison methods in subclasses. Instance methods: datetime.date()Â¶ Return date object with same year, month and day. datetime.time()Â¶ Return time object with same hour, minute, second, microsecond and fold. tzinfo is None. See also method timetz(). Changed in version 3.6: The fold value is copied to the returned time object. datetime.timetz()Â¶ Return time object with same hour, minute, second, microsecond, fold, and tzinfo attributes. See also method time(). Changed in version 3.6: The fold value is copied to the returned time object. datetime.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0)Â¶ Return a new datetime object with the same attributes, but with specified parameters updated. Note that tzinfo=None can be specified to create a naive datetime from an aware datetime with no conversion of date and time data. datetime objects are also supported by generic function copy.replace(). Changed in version 3.6: Added the fold parameter. datetime.astimezone(tz=None)Â¶ Return a datetime object with new tzinfo attribute tz, adjusting the date and time data so the result is the same UTC time as self, but in tzâs local time. If provided, tz must be an instance of a tzinfo subclass, and its utcoffset() and dst() methods must not return None. If self is naive, it is",
    "content_length": 3314
  },
  {
    "id": "datetime_chunk_12",
    "source_file": "datetime",
    "chunk_index": 12,
    "content": "attribute tz, adjusting the date and time data so the result is the same UTC time as self, but in tzâs local time. If provided, tz must be an instance of a tzinfo subclass, and its utcoffset() and dst() methods must not return None. If self is naive, it is presumed to represent time in the system time zone. If called without arguments (or with tz=None) the system local time zone is assumed for the target time zone. The .tzinfo attribute of the converted datetime instance will be set to an instance of timezone with the zone name and offset obtained from the OS. If self.tzinfo is tz, self.astimezone(tz) is equal to self: no adjustment of date or time data is performed. Else the result is local time in the time zone tz, representing the same UTC time as self: after astz = dt.astimezone(tz), astz - astz.utcoffset() will have the same date and time data as dt - dt.utcoffset(). If you merely want to attach a timezone object tz to a datetime dt without adjustment of date and time data, use dt.replace(tzinfo=tz). If you merely want to remove the timezone object from an aware datetime dt without conversion of date and time data, use dt.replace(tzinfo=None). Note that the default tzinfo.fromutc() method can be overridden in a tzinfo subclass to affect the result returned by astimezone(). Ignoring error cases, astimezone() acts like: def astimezone(self, tz): if self.tzinfo is tz: return self # Convert self to UTC, and attach the new timezone object. utc = (self - self.utcoffset()).replace(tzinfo=tz) # Convert from UTC to tz's local time. return tz.fromutc(utc) Changed in version 3.3: tz now can be omitted. Changed in version 3.6: The astimezone() method can now be called on naive instances that are presumed to represent system local time. datetime.utcoffset()Â¶ If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(self), and raises an exception if the latter doesnât return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. datetime.dst()Â¶ If tzinfo is None, returns None, else returns self.tzinfo.dst(self), and raises an exception if the latter doesnât return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The DST offset is not restricted to a whole number of minutes. datetime.tzname()Â¶ If tzinfo is None, returns None, else returns self.tzinfo.tzname(self), raises an exception if the latter doesnât return None or a string object, datetime.timetuple()Â¶ Return a time.struct_time such as returned by time.localtime(). d.timetuple() is equivalent to: time.struct_time((d.year, d.month, d.day, d.hour, d.minute, d.second, d.weekday(), yday, dst)) where yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within the current year starting with 1 for January 1st. The tm_isdst flag of the result is set according to the dst() method: tzinfo is None or dst() returns None, tm_isdst is set to -1; else if dst() returns a non-zero value, tm_isdst is set to 1; else tm_isdst is set to",
    "content_length": 3088
  },
  {
    "id": "datetime_chunk_13",
    "source_file": "datetime",
    "chunk_index": 13,
    "content": "current year starting with 1 for January 1st. The tm_isdst flag of the result is set according to the dst() method: tzinfo is None or dst() returns None, tm_isdst is set to -1; else if dst() returns a non-zero value, tm_isdst is set to 1; else tm_isdst is set to 0. datetime.utctimetuple()Â¶ If datetime instance d is naive, this is the same as d.timetuple() except that tm_isdst is forced to 0 regardless of what d.dst() returns. DST is never in effect for a UTC time. If d is aware, d is normalized to UTC time, by subtracting d.utcoffset(), and a time.struct_time for the normalized time is returned. tm_isdst is forced to 0. Note that an OverflowError may be raised if d.year was MINYEAR or MAXYEAR and UTC adjustment spills over a year boundary. Warning Because naive datetime objects are treated by many datetime methods as local times, it is preferred to use aware datetimes to represent times in UTC; as a result, using datetime.utctimetuple() may give misleading results. If you have a naive datetime representing UTC, use datetime.replace(tzinfo=timezone.utc) to make it aware, at which point you can use datetime.timetuple(). datetime.toordinal()Â¶ Return the proleptic Gregorian ordinal of the date. The same as self.date().toordinal(). datetime.timestamp()Â¶ Return POSIX timestamp corresponding to the datetime instance. The return value is a float similar to that returned by time.time(). Naive datetime instances are assumed to represent local time and this method relies on the platform C mktime() function to perform the conversion. Since datetime supports wider range of values than mktime() on many platforms, this method may raise OverflowError or OSError for times far in the past or far in the future. For aware datetime instances, the return value is computed as: (dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds() Added in version 3.3. Changed in version 3.6: The timestamp() method uses the fold attribute to disambiguate the times during a repeated interval. Note There is no method to obtain the POSIX timestamp directly from a naive datetime instance representing UTC time. If your application uses this convention and your system time zone is not set to UTC, you can obtain the POSIX timestamp by supplying tzinfo=timezone.utc: timestamp = dt.replace(tzinfo=timezone.utc).timestamp() or by calculating the timestamp directly: timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1) datetime.weekday()Â¶ Return the day of the week as an integer, where Monday is 0 and Sunday is 6. The same as self.date().weekday(). See also isoweekday(). datetime.isoweekday()Â¶ Return the day of the week as an integer, where Monday is 1 and Sunday is 7. The same as self.date().isoweekday(). See also weekday(), isocalendar(). datetime.isocalendar()Â¶ Return a named tuple with three components: year, week and weekday. The same as self.date().isocalendar(). datetime.isoformat(sep='T', timespec='auto')Â¶ Return a string representing the date and time in ISO 8601 format: YYYY-MM-DDTHH:MM:SS.ffffff, if microsecond is not 0 YYYY-MM-DDTHH:MM:SS, if microsecond is 0 If utcoffset() does not return None, a string is appended, giving the UTC offset: YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]], if microsecond is not 0 YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]], if microsecond is 0 Examples: >>> from datetime import datetime,",
    "content_length": 3361
  },
  {
    "id": "datetime_chunk_14",
    "source_file": "datetime",
    "chunk_index": 14,
    "content": "the date and time in ISO 8601 format: YYYY-MM-DDTHH:MM:SS.ffffff, if microsecond is not 0 YYYY-MM-DDTHH:MM:SS, if microsecond is 0 If utcoffset() does not return None, a string is appended, giving the UTC offset: YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]], if microsecond is not 0 YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]], if microsecond is 0 Examples: >>> from datetime import datetime, timezone >>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat() '2019-05-18T15:17:08.132263' >>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat() '2019-05-18T15:17:00+00:00' The optional argument sep (default 'T') is a one-character separator, placed between the date and time portions of the result. For example: >>> from datetime import tzinfo, timedelta, datetime >>> class TZ(tzinfo): ... \"\"\"A time zone with an arbitrary, constant -06:39 offset.\"\"\" ... def utcoffset(self, dt): ... return timedelta(hours=-6, minutes=-39) ... >>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ') '2002-12-25 00:00:00-06:39' >>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat() '2009-11-27T00:00:00.000100-06:39' The optional argument timespec specifies the number of additional components of the time to include (the default is 'auto'). It can be one of the following: 'auto': Same as 'seconds' if microsecond is 0, same as 'microseconds' otherwise. 'hours': Include the hour in the two-digit HH format. 'minutes': Include hour and minute in HH:MM format. 'seconds': Include hour, minute, and second in HH:MM:SS format. 'milliseconds': Include full time, but truncate fractional second part to milliseconds. HH:MM:SS.sss format. 'microseconds': Include full time in HH:MM:SS.ffffff format. Note Excluded time components are truncated, not rounded. ValueError will be raised on an invalid timespec argument: >>> from datetime import datetime >>> datetime.now().isoformat(timespec='minutes') '2002-12-25T00:00' >>> dt = datetime(2015, 1, 1, 12, 30, 59, 0) >>> dt.isoformat(timespec='microseconds') '2015-01-01T12:30:59.000000' Changed in version 3.6: Added the timespec parameter. datetime.__str__()Â¶ For a datetime instance d, str(d) is equivalent to d.isoformat(' '). datetime.ctime()Â¶ Return a string representing the date and time: >>> from datetime import datetime >>> datetime(2002, 12, 4, 20, 30, 40).ctime() 'Wed Dec 4 20:30:40 2002' The output string will not include time zone information, regardless of whether the input is aware or naive. d.ctime() is equivalent to: time.ctime(time.mktime(d.timetuple())) on platforms where the native C ctime() function (which time.ctime() invokes, but which datetime.ctime() does not invoke) conforms to the C standard. datetime.strftime(format)Â¶ Return a string representing the date and time, controlled by an explicit format string. See also strftime() and strptime() Behavior and datetime.isoformat(). datetime.__format__(format)Â¶ Same as datetime.strftime(). This makes it possible to specify a format string for a datetime object in formatted string literals and when using str.format(). See also strftime() and strptime() Behavior and datetime.isoformat(). Examples of Usage: datetimeÂ¶ Examples of working with datetime objects: >>> from datetime import datetime, date, time, timezone >>> # Using datetime.combine() >>> d = date(2005, 7, 14) >>> t = time(12, 30) >>> datetime.combine(d, t) datetime.datetime(2005, 7, 14, 12, 30) >>> # Using datetime.now() >>> datetime.now() datetime.datetime(2007, 12, 6, 16, 29, 43, 79043) # GMT +1 >>> datetime.now(timezone.utc) datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone.utc) >>> # Using datetime.strptime() >>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\") >>> dt datetime.datetime(2006, 11, 21, 16, 30) >>> # Using datetime.timetuple() to get tuple of all attributes >>> tt",
    "content_length": 3828
  },
  {
    "id": "datetime_chunk_15",
    "source_file": "datetime",
    "chunk_index": 15,
    "content": "datetime.datetime(2007, 12, 6, 16, 29, 43, 79043) # GMT +1 >>> datetime.now(timezone.utc) datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone.utc) >>> # Using datetime.strptime() >>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\") >>> dt datetime.datetime(2006, 11, 21, 16, 30) >>> # Using datetime.timetuple() to get tuple of all attributes >>> tt = dt.timetuple() >>> for it in tt: ... print(it) ... 2006 # year 11 # month 21 # day 16 # hour 30 # minute 0 # second 1 # weekday (0 = Monday) 325 # number of days since 1st January -1 # dst - method tzinfo.dst() returned None >>> # Date in ISO format >>> ic = dt.isocalendar() >>> for it in ic: ... print(it) ... 2006 # ISO year 47 # ISO week 2 # ISO weekday >>> # Formatting a datetime >>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\") 'Tuesday, 21. November 2006 04:30PM' >>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'.format(dt, \"day\", \"month\", \"time\") 'The day is 21, the month is November, the time is 04:30PM.' The example below defines a tzinfo subclass capturing time zone information for Kabul, Afghanistan, which used +4 UTC until 1945 and then +4:30 UTC thereafter: from datetime import timedelta, datetime, tzinfo, timezone class KabulTz(tzinfo): # Kabul used +4 until 1945, when they moved to +4:30 UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc) def utcoffset(self, dt): if dt.year < 1945: return timedelta(hours=4) elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, 30): # An ambiguous (\"imaginary\") half-hour range representing # a 'fold' in time due to the shift from +4 to +4:30. # If dt falls in the imaginary range, use fold to decide how # to resolve. See PEP495. return timedelta(hours=4, minutes=(30 if dt.fold else 0)) else: return timedelta(hours=4, minutes=30) def fromutc(self, dt): # Follow same validations as in datetime.tzinfo if not isinstance(dt, datetime): raise TypeError(\"fromutc() requires a datetime argument\") if dt.tzinfo is not self: raise ValueError(\"dt.tzinfo is not self\") # A custom implementation is required for fromutc as # the input to this function is a datetime with utc values # but with a tzinfo set to self. # See datetime.astimezone or fromtimestamp. if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE: return dt + timedelta(hours=4, minutes=30) else: return dt + timedelta(hours=4) def dst(self, dt): # Kabul does not observe daylight saving time. return timedelta(0) def tzname(self, dt): if dt >= self.UTC_MOVE_DATE: return \"+04:30\" return \"+04\" Usage of KabulTz from above: >>> tz1 = KabulTz() >>> # Datetime before the change >>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1) >>> print(dt1.utcoffset()) 4:00:00 >>> # Datetime after the change >>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1) >>> print(dt2.utcoffset()) 4:30:00 >>> # Convert datetime to another time zone >>> dt3 = dt2.astimezone(timezone.utc) >>> dt3 datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc) >>> dt2 datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz()) >>> dt2 == dt3 True time ObjectsÂ¶ A time object represents a (local) time of day, independent of any particular day, and subject to adjustment via a",
    "content_length": 3195
  },
  {
    "id": "datetime_chunk_16",
    "source_file": "datetime",
    "chunk_index": 16,
    "content": "another time zone >>> dt3 = dt2.astimezone(timezone.utc) >>> dt3 datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc) >>> dt2 datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz()) >>> dt2 == dt3 True time ObjectsÂ¶ A time object represents a (local) time of day, independent of any particular day, and subject to adjustment via a tzinfo object. class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)Â¶ All arguments are optional. tzinfo may be None, or an instance of a tzinfo subclass. The remaining arguments must be integers in the following ranges: 0 <= hour < 24, 0 <= minute < 60, 0 <= second < 60, 0 <= microsecond < 1000000, fold in [0, 1]. If an argument outside those ranges is given, ValueError is raised. All default to 0 except tzinfo, which defaults to None. Class attributes: time.minÂ¶ The earliest representable time, time(0, 0, 0, 0). time.maxÂ¶ The latest representable time, time(23, 59, 59, 999999). time.resolutionÂ¶ The smallest possible difference between non-equal time objects, timedelta(microseconds=1), although note that arithmetic on time objects is not supported. Instance attributes (read-only): time.hourÂ¶ In range(24). time.minuteÂ¶ In range(60). time.secondÂ¶ In range(60). time.microsecondÂ¶ In range(1000000). time.tzinfoÂ¶ The object passed as the tzinfo argument to the time constructor, or None if none was passed. time.foldÂ¶ In [0, 1]. Used to disambiguate wall times during a repeated interval. (A repeated interval occurs when clocks are rolled back at the end of daylight saving time or when the UTC offset for the current zone is decreased for political reasons.) The values 0 and 1 represent, respectively, the earlier and later of the two moments with the same wall time representation. Added in version 3.6. time objects support equality and order comparisons, where a is considered less than b when a precedes b in time. Naive and aware time objects are never equal. Order comparison between naive and aware time objects raises TypeError. If both comparands are aware, and have the same tzinfo attribute, the tzinfo and fold attributes are ignored and the base times are compared. If both comparands are aware and have different tzinfo attributes, the comparands are first adjusted by subtracting their UTC offsets (obtained from self.utcoffset()). Changed in version 3.3: Equality comparisons between aware and naive time instances donât raise TypeError. In Boolean contexts, a time object is always considered to be true. Changed in version 3.5: Before Python 3.5, a time object was considered to be false if it represented midnight in UTC. This behavior was considered obscure and error-prone and has been removed in Python 3.5. See bpo-13936 for full details. Other constructor: classmethod time.fromisoformat(time_string)Â¶ Return a time corresponding to a time_string in any valid ISO 8601 format, with the following exceptions: Time zone offsets may have fractional seconds. The leading T, normally required in cases where there may be ambiguity between a date and a time, is not required. Fractional seconds may have any number of digits (anything beyond 6 will be truncated). Fractional hours and minutes are not supported. Examples: >>> from datetime import time >>>",
    "content_length": 3278
  },
  {
    "id": "datetime_chunk_17",
    "source_file": "datetime",
    "chunk_index": 17,
    "content": "seconds. The leading T, normally required in cases where there may be ambiguity between a date and a time, is not required. Fractional seconds may have any number of digits (anything beyond 6 will be truncated). Fractional hours and minutes are not supported. Examples: >>> from datetime import time >>> time.fromisoformat('04:23:01') datetime.time(4, 23, 1) >>> time.fromisoformat('T04:23:01') datetime.time(4, 23, 1) >>> time.fromisoformat('T042301') datetime.time(4, 23, 1) >>> time.fromisoformat('04:23:01.000384') datetime.time(4, 23, 1, 384) >>> time.fromisoformat('04:23:01,000384') datetime.time(4, 23, 1, 384) >>> time.fromisoformat('04:23:01+04:00') datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400))) >>> time.fromisoformat('04:23:01Z') datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc) >>> time.fromisoformat('04:23:01+00:00') datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc) Added in version 3.7. Changed in version 3.11: Previously, this method only supported formats that could be emitted by time.isoformat(). Instance methods: time.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0)Â¶ Return a new time with the same values, but with specified parameters updated. Note that tzinfo=None can be specified to create a naive time from an aware time, without conversion of the time data. time objects are also supported by generic function copy.replace(). Changed in version 3.6: Added the fold parameter. time.isoformat(timespec='auto')Â¶ Return a string representing the time in ISO 8601 format, one of: HH:MM:SS.ffffff, if microsecond is not 0 HH:MM:SS, if microsecond is 0 HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]], if utcoffset() does not return None HH:MM:SS+HH:MM[:SS[.ffffff]], if microsecond is 0 and utcoffset() does not return None The optional argument timespec specifies the number of additional components of the time to include (the default is 'auto'). It can be one of the following: 'auto': Same as 'seconds' if microsecond is 0, same as 'microseconds' otherwise. 'hours': Include the hour in the two-digit HH format. 'minutes': Include hour and minute in HH:MM format. 'seconds': Include hour, minute, and second in HH:MM:SS format. 'milliseconds': Include full time, but truncate fractional second part to milliseconds. HH:MM:SS.sss format. 'microseconds': Include full time in HH:MM:SS.ffffff format. Note Excluded time components are truncated, not rounded. ValueError will be raised on an invalid timespec argument. Example: >>> from datetime import time >>> time(hour=12, minute=34, second=56, microsecond=123456).isoformat(timespec='minutes') '12:34' >>> dt = time(hour=12, minute=34, second=56, microsecond=0) >>> dt.isoformat(timespec='microseconds') '12:34:56.000000' >>> dt.isoformat(timespec='auto') '12:34:56' Changed in version 3.6: Added the timespec parameter. time.__str__()Â¶ For a time t, str(t) is equivalent to t.isoformat(). time.strftime(format)Â¶ Return a string representing the time, controlled by an explicit format string. See also strftime() and strptime() Behavior and time.isoformat(). time.__format__(format)Â¶ Same as time.strftime(). This makes it possible to specify a format string for a time object in formatted string literals and when using str.format(). See also strftime() and strptime() Behavior and time.isoformat(). time.utcoffset()Â¶ If tzinfo is None, returns None, else returns self.tzinfo.utcoffset(None), and raises an exception if the latter doesnât return None or a timedelta object with magnitude less than one day. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. time.dst()Â¶ If tzinfo is None, returns None, else returns self.tzinfo.dst(None), and raises an exception if the latter doesnât return None, or a timedelta object with magnitude less than one day. Changed in version 3.7: The DST offset is not restricted",
    "content_length": 3950
  },
  {
    "id": "datetime_chunk_18",
    "source_file": "datetime",
    "chunk_index": 18,
    "content": "offset is not restricted to a whole number of minutes. time.dst()Â¶ If tzinfo is None, returns None, else returns self.tzinfo.dst(None), and raises an exception if the latter doesnât return None, or a timedelta object with magnitude less than one day. Changed in version 3.7: The DST offset is not restricted to a whole number of minutes. time.tzname()Â¶ If tzinfo is None, returns None, else returns self.tzinfo.tzname(None), or raises an exception if the latter doesnât return None or a string object. Examples of Usage: timeÂ¶ Examples of working with a time object: >>> from datetime import time, tzinfo, timedelta >>> class TZ1(tzinfo): ... def utcoffset(self, dt): ... return timedelta(hours=1) ... def dst(self, dt): ... return timedelta(0) ... def tzname(self,dt): ... return \"+01:00\" ... def __repr__(self): ... return f\"{self.__class__.__name__}()\" ... >>> t = time(12, 10, 30, tzinfo=TZ1()) >>> t datetime.time(12, 10, 30, tzinfo=TZ1()) >>> t.isoformat() '12:10:30+01:00' >>> t.dst() datetime.timedelta(0) >>> t.tzname() '+01:00' >>> t.strftime(\"%H:%M:%S %Z\") '12:10:30 +01:00' >>> 'The {} is {:%H:%M}.'.format(\"time\", t) 'The time is 12:10.' tzinfo ObjectsÂ¶ class datetime.tzinfoÂ¶ This is an abstract base class, meaning that this class should not be instantiated directly. Define a subclass of tzinfo to capture information about a particular time zone. An instance of (a concrete subclass of) tzinfo can be passed to the constructors for datetime and time objects. The latter objects view their attributes as being in local time, and the tzinfo object supports methods revealing offset of local time from UTC, the name of the time zone, and DST offset, all relative to a date or time object passed to them. You need to derive a concrete subclass, and (at least) supply implementations of the standard tzinfo methods needed by the datetime methods you use. The datetime module provides timezone, a simple concrete subclass of tzinfo which can represent time zones with fixed offset from UTC such as UTC itself or North American EST and EDT. Special requirement for pickling: A tzinfo subclass must have an __init__() method that can be called with no arguments, otherwise it can be pickled but possibly not unpickled again. This is a technical requirement that may be relaxed in the future. A concrete subclass of tzinfo may need to implement the following methods. Exactly which methods are needed depends on the uses made of aware datetime objects. If in doubt, simply implement all of them. tzinfo.utcoffset(dt)Â¶ Return offset of local time from UTC, as a timedelta object that is positive east of UTC. If local time is west of UTC, this should be negative. This represents the total offset from UTC; for example, if a tzinfo object represents both time zone and DST adjustments, utcoffset() should return their sum. If the UTC offset isnât known, return None. Else the value returned must be a timedelta object strictly between -timedelta(hours=24) and timedelta(hours=24) (the magnitude of the offset must be less than one day). Most implementations of utcoffset() will probably look like one of these two: return CONSTANT # fixed-offset class return CONSTANT + self.dst(dt) # daylight-aware",
    "content_length": 3218
  },
  {
    "id": "datetime_chunk_19",
    "source_file": "datetime",
    "chunk_index": 19,
    "content": "return None. Else the value returned must be a timedelta object strictly between -timedelta(hours=24) and timedelta(hours=24) (the magnitude of the offset must be less than one day). Most implementations of utcoffset() will probably look like one of these two: return CONSTANT # fixed-offset class return CONSTANT + self.dst(dt) # daylight-aware class If utcoffset() does not return None, dst() should not return None either. The default implementation of utcoffset() raises NotImplementedError. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. tzinfo.dst(dt)Â¶ Return the daylight saving time (DST) adjustment, as a timedelta object or None if DST information isnât known. Return timedelta(0) if DST is not in effect. If DST is in effect, return the offset as a timedelta object (see utcoffset() for details). Note that DST offset, if applicable, has already been added to the UTC offset returned by utcoffset(), so thereâs no need to consult dst() unless youâre interested in obtaining DST info separately. For example, datetime.timetuple() calls its tzinfo attributeâs dst() method to determine how the tm_isdst flag should be set, and tzinfo.fromutc() calls dst() to account for DST changes when crossing time zones. An instance tz of a tzinfo subclass that models both standard and daylight times must be consistent in this sense: tz.utcoffset(dt) - tz.dst(dt) must return the same result for every datetime dt with dt.tzinfo == tz. For sane tzinfo subclasses, this expression yields the time zoneâs âstandard offsetâ, which should not depend on the date or the time, but only on geographic location. The implementation of datetime.astimezone() relies on this, but cannot detect violations; itâs the programmerâs responsibility to ensure it. If a tzinfo subclass cannot guarantee this, it may be able to override the default implementation of tzinfo.fromutc() to work correctly with astimezone() regardless. Most implementations of dst() will probably look like one of these two: def dst(self, dt): # a fixed-offset class: doesn't account for DST return timedelta(0) or: def dst(self, dt): # Code to set dston and dstoff to the time zone's DST # transition times based on the input dt.year, and expressed # in standard local time. if dston <= dt.replace(tzinfo=None) < dstoff: return timedelta(hours=1) else: return timedelta(0) The default implementation of dst() raises NotImplementedError. Changed in version 3.7: The DST offset is not restricted to a whole number of minutes. tzinfo.tzname(dt)Â¶ Return the time zone name corresponding to the datetime object dt, as a string. Nothing about string names is defined by the datetime module, and thereâs no requirement that it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\", \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies. Return None if a string name isnât known. Note that this is a method rather than a fixed string primarily because some tzinfo subclasses will wish to return different names depending on the specific value of dt passed, especially if the tzinfo class is accounting for daylight time. The default implementation of tzname() raises NotImplementedError. These methods are called by a datetime or time",
    "content_length": 3274
  },
  {
    "id": "datetime_chunk_20",
    "source_file": "datetime",
    "chunk_index": 20,
    "content": "rather than a fixed string primarily because some tzinfo subclasses will wish to return different names depending on the specific value of dt passed, especially if the tzinfo class is accounting for daylight time. The default implementation of tzname() raises NotImplementedError. These methods are called by a datetime or time object, in response to their methods of the same names. A datetime object passes itself as the argument, and a time object passes None as the argument. A tzinfo subclassâs methods should therefore be prepared to accept a dt argument of None, or of class datetime. When None is passed, itâs up to the class designer to decide the best response. For example, returning None is appropriate if the class wishes to say that time objects donât participate in the tzinfo protocols. It may be more useful for utcoffset(None) to return the standard UTC offset, as there is no other convention for discovering the standard offset. When a datetime object is passed in response to a datetime method, dt.tzinfo is the same object as self. tzinfo methods can rely on this, unless user code calls tzinfo methods directly. The intent is that the tzinfo methods interpret dt as being in local time, and not need worry about objects in other time zones. There is one more tzinfo method that a subclass may wish to override: tzinfo.fromutc(dt)Â¶ This is called from the default datetime.astimezone() implementation. When called from that, dt.tzinfo is self, and dtâs date and time data are to be viewed as expressing a UTC time. The purpose of fromutc() is to adjust the date and time data, returning an equivalent datetime in selfâs local time. Most tzinfo subclasses should be able to inherit the default fromutc() implementation without problems. Itâs strong enough to handle fixed-offset time zones, and time zones accounting for both standard and daylight time, and the latter even if the DST transition times differ in different years. An example of a time zone the default fromutc() implementation may not handle correctly in all cases is one where the standard offset (from UTC) depends on the specific date and time passed, which can happen for political reasons. The default implementations of astimezone() and fromutc() may not produce the result you want if the result is one of the hours straddling the moment the standard offset changes. Skipping code for error cases, the default fromutc() implementation acts like: def fromutc(self, dt): # raise ValueError error if dt.tzinfo is not self dtoff = dt.utcoffset() dtdst = dt.dst() # raise ValueError if dtoff is None or dtdst is None delta = dtoff - dtdst # this is self's standard offset if delta: dt += delta # convert to standard local time dtdst = dt.dst() # raise ValueError if dtdst is None if dtdst: return dt + dtdst else: return dt In the following tzinfo_examples.py file there are some examples of tzinfo classes: from datetime import tzinfo, timedelta, datetime ZERO = timedelta(0) HOUR = timedelta(hours=1) SECOND = timedelta(seconds=1) # A class",
    "content_length": 3043
  },
  {
    "id": "datetime_chunk_21",
    "source_file": "datetime",
    "chunk_index": 21,
    "content": "time dtdst = dt.dst() # raise ValueError if dtdst is None if dtdst: return dt + dtdst else: return dt In the following tzinfo_examples.py file there are some examples of tzinfo classes: from datetime import tzinfo, timedelta, datetime ZERO = timedelta(0) HOUR = timedelta(hours=1) SECOND = timedelta(seconds=1) # A class capturing the platform's idea of local time. # (May result in wrong values on historical times in # timezones where UTC offset and/or the DST rules had # changed in the past.) import time as _time STDOFFSET = timedelta(seconds = -_time.timezone) if _time.daylight: DSTOFFSET = timedelta(seconds = -_time.altzone) else: DSTOFFSET = STDOFFSET DSTDIFF = DSTOFFSET - STDOFFSET class LocalTimezone(tzinfo): def fromutc(self, dt): assert dt.tzinfo is self stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND args = _time.localtime(stamp)[:6] dst_diff = DSTDIFF // SECOND # Detect fold fold = (args == _time.localtime(stamp - dst_diff)) return datetime(*args, microsecond=dt.microsecond, tzinfo=self, fold=fold) def utcoffset(self, dt): if self._isdst(dt): return DSTOFFSET else: return STDOFFSET def dst(self, dt): if self._isdst(dt): return DSTDIFF else: return ZERO def tzname(self, dt): return _time.tzname[self._isdst(dt)] def _isdst(self, dt): tt = (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.weekday(), 0, 0) stamp = _time.mktime(tt) tt = _time.localtime(stamp) return tt.tm_isdst > 0 Local = LocalTimezone() # A complete implementation of current DST rules for major US time zones. def first_sunday_on_or_after(dt): days_to_go = 6 - dt.weekday() if days_to_go: dt += timedelta(days_to_go) return dt # US DST Rules # # This is a simplified (i.e., wrong for a few cases) set of rules for US # DST start and end times. For a complete and up-to-date set of DST rules # and timezone definitions, visit the Olson Database (or try pytz): # http://www.twinsun.com/tz/tz-link.htm # https://sourceforge.net/projects/pytz/ (might not be up-to-date) # # In the US, since 2007, DST starts at 2am (standard time) on the second # Sunday in March, which is the first Sunday on or after Mar 8. DSTSTART_2007 = datetime(1, 3, 8, 2) # and ends at 2am (DST time) on the first Sunday of Nov. DSTEND_2007 = datetime(1, 11, 1, 2) # From 1987 to 2006, DST used to start at 2am (standard time) on the first # Sunday in April and to end at 2am (DST time) on the last # Sunday of October, which is the first Sunday on or after Oct 25. DSTSTART_1987_2006 = datetime(1, 4, 1, 2) DSTEND_1987_2006 = datetime(1, 10, 25, 2) # From 1967 to 1986, DST used to start at 2am (standard time) on the last # Sunday in April (the one on or after April 24) and to end at 2am (DST time) # on the last Sunday of October, which is the first Sunday # on or after Oct 25. DSTSTART_1967_1986 = datetime(1, 4, 24, 2) DSTEND_1967_1986 = DSTEND_1987_2006 def us_dst_range(year): # Find start and end times for US DST. For years before 1967, return # start = end for no DST. if 2006 < year: dststart, dstend = DSTSTART_2007, DSTEND_2007 elif 1986 < year < 2007: dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006 elif 1966",
    "content_length": 3122
  },
  {
    "id": "datetime_chunk_22",
    "source_file": "datetime",
    "chunk_index": 22,
    "content": "24, 2) DSTEND_1967_1986 = DSTEND_1987_2006 def us_dst_range(year): # Find start and end times for US DST. For years before 1967, return # start = end for no DST. if 2006 < year: dststart, dstend = DSTSTART_2007, DSTEND_2007 elif 1986 < year < 2007: dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006 elif 1966 < year < 1987: dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986 else: return (datetime(year, 1, 1), ) * 2 start = first_sunday_on_or_after(dststart.replace(year=year)) end = first_sunday_on_or_after(dstend.replace(year=year)) return start, end class USTimeZone(tzinfo): def __init__(self, hours, reprname, stdname, dstname): self.stdoffset = timedelta(hours=hours) self.reprname = reprname self.stdname = stdname self.dstname = dstname def __repr__(self): return self.reprname def tzname(self, dt): if self.dst(dt): return self.dstname else: return self.stdname def utcoffset(self, dt): return self.stdoffset + self.dst(dt) def dst(self, dt): if dt is None or dt.tzinfo is None: # An exception may be sensible here, in one or both cases. # It depends on how you want to treat them. The default # fromutc() implementation (called by the default astimezone() # implementation) passes a datetime with dt.tzinfo is self. return ZERO assert dt.tzinfo is self start, end = us_dst_range(dt.year) # Can't compare naive to aware objects, so strip the timezone from # dt first. dt = dt.replace(tzinfo=None) if start + HOUR <= dt < end - HOUR: # DST is in effect. return HOUR if end - HOUR <= dt < end: # Fold (an ambiguous hour): use dt.fold to disambiguate. return ZERO if dt.fold else HOUR if start <= dt < start + HOUR: # Gap (a non-existent hour): reverse the fold rule. return HOUR if dt.fold else ZERO # DST is off. return ZERO def fromutc(self, dt): assert dt.tzinfo is self start, end = us_dst_range(dt.year) start = start.replace(tzinfo=self) end = end.replace(tzinfo=self) std_time = dt + self.stdoffset dst_time = std_time + HOUR if end <= dst_time < end + HOUR: # Repeated hour return std_time.replace(fold=1) if std_time < start or dst_time >= end: # Standard time return std_time if start <= std_time < end - HOUR: # Daylight saving time return dst_time Eastern = USTimeZone(-5, \"Eastern\", \"EST\", \"EDT\") Central = USTimeZone(-6, \"Central\", \"CST\", \"CDT\") Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\") Pacific = USTimeZone(-8, \"Pacific\", \"PST\", \"PDT\") Note that there are unavoidable subtleties twice per year in a tzinfo subclass accounting for both standard and daylight time, at the DST transition points. For concreteness, consider US Eastern (UTC -0500), where EDT begins the minute after 1:59 (EST) on the second Sunday in March, and ends the minute after 1:59 (EDT) on the first Sunday in November: UTC 3:MM 4:MM 5:MM 6:MM 7:MM 8:MM EST 22:MM 23:MM 0:MM 1:MM 2:MM 3:MM EDT 23:MM 0:MM 1:MM 2:MM 3:MM 4:MM start 22:MM 23:MM 0:MM 1:MM 3:MM 4:MM end 23:MM 0:MM 1:MM 1:MM 2:MM 3:MM When DST starts (the âstartâ line), the local wall clock leaps from 1:59 to 3:00. A wall time of the form 2:MM doesnât really make sense on that day, so astimezone(Eastern) wonât deliver a result with hour == 2 on the day DST begins. For example, at the Spring",
    "content_length": 3182
  },
  {
    "id": "datetime_chunk_23",
    "source_file": "datetime",
    "chunk_index": 23,
    "content": "3:MM When DST starts (the âstartâ line), the local wall clock leaps from 1:59 to 3:00. A wall time of the form 2:MM doesnât really make sense on that day, so astimezone(Eastern) wonât deliver a result with hour == 2 on the day DST begins. For example, at the Spring forward transition of 2016, we get: >>> from datetime import datetime, timezone >>> from tzinfo_examples import HOUR, Eastern >>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc) >>> for i in range(4): ... u = u0 + i*HOUR ... t = u.astimezone(Eastern) ... print(u.time(), 'UTC =', t.time(), t.tzname()) ... 05:00:00 UTC = 00:00:00 EST 06:00:00 UTC = 01:00:00 EST 07:00:00 UTC = 03:00:00 EDT 08:00:00 UTC = 04:00:00 EDT When DST ends (the âendâ line), thereâs a potentially worse problem: thereâs an hour that canât be spelled unambiguously in local wall time: the last hour of daylight time. In Eastern, thatâs times of the form 5:MM UTC on the day daylight time ends. The local wall clock leaps from 1:59 (daylight time) back to 1:00 (standard time) again. Local times of the form 1:MM are ambiguous. astimezone() mimics the local clockâs behavior by mapping two adjacent UTC hours into the same local hour then. In the Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when converted to Eastern, but earlier times have the fold attribute set to 0 and the later times have it set to 1. For example, at the Fall back transition of 2016, we get: >>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc) >>> for i in range(4): ... u = u0 + i*HOUR ... t = u.astimezone(Eastern) ... print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold) ... 04:00:00 UTC = 00:00:00 EDT 0 05:00:00 UTC = 01:00:00 EDT 0 06:00:00 UTC = 01:00:00 EST 1 07:00:00 UTC = 02:00:00 EST 0 Note that the datetime instances that differ only by the value of the fold attribute are considered equal in comparisons. Applications that canât bear wall-time ambiguities should explicitly check the value of the fold attribute or avoid using hybrid tzinfo subclasses; there are no ambiguities when using timezone, or any other fixed-offset tzinfo subclass (such as a class representing only EST (fixed offset -5 hours), or only EDT (fixed offset -4 hours)). See also zoneinfoThe datetime module has a basic timezone class (for handling arbitrary fixed offsets from UTC) and its timezone.utc attribute (a UTC timezone instance). zoneinfo brings the IANA time zone database (also known as the Olson database) to Python, and its usage is recommended. IANA time zone databaseThe Time Zone Database (often called tz, tzdata or zoneinfo) contains code and data that represent the history of local time for many representative locations around the globe. It is updated periodically to reflect changes made by political bodies to time zone boundaries, UTC offsets, and daylight-saving rules. timezone ObjectsÂ¶ The timezone class is a subclass of tzinfo, each instance of which represents a time zone defined by a fixed offset from",
    "content_length": 2993
  },
  {
    "id": "datetime_chunk_24",
    "source_file": "datetime",
    "chunk_index": 24,
    "content": "many representative locations around the globe. It is updated periodically to reflect changes made by political bodies to time zone boundaries, UTC offsets, and daylight-saving rules. timezone ObjectsÂ¶ The timezone class is a subclass of tzinfo, each instance of which represents a time zone defined by a fixed offset from UTC. Objects of this class cannot be used to represent time zone information in the locations where different offsets are used in different days of the year or where historical changes have been made to civil time. class datetime.timezone(offset, name=None)Â¶ The offset argument must be specified as a timedelta object representing the difference between the local time and UTC. It must be strictly between -timedelta(hours=24) and timedelta(hours=24), otherwise ValueError is raised. The name argument is optional. If specified it must be a string that will be used as the value returned by the datetime.tzname() method. Added in version 3.2. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. timezone.utcoffset(dt)Â¶ Return the fixed value specified when the timezone instance is constructed. The dt argument is ignored. The return value is a timedelta instance equal to the difference between the local time and UTC. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. timezone.tzname(dt)Â¶ Return the fixed value specified when the timezone instance is constructed. If name is not provided in the constructor, the name returned by tzname(dt) is generated from the value of the offset as follows. If offset is timedelta(0), the name is âUTCâ, otherwise it is a string in the format UTCÂ±HH:MM, where Â± is the sign of offset, HH and MM are two digits of offset.hours and offset.minutes respectively. Changed in version 3.6: Name generated from offset=timedelta(0) is now plain 'UTC', not 'UTC+00:00'. timezone.dst(dt)Â¶ Always returns None. timezone.fromutc(dt)Â¶ Return dt + offset. The dt argument must be an aware datetime instance, with tzinfo set to self. Class attributes: timezone.utcÂ¶ The UTC time zone, timezone(timedelta(0)). strftime() and strptime() BehaviorÂ¶ date, datetime, and time objects all support a strftime(format) method, to create a string representing the time under the control of an explicit format string. Conversely, the datetime.strptime() class method creates a datetime object from a string representing a date and time and a corresponding format string. The table below provides a high-level comparison of strftime() versus strptime(): strftime strptime Usage Convert object to a string according to a given format Parse a string into a datetime object given a corresponding format Type of method Instance method Class method Method of date; datetime; time datetime Signature strftime(format) strptime(date_string, format) strftime() and strptime() Format CodesÂ¶ These methods accept format codes that can be used to parse and format dates: >>> datetime.strptime('31/01/22 23:59:59.999999', ... '%d/%m/%y %H:%M:%S.%f') datetime.datetime(2022, 1, 31, 23, 59, 59, 999999) >>> _.strftime('%a %d %b %Y, %I:%M%p') 'Mon 31 Jan 2022, 11:59PM' The following is a list of all the format codes that the 1989 C standard requires, and these work on all platforms with a",
    "content_length": 3296
  },
  {
    "id": "datetime_chunk_25",
    "source_file": "datetime",
    "chunk_index": 25,
    "content": "format dates: >>> datetime.strptime('31/01/22 23:59:59.999999', ... '%d/%m/%y %H:%M:%S.%f') datetime.datetime(2022, 1, 31, 23, 59, 59, 999999) >>> _.strftime('%a %d %b %Y, %I:%M%p') 'Mon 31 Jan 2022, 11:59PM' The following is a list of all the format codes that the 1989 C standard requires, and these work on all platforms with a standard C implementation. Directive Meaning Example Notes %a Weekday as localeâs abbreviated name. Sun, Mon, â¦, Sat (en_US); So, Mo, â¦, Sa (de_DE) (1) %A Weekday as localeâs full name. Sunday, Monday, â¦, Saturday (en_US); Sonntag, Montag, â¦, Samstag (de_DE) (1) %w Weekday as a decimal number, where 0 is Sunday and 6 is Saturday. 0, 1, â¦, 6 %d Day of the month as a zero-padded decimal number. 01, 02, â¦, 31 (9) %b Month as localeâs abbreviated name. Jan, Feb, â¦, Dec (en_US); Jan, Feb, â¦, Dez (de_DE) (1) %B Month as localeâs full name. January, February, â¦, December (en_US); Januar, Februar, â¦, Dezember (de_DE) (1) %m Month as a zero-padded decimal number. 01, 02, â¦, 12 (9) %y Year without century as a zero-padded decimal number. 00, 01, â¦, 99 (9) %Y Year with century as a decimal number. 0001, 0002, â¦, 2013, 2014, â¦, 9998, 9999 (2) %H Hour (24-hour clock) as a zero-padded decimal number. 00, 01, â¦, 23 (9) %I Hour (12-hour clock) as a zero-padded decimal number. 01, 02, â¦, 12 (9) %p Localeâs equivalent of either AM or PM. AM, PM (en_US); am, pm (de_DE) (1), (3) %M Minute as a zero-padded decimal number. 00, 01, â¦, 59 (9) %S Second as a zero-padded decimal number. 00, 01, â¦, 59 (4), (9) %f Microsecond as a decimal number, zero-padded to 6 digits. 000000, 000001, â¦, 999999 (5) %z UTC offset in the form Â±HHMM[SS[.ffffff]] (empty string if the object is naive). (empty), +0000, -0400, +1030, +063415, -030712.345216 (6) %Z Time zone name (empty string if the object is naive). (empty), UTC, GMT (6) %j Day of the year as a zero-padded decimal number. 001, 002, â¦, 366 (9) %U Week number of the year (Sunday as the first day of the week) as a zero-padded decimal number. All days in a new year preceding the first Sunday are considered to be in week 0. 00, 01, â¦, 53 (7), (9) %W Week number of the year (Monday as the first day of the week) as a zero-padded decimal number. All days in a new year preceding the first Monday are considered to be in week 0. 00, 01, â¦, 53 (7), (9) %c Localeâs appropriate date and time representation. Tue Aug 16 21:30:00 1988 (en_US); Di 16 Aug 21:30:00 1988 (de_DE) (1) %x Localeâs appropriate date representation. 08/16/88 (None); 08/16/1988 (en_US); 16.08.1988 (de_DE) (1) %X Localeâs appropriate time representation. 21:30:00 (en_US); 21:30:00 (de_DE) (1) %% A literal '%' character. % Several additional directives not required by the C89 standard are included for convenience. These parameters all correspond to ISO 8601 date values. Directive Meaning Example Notes %G ISO 8601 year with century",
    "content_length": 2940
  },
  {
    "id": "datetime_chunk_26",
    "source_file": "datetime",
    "chunk_index": 26,
    "content": "(de_DE) (1) %X Localeâs appropriate time representation. 21:30:00 (en_US); 21:30:00 (de_DE) (1) %% A literal '%' character. % Several additional directives not required by the C89 standard are included for convenience. These parameters all correspond to ISO 8601 date values. Directive Meaning Example Notes %G ISO 8601 year with century representing the year that contains the greater part of the ISO week (%V). 0001, 0002, â¦, 2013, 2014, â¦, 9998, 9999 (8) %u ISO 8601 weekday as a decimal number where 1 is Monday. 1, 2, â¦, 7 %V ISO 8601 week as a decimal number with Monday as the first day of the week. Week 01 is the week containing Jan 4. 01, 02, â¦, 53 (8), (9) %:z UTC offset in the form Â±HH:MM[:SS[.ffffff]] (empty string if the object is naive). (empty), +00:00, -04:00, +10:30, +06:34:15, -03:07:12.345216 (6) These may not be available on all platforms when used with the strftime() method. The ISO 8601 year and ISO 8601 week directives are not interchangeable with the year and week number directives above. Calling strptime() with incomplete or ambiguous ISO 8601 directives will raise a ValueError. The full set of format codes supported varies across platforms, because Python calls the platform C libraryâs strftime() function, and platform variations are common. To see the full set of format codes supported on your platform, consult the strftime(3) documentation. There are also differences between platforms in handling of unsupported format specifiers. Added in version 3.6: %G, %u and %V were added. Added in version 3.12: %:z was added. Technical DetailÂ¶ Broadly speaking, d.strftime(fmt) acts like the time moduleâs time.strftime(fmt, d.timetuple()) although not all objects support a timetuple() method. For the datetime.strptime() class method, the default value is 1900-01-01T00:00:00.000: any components not specified in the format string will be pulled from the default value. [4] Using datetime.strptime(date_string, format) is equivalent to: datetime(*(time.strptime(date_string, format)[0:6])) except when the format includes sub-second components or time zone offset information, which are supported in datetime.strptime but are discarded by time.strptime. For time objects, the format codes for year, month, and day should not be used, as time objects have no such values. If theyâre used anyway, 1900 is substituted for the year, and 1 for the month and day. For date objects, the format codes for hours, minutes, seconds, and microseconds should not be used, as date objects have no such values. If theyâre used anyway, 0 is substituted for them. For the same reason, handling of format strings containing Unicode code points that canât be represented in the charset of the current locale is also platform-dependent. On some platforms such code points are preserved intact in the output, while on others strftime may raise UnicodeError or return an empty string instead. Notes: Because the format depends on the current locale, care should be taken when making assumptions about the output value. Field orderings will vary (for example, âmonth/day/yearâ versus âday/month/yearâ), and the output may contain non-ASCII characters. The strptime() method can parse years in the full [1,",
    "content_length": 3249
  },
  {
    "id": "datetime_chunk_27",
    "source_file": "datetime",
    "chunk_index": 27,
    "content": "an empty string instead. Notes: Because the format depends on the current locale, care should be taken when making assumptions about the output value. Field orderings will vary (for example, âmonth/day/yearâ versus âday/month/yearâ), and the output may contain non-ASCII characters. The strptime() method can parse years in the full [1, 9999] range, but years < 1000 must be zero-filled to 4-digit width. Changed in version 3.2: In previous versions, strftime() method was restricted to years >= 1900. Changed in version 3.3: In version 3.2, strftime() method was restricted to years >= 1000. When used with the strptime() method, the %p directive only affects the output hour field if the %I directive is used to parse the hour. Unlike the time module, the datetime module does not support leap seconds. When used with the strptime() method, the %f directive accepts from one to six digits and zero pads on the right. %f is an extension to the set of format characters in the C standard (but implemented separately in datetime objects, and therefore always available). For a naive object, the %z, %:z and %Z format codes are replaced by empty strings. For an aware object: %zutcoffset() is transformed into a string of the form Â±HHMM[SS[.ffffff]], where HH is a 2-digit string giving the number of UTC offset hours, MM is a 2-digit string giving the number of UTC offset minutes, SS is a 2-digit string giving the number of UTC offset seconds and ffffff is a 6-digit string giving the number of UTC offset microseconds. The ffffff part is omitted when the offset is a whole number of seconds and both the ffffff and the SS part is omitted when the offset is a whole number of minutes. For example, if utcoffset() returns timedelta(hours=-3, minutes=-30), %z is replaced with the string '-0330'. Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes. Changed in version 3.7: When the %z directive is provided to the strptime() method, the UTC offsets can have a colon as a separator between hours, minutes and seconds. For example, '+01:00:00' will be parsed as an offset of one hour. In addition, providing 'Z' is identical to '+00:00'. %:zBehaves exactly as %z, but has a colon separator added between hours, minutes and seconds. %ZIn strftime(), %Z is replaced by an empty string if tzname() returns None; otherwise %Z is replaced by the returned value, which must be a string. strptime() only accepts certain values for %Z: any value in time.tzname for your machineâs locale the hard-coded values UTC and GMT So someone living in Japan may have JST, UTC, and GMT as valid values, but probably not EST. It will raise ValueError for invalid values. Changed in version 3.2: When the %z directive is provided to the strptime() method, an aware datetime object will be produced. The tzinfo of the result will be set to a timezone instance. When used with the strptime() method, %U and %W are only used in calculations",
    "content_length": 2959
  },
  {
    "id": "datetime_chunk_28",
    "source_file": "datetime",
    "chunk_index": 28,
    "content": "for invalid values. Changed in version 3.2: When the %z directive is provided to the strptime() method, an aware datetime object will be produced. The tzinfo of the result will be set to a timezone instance. When used with the strptime() method, %U and %W are only used in calculations when the day of the week and the calendar year (%Y) are specified. Similar to %U and %W, %V is only used in calculations when the day of the week and the ISO year (%G) are specified in a strptime() format string. Also note that %G and %Y are not interchangeable. When used with the strptime() method, the leading zero is optional for formats %d, %m, %H, %I, %M, %S, %j, %U, %W, and %V. Format %y does require a leading zero. When parsing a month and day using strptime(), always include a year in the format. If the value you need to parse lacks a year, append an explicit dummy leap year. Otherwise your code will raise an exception when it encounters leap day because the default year used by the parser is not a leap year. Users run into this bug every four yearsâ¦ >>> month_day = \"02/29\" >>> datetime.strptime(f\"{month_day};1984\", \"%m/%d;%Y\") # No leap year bug. datetime.datetime(1984, 2, 29, 0, 0) Deprecated since version 3.13, will be removed in version 3.15: strptime() calls using a format string containing a day of month without a year now emit a DeprecationWarning. In 3.15 or later we may change this into an error or change the default year to a leap year. See gh-70647. Footnotes [1] If, that is, we ignore the effects of Relativity [2] This matches the definition of the âproleptic Gregorianâ calendar in Dershowitz and Reingoldâs book Calendrical Calculations, where itâs the base calendar for all computations. See the book for algorithms for converting between proleptic Gregorian ordinals and many other calendar systems. [3] See R. H. van Gentâs guide to the mathematics of the ISO 8601 calendar for a good explanation. [4] Passing datetime.strptime('Feb 29', '%b %d') will fail since 1900 is not a leap year.",
    "content_length": 2029
  },
  {
    "id": "introduction_chunk_0",
    "source_file": "introduction",
    "chunk_index": 0,
    "content": "3. An Informal Introduction to PythonÂ¶ In the following examples, input and output are distinguished by the presence or absence of prompts (>>> and â¦): to repeat the example, you must type everything after the prompt, when the prompt appears; lines that do not begin with a prompt are output from the interpreter. Note that a secondary prompt on a line by itself in an example means you must type a blank line; this is used to end a multi-line command. You can use the âCopyâ button (it appears in the upper-right corner when hovering over or tapping a code example), which strips prompts and omits output, to copy and paste the input lines into your interpreter. Many of the examples in this manual, even those entered at the interactive prompt, include comments. Comments in Python start with the hash character, #, and extend to the end of the physical line. A comment may appear at the start of a line or following whitespace or code, but not within a string literal. A hash character within a string literal is just a hash character. Since comments are to clarify code and are not interpreted by Python, they may be omitted when typing in examples. Some examples: # this is the first comment spam = 1 # and this is the second comment # ... and now a third! text = \"# This is not a comment because it's inside quotes.\" 3.1. Using Python as a CalculatorÂ¶ Letâs try some simple Python commands. Start the interpreter and wait for the primary prompt, >>>. (It shouldnât take long.) 3.1.1. NumbersÂ¶ The interpreter acts as a simple calculator: you can type an expression at it and it will write the value. Expression syntax is straightforward: the operators +, -, * and / can be used to perform arithmetic; parentheses (()) can be used for grouping. For example: >>> 2 + 2 4 >>> 50 - 5*6 20 >>> (50 - 5*6) / 4 5.0 >>> 8 / 5 # division always returns a floating-point number 1.6 The integer numbers (e.g. 2, 4, 20) have type int, the ones with a fractional part (e.g. 5.0, 1.6) have type float. We will see more about numeric types later in the tutorial. Division (/) always returns a float. To do floor division and get an integer result you can use the // operator; to calculate the remainder you can use %: >>> 17 / 3 # classic division returns a float 5.666666666666667 >>> >>> 17 // 3 # floor division discards the fractional part 5 >>> 17 % 3 # the % operator returns the remainder of the division 2 >>> 5 * 3 + 2 # floored quotient * divisor + remainder 17 With Python, it is possible to use the ** operator to calculate powers [1]: >>> 5 ** 2 # 5 squared 25 >>> 2 ** 7 # 2 to the power of 7 128 The equal sign (=) is used to assign",
    "content_length": 2651
  },
  {
    "id": "introduction_chunk_1",
    "source_file": "introduction",
    "chunk_index": 1,
    "content": "# floored quotient * divisor + remainder 17 With Python, it is possible to use the ** operator to calculate powers [1]: >>> 5 ** 2 # 5 squared 25 >>> 2 ** 7 # 2 to the power of 7 128 The equal sign (=) is used to assign a value to a variable. Afterwards, no result is displayed before the next interactive prompt: >>> width = 20 >>> height = 5 * 9 >>> width * height 900 If a variable is not âdefinedâ (assigned a value), trying to use it will give you an error: >>> n # try to access an undefined variable Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'n' is not defined There is full support for floating point; operators with mixed type operands convert the integer operand to floating point: >>> 4 * 3.75 - 1 14.0 In interactive mode, the last printed expression is assigned to the variable _. This means that when you are using Python as a desk calculator, it is somewhat easier to continue calculations, for example: >>> tax = 12.5 / 100 >>> price = 100.50 >>> price * tax 12.5625 >>> price + _ 113.0625 >>> round(_, 2) 113.06 This variable should be treated as read-only by the user. Donât explicitly assign a value to it â you would create an independent local variable with the same name masking the built-in variable with its magic behavior. In addition to int and float, Python supports other types of numbers, such as Decimal and Fraction. Python also has built-in support for complex numbers, and uses the j or J suffix to indicate the imaginary part (e.g. 3+5j). 3.1.2. TextÂ¶ Python can manipulate text (represented by type str, so-called âstringsâ) as well as numbers. This includes characters â!â, words ârabbitâ, names âParisâ, sentences âGot your back.â, etc. âYay! :)â. They can be enclosed in single quotes ('...') or double quotes (\"...\") with the same result [2]. >>> 'spam eggs' # single quotes 'spam eggs' >>> \"Paris rabbit got your back :)! Yay!\" # double quotes 'Paris rabbit got your back :)! Yay!' >>> '1975' # digits and numerals enclosed in quotes are also strings '1975' To quote a quote, we need to âescapeâ it, by preceding it with \\. Alternatively, we can use the other type of quotation marks: >>> 'doesn\\'t' # use \\' to escape the single quote... \"doesn't\" >>> \"doesn't\" # ...or use double quotes instead \"doesn't\" >>> '\"Yes,\" they said.' '\"Yes,\" they said.' >>> \"\\\"Yes,\\\" they said.\" '\"Yes,\" they said.' >>> '\"Isn\\'t,\" they said.' '\"Isn\\'t,\" they said.' In the Python shell, the string definition and output string can look different. The print() function produces a more readable output, by omitting the enclosing quotes and by printing escaped and special characters: >>> s = 'First line.\\nSecond line.' # \\n means newline >>> s # without print(), special characters are included in the string 'First line.\\nSecond line.' >>> print(s) # with print(), special",
    "content_length": 2875
  },
  {
    "id": "introduction_chunk_2",
    "source_file": "introduction",
    "chunk_index": 2,
    "content": "print() function produces a more readable output, by omitting the enclosing quotes and by printing escaped and special characters: >>> s = 'First line.\\nSecond line.' # \\n means newline >>> s # without print(), special characters are included in the string 'First line.\\nSecond line.' >>> print(s) # with print(), special characters are interpreted, so \\n produces new line First line. Second line. If you donât want characters prefaced by \\ to be interpreted as special characters, you can use raw strings by adding an r before the first quote: >>> print('C:\\some\\name') # here \\n means newline! C:\\some ame >>> print(r'C:\\some\\name') # note the r before the quote C:\\some\\name There is one subtle aspect to raw strings: a raw string may not end in an odd number of \\ characters; see the FAQ entry for more information and workarounds. String literals can span multiple lines. One way is using triple-quotes: \"\"\"...\"\"\" or '''...'''. End-of-line characters are automatically included in the string, but itâs possible to prevent this by adding a \\ at the end of the line. In the following example, the initial newline is not included: >>> print(\"\"\"\\ ... Usage: thingy [OPTIONS] ... -h Display this usage message ... -H hostname Hostname to connect to ... \"\"\") Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to >>> Strings can be concatenated (glued together) with the + operator, and repeated with *: >>> # 3 times 'un', followed by 'ium' >>> 3 * 'un' + 'ium' 'unununium' Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically concatenated. >>> 'Py' 'thon' 'Python' This feature is particularly useful when you want to break long strings: >>> text = ('Put several strings within parentheses ' ... 'to have them joined together.') >>> text 'Put several strings within parentheses to have them joined together.' This only works with two literals though, not with variables or expressions: >>> prefix = 'Py' >>> prefix 'thon' # can't concatenate a variable and a string literal File \"<stdin>\", line 1 prefix 'thon' ^^^^^^ SyntaxError: invalid syntax >>> ('un' * 3) 'ium' File \"<stdin>\", line 1 ('un' * 3) 'ium' ^^^^^ SyntaxError: invalid syntax If you want to concatenate variables or a variable and a literal, use +: >>> prefix + 'thon' 'Python' Strings can be indexed (subscripted), with the first character having index 0. There is no separate character type; a character is simply a string of size one: >>> word = 'Python' >>> word[0] # character in position 0 'P' >>> word[5] # character in position 5 'n' Indices may also be negative numbers, to start counting from the right: >>> word[-1] # last character 'n' >>> word[-2] # second-last character 'o' >>> word[-6] 'P' Note that since -0 is the same as 0, negative indices start from -1. In addition to indexing, slicing is also supported. While indexing is used to obtain individual characters, slicing allows you to obtain a substring: >>> word[0:2] #",
    "content_length": 2998
  },
  {
    "id": "introduction_chunk_3",
    "source_file": "introduction",
    "chunk_index": 3,
    "content": "'n' >>> word[-2] # second-last character 'o' >>> word[-6] 'P' Note that since -0 is the same as 0, negative indices start from -1. In addition to indexing, slicing is also supported. While indexing is used to obtain individual characters, slicing allows you to obtain a substring: >>> word[0:2] # characters from position 0 (included) to 2 (excluded) 'Py' >>> word[2:5] # characters from position 2 (included) to 5 (excluded) 'tho' Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults to the size of the string being sliced. >>> word[:2] # character from the beginning to position 2 (excluded) 'Py' >>> word[4:] # characters from position 4 (included) to the end 'on' >>> word[-2:] # characters from the second-last (included) to the end 'on' Note how the start is always included, and the end always excluded. This makes sure that s[:i] + s[i:] is always equal to s: >>> word[:2] + word[2:] 'Python' >>> word[:4] + word[4:] 'Python' One way to remember how slices work is to think of the indices as pointing between characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of n characters has index n, for example: +---+---+---+---+---+---+ | P | y | t | h | o | n | +---+---+---+---+---+---+ 0 1 2 3 4 5 6 -6 -5 -4 -3 -2 -1 The first row of numbers gives the position of the indices 0â¦6 in the string; the second row gives the corresponding negative indices. The slice from i to j consists of all characters between the edges labeled i and j, respectively. For non-negative indices, the length of a slice is the difference of the indices, if both are within bounds. For example, the length of word[1:3] is 2. Attempting to use an index that is too large will result in an error: >>> word[42] # the word only has 6 characters Traceback (most recent call last): File \"<stdin>\", line 1, in <module> IndexError: string index out of range However, out of range slice indexes are handled gracefully when used for slicing: >>> word[4:42] 'on' >>> word[42:] '' Python strings cannot be changed â they are immutable. Therefore, assigning to an indexed position in the string results in an error: >>> word[0] = 'J' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>> word[2:] = 'py' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment If you need a different string, you should create a new one: >>> 'J' + word[1:] 'Jython' >>> word[:2] + 'py' 'Pypy' The built-in function len() returns the length of a string: >>> s = 'supercalifragilisticexpialidocious' >>> len(s) 34 See also Text Sequence Type â strStrings are examples of sequence types, and support the common operations supported by such types. String MethodsStrings support a large",
    "content_length": 2913
  },
  {
    "id": "introduction_chunk_4",
    "source_file": "introduction",
    "chunk_index": 4,
    "content": "word[1:] 'Jython' >>> word[:2] + 'py' 'Pypy' The built-in function len() returns the length of a string: >>> s = 'supercalifragilisticexpialidocious' >>> len(s) 34 See also Text Sequence Type â strStrings are examples of sequence types, and support the common operations supported by such types. String MethodsStrings support a large number of methods for basic transformations and searching. f-stringsString literals that have embedded expressions. Format String SyntaxInformation about string formatting with str.format(). printf-style String FormattingThe old formatting operations invoked when strings are the left operand of the % operator are described in more detail here. 3.1.3. ListsÂ¶ Python knows a number of compound data types, used to group together other values. The most versatile is the list, which can be written as a list of comma-separated values (items) between square brackets. Lists might contain items of different types, but usually the items all have the same type. >>> squares = [1, 4, 9, 16, 25] >>> squares [1, 4, 9, 16, 25] Like strings (and all other built-in sequence types), lists can be indexed and sliced: >>> squares[0] # indexing returns the item 1 >>> squares[-1] 25 >>> squares[-3:] # slicing returns a new list [9, 16, 25] Lists also support operations like concatenation: >>> squares + [36, 49, 64, 81, 100] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content: >>> cubes = [1, 8, 27, 65, 125] # something's wrong here >>> 4 ** 3 # the cube of 4 is 64, not 65! 64 >>> cubes[3] = 64 # replace the wrong value >>> cubes [1, 8, 27, 64, 125] You can also add new items at the end of the list, by using the list.append() method (we will see more about methods later): >>> cubes.append(216) # add the cube of 6 >>> cubes.append(7 ** 3) # and the cube of 7 >>> cubes [1, 8, 27, 64, 125, 216, 343] Simple assignment in Python never copies data. When you assign a list to a variable, the variable refers to the existing list. Any changes you make to the list through one variable will be seen through all other variables that refer to it.: >>> rgb = [\"Red\", \"Green\", \"Blue\"] >>> rgba = rgb >>> id(rgb) == id(rgba) # they reference the same object True >>> rgba.append(\"Alph\") >>> rgb [\"Red\", \"Green\", \"Blue\", \"Alph\"] All slice operations return a new list containing the requested elements. This means that the following slice returns a shallow copy of the list: >>> correct_rgba = rgba[:] >>> correct_rgba[-1] = \"Alpha\" >>> correct_rgba [\"Red\", \"Green\", \"Blue\", \"Alpha\"] >>> rgba [\"Red\", \"Green\", \"Blue\", \"Alph\"] Assignment to slices is also possible, and this can even change the size of the list or clear it entirely: >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] >>> letters ['a', 'b', 'c', 'd', 'e', 'f', 'g'] >>> # replace some values >>> letters[2:5] = ['C', 'D', 'E'] >>>",
    "content_length": 2910
  },
  {
    "id": "introduction_chunk_5",
    "source_file": "introduction",
    "chunk_index": 5,
    "content": "to slices is also possible, and this can even change the size of the list or clear it entirely: >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] >>> letters ['a', 'b', 'c', 'd', 'e', 'f', 'g'] >>> # replace some values >>> letters[2:5] = ['C', 'D', 'E'] >>> letters ['a', 'b', 'C', 'D', 'E', 'f', 'g'] >>> # now remove them >>> letters[2:5] = [] >>> letters ['a', 'b', 'f', 'g'] >>> # clear the list by replacing all the elements with an empty list >>> letters[:] = [] >>> letters [] The built-in function len() also applies to lists: >>> letters = ['a', 'b', 'c', 'd'] >>> len(letters) 4 It is possible to nest lists (create lists containing other lists), for example: >>> a = ['a', 'b', 'c'] >>> n = [1, 2, 3] >>> x = [a, n] >>> x [['a', 'b', 'c'], [1, 2, 3]] >>> x[0] ['a', 'b', 'c'] >>> x[0][1] 'b' 3.2. First Steps Towards ProgrammingÂ¶ Of course, we can use Python for more complicated tasks than adding two and two together. For instance, we can write an initial sub-sequence of the Fibonacci series as follows: >>> # Fibonacci series: >>> # the sum of two elements defines the next >>> a, b = 0, 1 >>> while a < 10: ... print(a) ... a, b = b, a+b ... 0 1 1 2 3 5 8 This example introduces several new features. The first line contains a multiple assignment: the variables a and b simultaneously get the new values 0 and 1. On the last line this is used again, demonstrating that the expressions on the right-hand side are all evaluated first before any of the assignments take place. The right-hand side expressions are evaluated from the left to the right. The while loop executes as long as the condition (here: a < 10) remains true. In Python, like in C, any non-zero integer value is true; zero is false. The condition may also be a string or list value, in fact any sequence; anything with a non-zero length is true, empty sequences are false. The test used in the example is a simple comparison. The standard comparison operators are written the same as in C: < (less than), > (greater than), == (equal to), <= (less than or equal to), >= (greater than or equal to) and != (not equal to). The body of the loop is indented: indentation is Pythonâs way of grouping statements. At the interactive prompt, you have to type a tab or space(s) for each indented line. In practice you will prepare more complicated input for Python with a text editor; all decent text editors have an auto-indent facility. When a compound statement is entered interactively, it must be followed by a blank line to indicate completion (since the parser cannot guess when you have typed the last line). Note that each line within a basic block must be indented by the same amount. The print() function",
    "content_length": 2691
  },
  {
    "id": "introduction_chunk_6",
    "source_file": "introduction",
    "chunk_index": 6,
    "content": "auto-indent facility. When a compound statement is entered interactively, it must be followed by a blank line to indicate completion (since the parser cannot guess when you have typed the last line). Note that each line within a basic block must be indented by the same amount. The print() function writes the value of the argument(s) it is given. It differs from just writing the expression you want to write (as we did earlier in the calculator examples) in the way it handles multiple arguments, floating-point quantities, and strings. Strings are printed without quotes, and a space is inserted between items, so you can format things nicely, like this: >>> i = 256*256 >>> print('The value of i is', i) The value of i is 65536 The keyword argument end can be used to avoid the newline after the output, or end the output with a different string: >>> a, b = 0, 1 >>> while a < 1000: ... print(a, end=',') ... a, b = b, a+b ... 0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987, Footnotes [1] Since ** has higher precedence than -, -3**2 will be interpreted as -(3**2) and thus result in -9. To avoid this and get 9, you can use (-3)**2. [2] Unlike other languages, special characters such as \\n have the same meaning with both single ('...') and double (\"...\") quotes. The only difference between the two is that within single quotes you donât need to escape \" (but you have to escape \\') and vice versa.",
    "content_length": 1409
  }
]